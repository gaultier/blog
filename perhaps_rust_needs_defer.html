<!DOCTYPE html>
<html>
<head>
<title>Perhaps Rust needs "defer"</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self"/>
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js"></script>
<script>
  window.onload = function() {
      hljs.registerLanguage("odin", function(e) {
      return {
          aliases: ["odin", "odinlang", "odin-lang"],
          keywords: {
              keyword: "auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",
              literal: "true false nil",
              built_in: "abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"
          },
          illegal: "</",
          contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e.QUOTE_STRING_MODE, {
                  begin: "'",
                  end: "[^\\\\]'"
              }, {
                  begin: "`",
                  end: "`"
              }]
          }, {
              className: "number",
              variants: [{
                  begin: e.C_NUMBER_RE + "[ijk]",
                  relevance: 1
              }, e.C_NUMBER_MODE]
          }]
      }
    });

    hljs.highlightAll();

    document.querySelectorAll('code').forEach((el, _i) => {
        if (0 == el.classList.length || el.classList.contains('language-sh') || el.classList.contains('language-shell') || el.classList.contains('language-bash')){
          el.classList.add('code-no-line-numbers');
          return; 
        }

        var lines = el.innerHTML.trimEnd().split('\n');
        var out = [];
        lines.forEach(function(l, i){
          out.push('<span class="line-number">' + (i+1).toString() + '</span> ' + l);
        });
        el.innerHTML = out.join('\n');
    });
  }
</script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <ul>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="#000000"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" class="mercado-match" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"></path>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z" fill="url(#paint0_linear_549_34)"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="white"/>
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="none" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path fill="#0085ff" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"></path></svg>
        </a> </li>
    </ul>
</div>
<div class="body">

		<div class="article-prelude">
			<p><a href="/blog"> ⏴ Back to all articles</a></p>

			<p class="publication-date">Published on 2024-11-06</p>
		</div>
		<div class="article-title">
		<h1>Perhaps Rust needs "defer"</h1>
		  <div class="tags"> <a href="/blog/articles-by-tag.html#rust" class="tag">Rust</a> <a href="/blog/articles-by-tag.html#c" class="tag">C</a></div>
 </div>

<p><em>Or, how FFI in Rust is a pain in the neck.</em></p>
<p><em>Discussions: <a href="https://old.reddit.com/r/rust/comments/1gktuw6/perhaps_rust_needs_defer/?">/r/rust</a>, <a href="https://old.reddit.com/r/programming/comments/1gktum4/perhaps_rust_needs_defer/?">/r/programming</a>, <a href="https://news.ycombinator.com/item?id=42058091">HN</a>, <a href="https://lobste.rs/s/2ka0ps/perhaps_rust_needs_defer">lobsters</a></em></p>
<p>In a previous article I <a href="/blog/lessons_learned_from_a_successful_rust_rewrite.html#i-am-still-chasing-memory-leaks">mentioned</a> that we use the <code>defer</code> idiom in Rust through a crate, but that it actually rarely gets past the borrow checker. Some comments were <s>claiming this issue does not exist</s> surprised and I did not have an example at hand.</p>
<p>Well, today at work I hit this issue again so I thought I would document it. And the whole experience showcases well how working in Rust with lots of FFI interop feels like.</p>
<h2>Setting the stage</h2>
<p>So, I have a Rust API like this:</p>
<pre><code class="language-rust">#[repr(C)]
pub struct Foo {
    value: usize,
}

#[no_mangle]
pub extern &quot;C&quot; fn MYLIB_get_foos(out_foos: *mut *mut Foo, out_foos_count: &amp;mut usize) -&gt; i32 {
    let res = vec![Foo { value: 42 }, Foo { value: 99 }];
    *out_foos_count = res.len();
    unsafe { *out_foos = res.leak().as_mut_ptr() };
    0
}
</code></pre>
<p>It allocates and returns an dynamically allocated array as a pointer and a length. Of course in reality, <code>Foo</code> has many fields and the values are not known in advance but what happens is that we send messages to a Smartcard to ask it to send us a piece of data residing on it, and it replies with some encoded messages that our library decodes and returns to the user.</p>
<p>I tell Cargo this is a static library:</p>
<pre><code class="language-toml"># Cargo.toml

[lib]
crate-type = [&quot;staticlib&quot;]
</code></pre>
<p>It's a straightforward API, so I generate the corresponding C header with cbindgen:</p>
<pre><code class="language-sh">$ cbindgen -v src/lib.rs --lang=c -o mylib.h
</code></pre>
<p>And I get:</p>
<pre><code class="language-c">#include &lt;stdarg.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Foo {
  uintptr_t value;
} Foo;

int32_t MYLIB_get_foos(struct Foo **out_foos, uintptr_t *out_foos_count);

</code></pre>
<p>I can now use it from C so:</p>
<pre><code class="language-c">#include &quot;mylib.h&quot;
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  Foo *foos = NULL;
  size_t foos_count = 0;
  assert(0 == MYLIB_get_foos(&amp;foos, &amp;foos_count));

  for (size_t i = 0; i &lt; foos_count; i++) {
    printf(&quot;%lu\n&quot;, foos[i].value);
  }

  if (NULL != foos) {
    free(foos);
  }
}
</code></pre>
<p>I build it with all the warnings enabled, run it with sanitizers on, and/or in Valgrind, all good.</p>
<p><em>This code has a subtle mistake (can you spot it?), so keep on reading.</em></p>
<blockquote>
<p>If we feel fancy (and non-portable), we can even automate the freeing of the memory in C with <code>__attribute(cleanup)</code>, like <code>defer</code> (ominous sounds). But let's not, today. Let's focus on the Rust side.</p>
</blockquote>
<p>Now, we are principled developers who test their code (right?). So let's write a Rust test for it. We expect it to be exactly the same as the C code:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn test_get_foos() {
        let mut foos = std::ptr::null_mut();
        let mut foos_count = 0;
        assert_eq!(0, super::MYLIB_get_foos(&amp;mut foos, &amp;mut foos_count));
    }
}
</code></pre>
<p>And it passes:</p>
<pre><code class="language-sh">$ cargo test
...
running 1 test
test tests::test_get_foos ... ok
...
</code></pre>
<p>Of course, we have not yet freed anything, so we expect Miri to complain, and it does:</p>
<pre><code class="language-sh">$ cargo +nightly miri test
...
error: memory leaked: alloc59029 (Rust heap, size: 16, align: 8), allocated here:
...
</code></pre>
<p>Note that the standard test runner does not report memory leaks, unfortunately. If Miri does not work for a given use case, and we still want to check that there are no leaks, we have to reach for nightly sanitizers or Valgrind.</p>
<h2>First attempt at freeing the memory properly</h2>
<p>Great, so let's free it at the end of the test, like C does, with <code>free</code> from libc, which we add as a dependency:</p>
<pre><code class="language-rust">
    #[test]
    fn test_get_foos() {
        ...

        unsafe { libc::free(foos as *mut std::ffi::c_void) };
    }
</code></pre>
<p>The test passes, great. Let's try with Miri:</p>
<pre><code class="language-sh">$ cargo +nightly miri test
...
 error: Undefined Behavior: deallocating alloc59029, which is Rust heap memory, using C heap deallocation operation
...
</code></pre>
<p>Hmm...ok...Well that's a bit weird, because what Rust does, when the <code>Vec</code> is allocated, is to call out to <code>malloc</code> from libc, as we can see with <code>strace</code>:</p>
<pre><code class="language-sh">$ strace -k -v -e brk ./a.out
...
brk(0x213c0000)                         = 0x213c0000
 &gt; /usr/lib64/libc.so.6(brk+0xb) [0x10fa9b]
 &gt; /usr/lib64/libc.so.6(__sbrk+0x6b) [0x118cab]
 &gt; /usr/lib64/libc.so.6(__default_morecore@GLIBC_2.2.5+0x15) [0xa5325]
 &gt; /usr/lib64/libc.so.6(sysmalloc+0x57b) [0xa637b]
 &gt; /usr/lib64/libc.so.6(_int_malloc+0xd39) [0xa7399]
 &gt; /usr/lib64/libc.so.6(tcache_init.part.0+0x36) [0xa7676]
 &gt; /usr/lib64/libc.so.6(__libc_malloc+0x125) [0xa7ef5]
 &gt; /home/pg/scratch/rust-blog2/a.out(alloc::alloc::alloc+0x6a) [0x4a145a]
 &gt; /home/pg/scratch/rust-blog2/a.out(alloc::alloc::Global::alloc_impl+0x140) [0x4a15a0]
 &gt; /home/pg/scratch/rust-blog2/a.out(alloc::alloc::exchange_malloc+0x3a) [0x4a139a]
 &gt; /home/pg/scratch/rust-blog2/a.out(MYLIB_get_foos+0x26) [0x407cc6]
 &gt; /home/pg/scratch/rust-blog2/a.out(main+0x2b) [0x407bfb]
</code></pre>
<p><em>Depending on your system, the call stack and specific system call may vary. It depends on the libc implementation, but point being, <code>malloc</code> from libc gets called by Rust.</em></p>
<p>Note the irony that we do not need to have a third-party dependency on the <code>libc</code> crate to allocate with <code>malloc</code> (being called under the hood), but we do need it, in order to deallocate the memory with <code>free</code>. Perhaps it's by design. Anyway. Where was I.</p>
<p>The docs for <code>Vec</code> indeed state:</p>
<blockquote>
<p>In general, Vec’s allocation details are very subtle — if you intend to allocate memory using a Vec and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using from_raw_parts to recover the Vec and then dropping it.</p>
</blockquote>
<p>But a few sentences later it also says:</p>
<blockquote>
<p>That is, the reported capacity is completely accurate, and can be relied on. It can even be used to manually free the memory allocated by a Vec if desired.</p>
</blockquote>
<p>So now I am confused, am I allowed to <code>free()</code> the <code>Vec</code>'s pointer directly or not?</p>
<p>By the way, we also spot in the same docs that there was no way to correctly free the <code>Vec</code> by calling <code>free()</code> on the pointer without knowing the capacity because:</p>
<blockquote>
<p>The pointer will never be null, so this type is null-pointer-optimized. However, the pointer might not actually point to allocated memory.</p>
</blockquote>
<p>Hmm, ok... So I guess the only way to not trigger Undefined Behavior on the C side when freeing, would be to keep the <code>capacity</code> of the <code>Vec</code> around and do:</p>
<pre><code class="language-c">  if (capacity &gt; 0) {
    free(foos);
  }
</code></pre>
<p>Let's ignore for now that this will surprise every C developer out there that have been doing <code>if (NULL != ptr) free(ptr)</code> for 50 years now.</p>
<p>I also tried to investigate how <code>drop</code> is implemented for <code>Vec</code> to understand what's going on and I stopped at this function in <code>core/src/alloc/mod.rs</code>:</p>
<pre><code class="language-rust">    unsafe fn deallocate(&amp;self, ptr: NonNull&lt;u8&gt;, layout: Layout);
</code></pre>
<p>Not sure where the implementation is located... Ok, let's move on.</p>
<p>Let's stay on the safe side and assume that we ought to use <code>Vec::from_raw_parts</code> and let the <code>Vec</code> free the memory when it gets dropped at the end of the scope. The only problem is: This function requires the pointer, the length, <em>and the capacity</em>. Wait, but we lost the capacity when we returned the pointer + length to the caller in <code>MYLIB_get_foos()</code>, and the caller <em>does not care one bit about the capacity</em>! It's irrelevant to them! At work, the mobile developers using our library rightfully asked: wait, what is this <code>cap</code> field? Why do I care? What do I do with it? If you are used to manually managing your own memory, this is a very old concept, but if you are used to a Garbage Collector, it's very much new.</p>
<h2>Second attempt at freeing the memory properly</h2>
<p>So, let's first try to dodge the problem the <s>hacky</s> simple way by pretending that the memory is allocated by a <code>Box</code>, which only needs the pointer, just like <code>free()</code>:</p>
<pre><code class="language-rust">    #[test]
    fn test_get_foos() {
        ...

        unsafe {
            let _ = Box::from_raw(foos);
        }
    }
</code></pre>
<p>That's I think the first instinct for a C developer. Whatever way the memory was heap allocated, be it with <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, be it for one struct or for a whole array, we want to free it with one call, passing it the base pointer. Let's ignore for a moment the docs that state that sometimes the pointer is heap-allocated and sometimes not.</p>
<p>So this Rust code builds. The test passes. And Miri is unhappy. I guess you know the drill by now:</p>
<pre><code class="language-sh">$ cargo +nightly miri test
...
 incorrect layout on deallocation: alloc59029 has size 16 and alignment 8, but gave size 8 and alignment 8
...
</code></pre>
<p>Let's take a second to marvel at the fact that Rust, probably the programming language the most strict at compile time, the if-it-builds-it-runs-dude-I-swear language, seems to work at compile time and at run time, but only fails when run under an experimental analyzer that only works in nightly and does not support lots of FFI patterns, which is the place where you need Miri the most!</p>
<p>That's the power of Undefined Behavior and <code>unsafe{}</code>. Again: audit all of your <code>unsafe</code> blocks, and be very suspicious of any third-party code that uses <code>unsafe</code>. I think Rust developers on average do not realize the harm that it is very easy to inflict to your program by using <code>unsafe</code> unwisely even if everything seems fine.</p>
<p>Anyways, I guess we have to refactor our whole C API to do it the Rust Way(tm)!</p>
<h2>Third attempt at freeing the memory properly</h2>
<p>So, in our codebase at work, we have defined this type:</p>
<pre><code class="language-rust">/// Owning Array i.e. `Vec&lt;T&gt;` in Rust or `std::vector&lt;T&gt;` in C++.
#[repr(C)]
pub struct OwningArrayC&lt;T&gt; {
    pub data: *mut T,
    pub len: usize,
    pub cap: usize,
}
</code></pre>
<p>It clearly signifies to the caller that they are in charge of freeing the memory, and also it carries the capacity of the <code>Vec</code> with it, so it's not lost.</p>
<p>In our project, this struct is used a lot. We also define a struct for non owning arrays (slices), etc.</p>
<p>So let's adapt the function, and also add a function in the API to free it for convenience:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn MYLIB_get_foos(out_foos: &amp;mut OwningArrayC&lt;Foo&gt;) -&gt; i32 {
    let res = vec![Foo { value: 42 }, Foo { value: 99 }];
    let len = res.len();
    let cap = res.capacity();

    *out_foos = OwningArrayC {
        data: res.leak().as_mut_ptr(),
        len,
        cap,
    };
    0
}

#[no_mangle]
pub extern &quot;C&quot; fn MYLIB_free_foos(foos: &amp;mut OwningArrayC&lt;Foo&gt;) {
    if foos.cap &gt; 0 {
        unsafe {
            let _ = Vec::from_raw_parts(foos.data, foos.len, foos.cap);
        }
    }
}
</code></pre>
<p>Let's also re-generate the C header, adapt the C code, rebuild it, communicate with the various projects that use our C API to make them adapt, etc...</p>
<p>Back to the Rust test:</p>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn test_get_foos() {
        let mut foos = crate::OwningArrayC {
            data: std::ptr::null_mut(),
            len: 0,
            cap: 0,
        };
        assert_eq!(0, super::MYLIB_get_foos(&amp;mut foos));
        println!(&quot;foos: {}&quot;, foos.len);
        super::MYLIB_free_foos(&amp;mut foos);
    }
}
</code></pre>
<p>And now, Miri is happy. Urgh. So, back to what we set out to do originally, <code>defer</code>.</p>
<h2>Defer</h2>
<p>The test is trivial right now but in real code, there are many code paths that sometimes allocate, sometimes not, with validation interleaved, and early returns, so we'd really like if we could statically demonstrate that the memory is always correctly freed. To ourselves, to auditors, etc.</p>
<p>One example at work of such hairy code is: building a linked list (in Rust), fetching more from the network based on the content of the last node in the list, and appending the additional data to the linked list, until some flag is detected in the encoded data. Oh, and there is also validation of the incoming data, so you might have to return early with a partially constructed list which should be properly cleaned up.</p>
<p>And there are many such examples like this, where the memory is often allocated/deallocated with a C API and it's not always possible to use RAII. So <code>defer</code> comes in handy.</p>
<hr />
<p>Let's use the <code>scopeguard</code> crate which provides a <code>defer!</code> macro, in the test, to automatically free the memory:</p>
<pre><code class="language-rust">    #[test]
    fn test_get_foos() {
        let mut foos = crate::OwningArrayC {
            data: std::ptr::null_mut(),
            len: 0,
            cap: 0,
        };
        assert_eq!(0, super::MYLIB_get_foos(&amp;mut foos));
        defer! {
            super::MYLIB_free_foos(&amp;mut foos);
        }

        println!(&quot;foos: {}&quot;, foos.len);
    }
</code></pre>
<p>And we get a compile error:</p>
<pre><code class="language-sh">$ cargo test
error[E0502]: cannot borrow `foos.len` as immutable because it is also borrowed as mutable
  --&gt; src/lib.rs:54:30
   |
50 | /         defer! {
51 | |             super::MYLIB_free_foos(&amp;mut foos);
   | |                                         ---- first borrow occurs due to use of `foos` in closure
52 | |         }
   | |_________- mutable borrow occurs here
53 |
54 |           println!(&quot;foos: {}&quot;, foos.len);
   |                                ^^^^^^^^ immutable borrow occurs here
55 |       }
   |       - mutable borrow might be used here, when `_guard` is dropped and runs the `Drop` code for type `ScopeGuard`
   |
</code></pre>
<p>Dum dum duuuum....Yes, we cannot use the <code>defer</code> idiom here (or at least I did not find a way). In some cases it's possible, in lots of cases it's not. The borrow checker considers that the <code>defer</code> block holds an exclusive mutable reference and the rest of the code cannot use that reference in any way.</p>
<p>Despite the fact, that the version without defer, and with defer, are semantically equivalent and the borrow checker is fine with the former and not with the latter.</p>
<h2>Possible solutions</h2>
<p>So that is why I argue that Rust should get a <code>defer</code> statement in the language and the borrow checker should be made aware of this construct to allow this approach to take place.</p>
<p>But what can we do otherwise? Are there any alternatives?</p>
<ul>
<li>We can be very careful and make sure we deallocate everything by hand in every code paths. Obviously that doesn't scale to team size, code complexity, etc. And it's unfortunate since using a defer-like approach in C with <code>__attribute(cleanup)</code> and in C++ by implementing our <a href="https://www.gingerbill.org/article/2015/08/19/defer-in-cpp/">own</a> <code>defer</code> is trivial. And even Go which is garbage-collected has a first-class <code>defer</code>. So not being able to do so in Rust is unfortunate.</li>
<li>We can use a goto-like approach, as a reader <a href="https://lobste.rs/s/n6gciw/lessons_learned_from_successful_rust#c_8pzmqg">suggested</a> in a previous article, even though Rust does not have <code>goto</code> per se:
<pre><code class="language-rust">fn foo_init() -&gt; *mut () { &amp;mut () }
fn foo_bar(_: *mut ()) -&gt; bool { false }
fn foo_baz(_: *mut ()) -&gt; bool { true }
fn foo_free(_: *mut ()) {}

fn main() {
  let f = foo_init();
  
  'free: {
    if foo_bar(f) {
        break 'free;
    }
    
    if foo_baz(f) {
        break 'free;
    }
    
    // ...
  };
  
  foo_free(f);
}
</code></pre>
It's very nifty, but I am not sure I would enjoy reading and writing this kind of code, especially with multiple levels of nesting. Again, it does not scale very well. But it's something.</li>
<li>We can work-around the borrow-checker to still use <code>defer</code> by refactoring our code to make it happy. Again, tedious and not always possible. One thing that possibly works is using handles (numerical ids) instead of pointers, so that they are <code>Copy</code> and the borrow checker does not see an issue with sharing/copying them. Like file descriptors work in Unix. The potential downside here is that it creates global state since some component has to bookkeep these handles and their mapping to the real pointer. But it's a <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html">common</a> pattern in gamedev.</li>
<li>Perhaps the borrow checker can be improved upon without adding <code>defer</code> to the language, 'just' by making it smarter?</li>
<li>We can use arenas everywhere and sail away in the sunset, leaving all these nasty problems behind us</li>
<li>Rust can stabilize various nightly APIs and tools, like custom allocators and sanitizers, to make development simpler</li>
</ul>
<h2>Conclusion</h2>
<p>Rust + FFI is nasty and has a lot of friction. I went at work through all these steps I went through in this article, and this happens a lot.</p>
<p>The crux of the issue is that there is a lot of knowledge to keep in our heads, lots of easy ways to shoot ourselves in the foot, and we have to reconcile what various tools tell us: even if the compiler is happy, the tests might not be. Even the tests are happy, Miri might not be. Even if we think we have done the right thing, we discover later, buried deep in the docs, that in fact, we didn't. It's definitely for experts only.</p>
<p>This should not be so hard! Won't somebody think of the <s>children</s> Rust FFI users?</p>
<p>EDIT: It's been <a href="https://chaos.social/@filmroellchen/113464336212759405">pointed</a> out to me that there are two on-going internal discussions by the Rust developers about this topic to possibly reserve the <code>defer</code> keyword for future use and maybe one day add this facility to the language: <a href="https://internals.rust-lang.org/t/pre-rfc-defer-statement/16644">1</a>, <a href="https://internals.rust-lang.org/t/a-defer-discussion/20387/71">2</a>.</p>
<h2>Addendum: One more gotcha</h2>
<p>Rust guarantees that the underlying pointer in <code>Vec</code> is not null. And <code>OwningArrayC</code> mirrors <code>Vec</code>, so it should be the same, right? Well consider this C code:</p>
<pre><code class="language-c">int main() {
    OwningArrayC_Foo foos = {0};
    if (some_condition) {
         MYLIB_get_foos(&amp;foos);
    }

    // `foos.data` is null here in some code paths.
    MYLIB_free_foos(&amp;foos);
}
</code></pre>
<p>In this case, <code>MYLIB_free_foos</code> actually can receive an argument with a null pointer (the <code>data</code> field), which would then trigger an assert inside <code>Vec::from_raw_parts</code>. So we should check that in <code>MY_LIB_free_foos</code>:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern &quot;C&quot; fn MYLIB_free_foos(foos: &amp;mut OwningArrayC&lt;Foo&gt;) {
    if !foos.data.is_null() {
        unsafe {
            let _ = Vec::from_raw_parts(foos.data, foos.len, foos.cap);
        }
    }
}
</code></pre>
<p>It might be a bit surprising to a pure Rust developer given the <code>Vec</code> guarantees, but since the C side could pass anything, we must be defensive.</p>
<p><a href="/blog"> ⏴ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
