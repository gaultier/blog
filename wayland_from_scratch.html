<!DOCTYPE html>
<html>
<head>
<title>Learn Wayland by writing a GUI from scratch</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self"/>
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js"></script>
<script>
  window.onload = function() {
      hljs.registerLanguage("odin", function(e) {
      return {
          aliases: ["odin", "odinlang", "odin-lang"],
          keywords: {
              keyword: "auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",
              literal: "true false nil",
              built_in: "abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"
          },
          illegal: "</",
          contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e.QUOTE_STRING_MODE, {
                  begin: "'",
                  end: "[^\\\\]'"
              }, {
                  begin: "`",
                  end: "`"
              }]
          }, {
              className: "number",
              variants: [{
                  begin: e.C_NUMBER_RE + "[ijk]",
                  relevance: 1
              }, e.C_NUMBER_MODE]
          }]
      }
    });

    hljs.highlightAll();

    document.querySelectorAll('code').forEach((el, _i) => {
        if (0 == el.classList.length || el.classList.contains('language-sh') || el.classList.contains('language-shell') || el.classList.contains('language-bash')){
          el.classList.add('code-no-line-numbers');
          return; 
        }

        var lines = el.innerHTML.trimEnd().split('\n');
        var out = [];
        lines.forEach(function(l, i){
          out.push('<span class="line-number">' + (i+1).toString() + '</span> ' + l);
        });
        el.innerHTML = out.join('\n');
    });
  }
</script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <ul>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="#000000"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" class="mercado-match" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"></path>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z" fill="url(#paint0_linear_549_34)"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="white"/>
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="none" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path fill="#0085ff" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"></path></svg>
        </a> </li>
    </ul>
</div>
<div class="body">

		<div class="article-prelude">
			<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

			<p class="publication-date">Published on 2023-10-12</p>
		</div>
		<div class="article-title">
		<h1>Learn Wayland by writing a GUI from scratch</h1>
		  <div class="tags"> <a href="/blog/articles-by-tag.html#c" class="tag">C</a> <a href="/blog/articles-by-tag.html#wayland" class="tag">Wayland</a> <a href="/blog/articles-by-tag.html#gui" class="tag">GUI</a> <a href="/blog/articles-by-tag.html#x11" class="tag">X11</a></div>
 </div>
 <strong>Table of contents</strong>
<ul>

<li>
	<a href="#68538529-what-do-we-need">What do we need?</a>
		</li>

<li>
	<a href="#1380440494-wayland-basics">Wayland basics</a>
		</li>

<li>
	<a href="#1574111941-opening-a-socket">Opening a socket</a>
		</li>

<li>
	<a href="#2441755118-creating-a-registry">Creating a registry</a>
		</li>

<li>
	<a href="#3967261249-shared-memory-the-frame-buffer">Shared memory: the frame buffer</a>
		</li>

<li>
	<a href="#1978770427-chatting-with-the-compositor">Chatting with the compositor</a>
		<ul>

<li>
	<a href="#3514934991-reacting-to-events-binding-interfaces">Reacting to events: binding interfaces</a>
		</li>

<li>
	<a href="#1821577778-using-the-interfaces-we-created">Using the interfaces we created</a>
		</li>

<li>
	<a href="#179983459-reacting-to-events-ping-pong">Reacting to events: ping/pong</a>
		</li>

<li>
	<a href="#3758960744-reacting-to-events-configure-ack-configure">Reacting to events: configure/ACK configure</a>
		</li>

<li>
	<a href="#312563814-rendering-a-frame-the-red-rectangle">Rendering a frame: the red rectangle</a>
		</li>

<li>
	<a href="#2090170599-rendering-a-frame-the-wayland-logo">Rendering a frame: The Wayland logo</a>
		</li>
</ul>
</li>

<li>
	<a href="#2533850313-the-end">The end</a>
		</li>

<li>
	<a href="#3976453400-addendum-the-full-code">Addendum: the full code</a>
		</li>
</ul>

<p><em>Discussions: <a href="https://news.ycombinator.com/item?id=37876896">Hacker News</a>, <a href="https://lobste.rs/s/385e2w/learn_wayland_by_writing_gui_from_scratch">Lobsters</a>.</em></p>
<p><a href="https://wayland.freedesktop.org/">Wayland</a> is all the rage those days. Distributions left and right switch to it, many readers of my previous article on <a href="/blog/x11_x64.html">writing a X11 GUI from scratch in x86_64 assembly</a> asked for a follow-up article about Wayland, and I now run Wayland on my desktop. So here we go, let's write a (very simple) GUI program with Wayland, without any libraries, this time in C.</p>
<p>Here is what we are working towards:</p>
<p><img src="wayland-screenshot-tiled1.png" alt="Result" /></p>
<p>We display the Wayland logo in its own window (we can see the mountain wallpaper in the background since we use a fixed size buffer). It's not quite Visual Studio yet, I know, but it's a good foundation for more in future articles, perhaps.</p>
<p>Why not in assembly again you ask? Well, the Wayland protocol has some peculiarities that necessitate the use of some C standard library macros to make it work reliably on different platforms (Linux, FreeBSD, etc): namely, sending a file descriptor over a UNIX socket. Maybe it could be done in assembly, but it would be much more tedious. Also, the Wayland protocol is completely asynchronous by nature, whereas the X11 protocol was more of a request-(maybe) response chatter, and as such, we have to keep track of some state in our program, and C makes it easier.</p>
<p>Now, if you want to follow along and translate the C snippets into assembly, go for it, it is doable, just tedious.</p>
<blockquote>
<p>If you spot an error, please open a <a href="https://github.com/gaultier/blog">Github issue</a>!</p>
</blockquote>
<h2 id="68538529-what-do-we-need">
	<a class="title" href="#68538529-what-do-we-need">What do we need?</a>
	<a class="hash-anchor" href="#68538529-what-do-we-need" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Not much: We'll use C99 so any C compiler of the last 20 years will do. Having a Wayland desktop to test the application will also greatly help.</p>
<p>Note that I have only run it on Linux; it should work (meaning: compile and run) on other platforms running Wayland such as FreeBSD, it's just that I have not tried.</p>
<p><em>Note that the code in this article has not been written in the most robust way, it simply exits when things are not how they should be for example. So, not production ready, but still a good learning resource and a good foundation for more.</em></p>
<h2 id="1380440494-wayland-basics">
	<a class="title" href="#1380440494-wayland-basics">Wayland basics</a>
	<a class="hash-anchor" href="#1380440494-wayland-basics" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Wayland is a protocol specification for GUI applications (and more), in short. We will write the client side, while the server side is a compositor which understands our protocol. If you have a Wayland desktop right now, a Wayland compositor is already running so there is nothing to do.</p>
<p>Much like X11, a client opens a UNIX socket, sends some commands in a specific format (which are different from the X11 ones), to open a window and the server can also send messages to notify the client to resize the window, that there is some keyboard input, etc. It's important to note that contrary to X11, in Wayland, the client only has access to its own window.</p>
<p>It is also interesting to note that Wayland is quite a limited protocol and any GUI will have to use extension protocols.</p>
<p>Most client applications use <code>libwayland</code> which is a library composed of C files that are autogenerated from a XML file describing the protocol.
The same goes for extension protocols: they simply are one XML file that is turned into C files, which are then compiled and linked to a GUI application.</p>
<p>Now, we will not do any of this: we will instead write our own serialization and deserialization functions, which is really not a lot of work as you will see.</p>
<p>There are many advantages:</p>
<ul>
<li>No need to link to external libraries: no build system complexities, no dynamic linking issues, and so on.</li>
<li>We do not have to use the callback system that <code>libwayland</code> requires.</li>
<li>We can use the I/O mechanism we wish to listen to incoming messages: blocking, <code>poll</code>, <code>select</code>, <code>epoll</code>, <code>io_uring</code>, <code>kqueue</code> on some systems, etc. Here, we will use blocking calls for simplicity but the world is your oyster.</li>
<li>Easy troubleshooting: 100% of the code is our own.</li>
<li>No XML</li>
<li>The protocols we will use are stable so the numeric values on the wire should not change underneath us, but in the unlikely event they do, we simply have to fix them in our code and compile again.</li>
</ul>
<p>So at this point you might be thinking: this is going to be so much work! Well, not really. Here are <strong>all</strong> of the Wayland protocol numeric values we will need, including the extension protocols:</p>
<pre><code class="language-c">static const uint32_t wayland_display_object_id = 1;
static const uint16_t wayland_wl_registry_event_global = 0;
static const uint16_t wayland_shm_pool_event_format = 0;
static const uint16_t wayland_wl_buffer_event_release = 0;
static const uint16_t wayland_xdg_wm_base_event_ping = 0;
static const uint16_t wayland_xdg_toplevel_event_configure = 0;
static const uint16_t wayland_xdg_toplevel_event_close = 1;
static const uint16_t wayland_xdg_surface_event_configure = 0;
static const uint16_t wayland_wl_display_get_registry_opcode = 1;
static const uint16_t wayland_wl_registry_bind_opcode = 0;
static const uint16_t wayland_wl_compositor_create_surface_opcode = 0;
static const uint16_t wayland_xdg_wm_base_pong_opcode = 3;
static const uint16_t wayland_xdg_surface_ack_configure_opcode = 4;
static const uint16_t wayland_wl_shm_create_pool_opcode = 0;
static const uint16_t wayland_xdg_wm_base_get_xdg_surface_opcode = 2;
static const uint16_t wayland_wl_shm_pool_create_buffer_opcode = 0;
static const uint16_t wayland_wl_surface_attach_opcode = 1;
static const uint16_t wayland_xdg_surface_get_toplevel_opcode = 1;
static const uint16_t wayland_wl_surface_commit_opcode = 6;
static const uint16_t wayland_wl_display_error_event = 0;
static const uint32_t wayland_format_xrgb8888 = 1;
static const uint32_t wayland_header_size = 8;
static const uint32_t color_channels = 4;
</code></pre>
<p>So, not that much!</p>
<h2 id="1574111941-opening-a-socket">
	<a class="title" href="#1574111941-opening-a-socket">Opening a socket</a>
	<a class="hash-anchor" href="#1574111941-opening-a-socket" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>The first step is opening a UNIX domain socket. Note that this step is exactly the same as for X11, save for the path of the socket. Also, X11 is designed to be used over the network so it does not have to be a UNIX domain socket, on the same machine - but everybody does so on their desktop machine anyway.</p>
<p>To craft the socket path, we follow these simple steps:</p>
<ul>
<li>If <code>$WAYLAND_DISPLAY</code> is set, attempt to connect to <code>$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY</code></li>
<li>Otherwise, attempt to connect to <code>$XDG_RUNTIME_DIR/wayland-0</code></li>
<li>Otherwise, fail</li>
</ul>
<p>Here goes, along with two utility macros we'll use everywhere:</p>
<pre><code class="language-c">#define cstring_len(s) (sizeof(s) - 1)

#define roundup_4(n) (((n) + 3) &amp; -4)

static int wayland_display_connect() {
  char *xdg_runtime_dir = getenv(&quot;XDG_RUNTIME_DIR&quot;);
  if (xdg_runtime_dir == NULL)
    return EINVAL;

  uint64_t xdg_runtime_dir_len = strlen(xdg_runtime_dir);

  struct sockaddr_un addr = {.sun_family = AF_UNIX};
  assert(xdg_runtime_dir_len &lt;= cstring_len(addr.sun_path));
  uint64_t socket_path_len = 0;

  memcpy(addr.sun_path, xdg_runtime_dir, xdg_runtime_dir_len);
  socket_path_len += xdg_runtime_dir_len;

  addr.sun_path[socket_path_len++] = '/';

  char *wayland_display = getenv(&quot;WAYLAND_DISPLAY&quot;);
  if (wayland_display == NULL) {
    char wayland_display_default[] = &quot;wayland-0&quot;;
    uint64_t wayland_display_default_len = cstring_len(wayland_display_default);

    memcpy(addr.sun_path + socket_path_len, wayland_display_default,
           wayland_display_default_len);
    socket_path_len += wayland_display_default_len;
  } else {
    uint64_t wayland_display_len = strlen(wayland_display);
    memcpy(addr.sun_path + socket_path_len, wayland_display,
           wayland_display_len);
    socket_path_len += wayland_display_len;
  }

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (fd == -1)
    exit(errno);

  if (connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)
    exit(errno);

  return fd;
}
</code></pre>
<p>In Wayland, there is no connection setup to do, such as sending some special messages, so there is nothing more to do.</p>
<h2 id="2441755118-creating-a-registry">
	<a class="title" href="#2441755118-creating-a-registry">Creating a registry</a>
	<a class="hash-anchor" href="#2441755118-creating-a-registry" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Now, to do anything useful, we want to create a registry: it is an object that allows us to query at runtime the capabilities of the compositor.</p>
<p>In Wayland, to create an object, we simply send the right message followed by an id of our own. Ids should be unique so we simply increment a number each time we want to create a new resource. After this is done, we will remember this number to be able to refer to it in later messages:</p>
<p>This is coincidentally our first message we send, so let's briefly go over the structure of a Wayland message. It is basically a RPC mechanism. All bytes are in the host endianness so there is nothing special to do about it:</p>
<ul>
<li>4 bytes: The id of the resource ('object') we want to call a method on</li>
<li>2 bytes: The opcode of the method we want to call</li>
<li>2 bytes: The size of the message</li>
<li>Depending on the method, arguments in their wire format follow</li>
</ul>
<p>The object id in this case is <code>1</code>, which is the singleton <code>wl_display</code> that already exists.
The method is: <code>get_registry(u32 new_id)</code> whose opcode we listed before.
The sole argument takes 4 bytes and is this incremental number we keep track of client-side.
It does not necessarily have to be incremental, but that's what <code>libwayland</code> does and also it's the easiest.</p>
<p>For convenience and efficiency, we always craft the message on the stack and do not allocate dynamic memory.</p>
<p>We first introduce a few utility functions to read and write parts of messages:</p>
<pre><code class="language-c">static void buf_write_u32(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint32_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint32_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_u16(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint16_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint16_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_string(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                             char *src, uint32_t src_len) {
  assert(*buf_size + src_len &lt;= buf_cap);

  buf_write_u32(buf, buf_size, buf_cap, src_len);
  memcpy(buf + *buf_size, src, roundup_4(src_len));
  *buf_size += roundup_4(src_len);
}

static uint32_t buf_read_u32(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint32_t));
  assert((size_t)*buf % sizeof(uint32_t) == 0);

  uint32_t res = *(uint32_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static uint16_t buf_read_u16(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint16_t));
  assert((size_t)*buf % sizeof(uint16_t) == 0);

  uint16_t res = *(uint16_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static void buf_read_n(char **buf, uint64_t *buf_size, char *dst, uint64_t n) {
  assert(*buf_size &gt;= n);

  memcpy(dst, *buf, n);

  *buf += n;
  *buf_size -= n;
}
</code></pre>
<p>And we finally can send our first message:</p>
<pre><code class="language-c">static uint32_t wayland_wl_display_get_registry(int fd) {
  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_display_object_id);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_display_get_registry_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, MSG_DONTWAIT))
    exit(errno);

  printf(&quot;-&gt; wl_display@%u.get_registry: wl_registry=%u\n&quot;,
         wayland_display_object_id, wayland_current_id);

  return wayland_current_id;
}
</code></pre>
<p>And by calling it, we have created our very first Wayland resource!</p>
<p><em>From this point on, the utility functions to send Wayland messages (<code>wayland_*</code>) will not be included in the code snippets for brevity (but you will find all of the code at the end!), just because they all are similar to the one above.</em></p>
<h2 id="3967261249-shared-memory-the-frame-buffer">
	<a class="title" href="#3967261249-shared-memory-the-frame-buffer">Shared memory: the frame buffer</a>
	<a class="hash-anchor" href="#3967261249-shared-memory-the-frame-buffer" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>To avoid drawing  a frame in our application, and having to send all of the bytes over the socket to the compositor, there is a smarter approach: the buffer should be shared between the two processes, so that no copying is required.</p>
<p>We need to synchronize the access between the two so that presenting the frame does not happen while we are still drawing it, and Wayland has us covered here.</p>
<p>First, we need to create this buffer. We are going to make it easier for us by using a fixed size. Wayland is going to send us 'resize' events, whenever the window size changes, which we will acknowledge and ignore. This is done here just to simplify a bit the article, obviously in a real application, you would resize the buffer.</p>
<p>First, we introduce a struct that will hold all of the client-side state so that we remember which resources we have created so far. We also need a super simple state machine for later to track whether the surface (i.e. the 'frame' data) should be drawn to, as mentioned:</p>
<pre><code class="language-c">typedef enum state_state_t state_state_t;
enum state_state_t {
  STATE_NONE,
  STATE_SURFACE_ACKED_CONFIGURE,
  STATE_SURFACE_ATTACHED,
};

typedef struct state_t state_t;
struct state_t {
  uint32_t wl_registry;
  uint32_t wl_shm;
  uint32_t wl_shm_pool;
  uint32_t wl_buffer;
  uint32_t xdg_wm_base;
  uint32_t xdg_surface;
  uint32_t wl_compositor;
  uint32_t wl_surface;
  uint32_t xdg_toplevel;
  uint32_t stride;
  uint32_t w;
  uint32_t h;
  uint32_t shm_pool_size;
  int shm_fd;
  uint8_t *shm_pool_data;

  state_state_t state;
};
</code></pre>
<p>We use it so in <code>main()</code>:</p>
<pre><code class="language-c">  state_t state = {
      .wl_registry = wayland_wl_display_get_registry(fd),
      .w = 117,
      .h = 150,
      .stride = 117 * color_channels,
  };

  // Single buffering.
  state.shm_pool_size = state.h * state.stride;
</code></pre>
<p>The window is a rectangle, of width <code>w</code> and height <code>h</code>. We will use the color format <code>xrgb8888</code> which is 4 color channels, each taking one bytes, so 4 bytes per pixel. This is one of the two formats that is guaranteed to be supported by the compositor per the specification. The stride counts how many bytes a horizontal row takes: <code>w * 4</code>.</p>
<p>And so, our buffer size for the frame is : <code>w * h * 4</code>. We use single buffering again for simplicity and also because we want to display a static image.</p>
<p>We could choose to use double or even triple buffering, thus respectively doubling or tripling the buffer size. The compositor is none the wiser - we would simply keep a counter client-side that increments each time we render a frame (and wraps around back to 0 when reaching the number of buffers), we would draw in the right location of this big buffer (i.e. at an offset), and attach the right part of the buffer to the surface.
All the Wayland calls would remain the same.</p>
<p>Alright, time to really create this buffer, and not only keep track of its size:</p>
<pre><code class="language-c">static void create_shared_memory_file(uint64_t size, state_t *state) {
  char name[255] = &quot;/&quot;;
  for (uint64_t i = 1; i &lt; cstring_len(name); i++) {
    name[i] = ((double)rand()) / (double)RAND_MAX * 26 + 'a';
  }

  int fd = shm_open(name, O_RDWR | O_EXCL | O_CREAT, 0600);
  if (fd == -1)
    exit(errno);

  assert(shm_unlink(name) != -1);

  if (ftruncate(fd, size) == -1)
    exit(errno);

  state-&gt;shm_pool_data =
      mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  assert(state-&gt;shm_pool_data != NULL);
  state-&gt;shm_fd = fd;
}
</code></pre>
<p>We use <code>shm_open(3)</code> to create a POSIX shared memory object, so that we later can send the corresponding file descriptor to the compositor so that the latter also has access to it. The flags mean:</p>
<ul>
<li><code>O_RDWR</code>: Read-write.</li>
<li><code>O_CREAT</code>: If the file does not exist, create it.</li>
<li><code>O_EXCL</code>: Return an error if the shared memory object with this name already exists (we do not want that another running instance of the application gets by mistake the same memory buffer).</li>
</ul>
<p>We alternatively could use <code>memfd_create(2)</code> which spares us from crafting a unique path but this is Linux specific.</p>
<p>We craft a unique, random path to avoid clashes with other running applications.</p>
<p>Right after, we remove the file on the filesystem with <code>shm_unlink</code> to not leave any traces when the program finishes. Note that the file descriptor remains valid since our process still has the file open (there is a reference counting mechanism in the kernel behind the scenes).</p>
<p>We then resize with <code>ftruncate</code> and memory map this file with <code>mmap(2)</code>, effectively allocating memory, with the <code>MAP_SHARED</code> flag to allow the compositor to also read this memory.</p>
<p>Later, we will send the file descriptor over the UNIX domain socket as ancillary data to the compositor.</p>
<p>Alright, we now have some memory to draw our frame to, but the compositor does not know of it yet. Let's tackle that now.</p>
<h2 id="1978770427-chatting-with-the-compositor">
	<a class="title" href="#1978770427-chatting-with-the-compositor">Chatting with the compositor</a>
	<a class="hash-anchor" href="#1978770427-chatting-with-the-compositor" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>We are going to exchange messages back and forth over the socket with the compositor. Let's use plain old blocking calls in <code>main</code> like it's the 70's. We read as much as we can from the socket:</p>
<pre><code class="language-c">  while (1) {
    char read_buf[4096] = &quot;&quot;;
    int64_t read_bytes = recv(fd, read_buf, sizeof(read_buf), 0);
    if (read_bytes == -1)
      exit(errno);

    char *msg = read_buf;
    uint64_t msg_len = (uint64_t)read_bytes;

    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);
    }
  }
</code></pre>
<p>The read buffer very likely now contains a sequence of various messages, which we parse and handle with
<code>wayland_handle_message</code> eagerly until the end of the buffer.
This might break if a message is spanning two different read buffers - a ring buffer would be more appropriate to handle this case gracefully, but again, for this article this is fine.</p>
<p><code>wayland_handle_message</code> reads the header part of every message as described in the beginning, and reacts to known opcodes and objects:</p>
<pre><code class="language-c">static void wayland_handle_message(int fd, state_t *state, char **msg,
                                   uint64_t *msg_len) {
  assert(*msg_len &gt;= 8);

  uint32_t object_id = buf_read_u32(msg, msg_len);
  assert(object_id &lt;= wayland_current_id);

  uint16_t opcode = buf_read_u16(msg, msg_len);

  uint16_t announced_size = buf_read_u16(msg, msg_len);
  assert(roundup_4(announced_size) &lt;= announced_size);

  uint32_t header_size =
      sizeof(object_id) + sizeof(opcode) + sizeof(announced_size);
  assert(announced_size &lt;= header_size + *msg_len);

  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
      // TODO
  }
  // Following: Lots of `if (opcode == ...) {... } else if (opcode = ...) { ... } [...]`
}
</code></pre>
<h3 id="3514934991-reacting-to-events-binding-interfaces">
	<a class="title" href="#3514934991-reacting-to-events-binding-interfaces">Reacting to events: binding interfaces</a>
	<a class="hash-anchor" href="#3514934991-reacting-to-events-binding-interfaces" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>At this point we have sent one message to the compositor: <code>wl_display@1.get_registry()</code> thanks to our C function <code>wayland_wl_display_get_registry</code>.
The compositor responds with a series of events, listing the available global objects, such as shared memory support, extension protocols, etc.</p>
<p>Each event contains the interface name, which is a string. Now, in the Wayland protocol, the string length gets padded to a multiple of four, so we have read those padding bytes as well.</p>
<p>If we see a global object that we are interested in, we create one of this type, and record the new id in our <code>state</code> structure for later use. While we're at it, we also handle error events. If the compositor does not like our messages, it will complain with some useful error messages in there:</p>
<pre><code class="language-c">  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
    uint32_t name = buf_read_u32(msg, msg_len);

    uint32_t interface_len = buf_read_u32(msg, msg_len);
    uint32_t padded_interface_len = roundup_4(interface_len);

    char interface[512] = &quot;&quot;;
    assert(padded_interface_len &lt;= cstring_len(interface));

    buf_read_n(msg, msg_len, interface, padded_interface_len);
    // The length includes the NULL terminator.
    assert(interface[interface_len - 1] == 0);

    uint32_t version = buf_read_u32(msg, msg_len);

    printf(&quot;&lt;- wl_registry@%u.global: name=%u interface=%.*s version=%u\n&quot;,
           state-&gt;wl_registry, name, interface_len, interface, version);

    assert(announced_size == sizeof(object_id) + sizeof(announced_size) +
                                 sizeof(opcode) + sizeof(name) +
                                 sizeof(interface_len) + padded_interface_len +
                                 sizeof(version));

    char wl_shm_interface[] = &quot;wl_shm&quot;;
    if (strcmp(wl_shm_interface, interface) == 0) {
      state-&gt;wl_shm = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char xdg_wm_base_interface[] = &quot;xdg_wm_base&quot;;
    if (strcmp(xdg_wm_base_interface, interface) == 0) {
      state-&gt;xdg_wm_base = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char wl_compositor_interface[] = &quot;wl_compositor&quot;;
    if (strcmp(wl_compositor_interface, interface) == 0) {
      state-&gt;wl_compositor = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    return;
  } else if (object_id == wayland_display_object_id &amp;&amp; opcode == wayland_wl_display_error_event) {
    uint32_t target_object_id = buf_read_u32(msg, msg_len);
    uint32_t code = buf_read_u32(msg, msg_len);
    char error[512] = &quot;&quot;;
    uint32_t error_len = buf_read_u32(msg, msg_len);
    buf_read_n(msg, msg_len, error, roundup_4(error_len));

    fprintf(stderr, &quot;fatal error: target_object_id=%u code=%u error=%s\n&quot;,
            target_object_id, code, error);
    exit(EINVAL);
  }
</code></pre>
<p>Remember: Since the Wayland protocol is a kind of RPC, we need to create the objects first before calling remote methods on them.</p>
<p>In terms of robustness, we do not have guarantees that every feature (i.e.: interface) we need in our application will be supported by the compositor. It could be a good idea to bail if the interfaces we require are not present.</p>
<h3 id="1821577778-using-the-interfaces-we-created">
	<a class="title" href="#1821577778-using-the-interfaces-we-created">Using the interfaces we created</a>
	<a class="hash-anchor" href="#1821577778-using-the-interfaces-we-created" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>We can now call methods on the new interfaces to create more entities we will need, namely:</p>
<ul>
<li>A <code>wl_surface</code></li>
<li>A <code>xdg_surface</code></li>
<li>A <code>xdg_toplevel</code></li>
</ul>
<p>The last two being entities from extension protocols, which is inconsequential in our implementation since we do not link against any libraries. This is just the same logic as the other messages and events from the core protocol.</p>
<p>Once we have done that, the surface is setup, and we commit it, to signal to the compositor to atomically apply the changes to the surface.</p>
<pre><code class="language-c">
    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);

    if (state.wl_compositor != 0 &amp;&amp; state.wl_shm != 0 &amp;&amp;
        state.xdg_wm_base != 0 &amp;&amp;
        state.wl_surface == 0) { // Bind phase complete, need to create surface.
      assert(state.state == STATE_NONE);

      state.wl_surface = wayland_wl_compositor_create_surface(fd, &amp;state);
      state.xdg_surface = wayland_xdg_wm_base_get_xdg_surface(fd, &amp;state);
      state.xdg_toplevel = wayland_xdg_surface_get_toplevel(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);
    }
  }
</code></pre>
<h3 id="179983459-reacting-to-events-ping-pong">
	<a class="title" href="#179983459-reacting-to-events-ping-pong">Reacting to events: ping/pong</a>
	<a class="hash-anchor" href="#179983459-reacting-to-events-ping-pong" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>For some entities, the Wayland compositor will send us a ping message and expect a pong back to ensure our application is responsive and not deadlocked or frozen.</p>
<p>We just have to add one more <code>if</code> to the long list of <code>if</code>s to handle each event from the compositor:</p>
<pre><code class="language-c">if (object_id == state-&gt;xdg_wm_base &amp;&amp;
             opcode == wayland_xdg_wm_base_event_ping) {
    uint32_t ping = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_wm_base@%u.ping: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
    wayland_xdg_wm_base_pong(fd, state, ping);

    return;
  }
</code></pre>
<h3 id="3758960744-reacting-to-events-configure-ack-configure">
	<a class="title" href="#3758960744-reacting-to-events-configure-ack-configure">Reacting to events: configure/ACK configure</a>
	<a class="hash-anchor" href="#3758960744-reacting-to-events-configure-ack-configure" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>Akin to the previous ping/pong mechanism, we receive a <code>configure</code> event for the <code>xdg_surface</code> and we reply with a <code>ack_configure</code> message.</p>
<p>This is an important milestone since from that point on, we can start rendering our frame! We thus advance our little state machine:</p>
<pre><code class="language-c">if (object_id == state-&gt;xdg_surface &amp;&amp;
             opcode == wayland_xdg_surface_event_configure) {
    uint32_t configure = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_surface@%u.configure: configure=%u\n&quot;, state-&gt;xdg_surface,
           configure);
    wayland_xdg_surface_ack_configure(fd, state, configure);
    state-&gt;state = STATE_SURFACE_ACKED_CONFIGURE;

    return;
  } 
</code></pre>
<h3 id="312563814-rendering-a-frame-the-red-rectangle">
	<a class="title" href="#312563814-rendering-a-frame-the-red-rectangle">Rendering a frame: the red rectangle</a>
	<a class="hash-anchor" href="#312563814-rendering-a-frame-the-red-rectangle" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>Once the configure/ack configure step has been completed, we can render a frame.</p>
<p>To do so, we need to create two final entities: a shared memory pool (<code>wl_shm_pool</code>) and a <code>wl_buffer</code> if they do not exist yet.</p>
<p>Finally, we fiddle with the pixel data anyway we want, remembering the color format we picked (XRGB8888), attach the buffer to the surface, and commit the surface.</p>
<p>This acts as synchronization mechanism between the client and the compositor to avoid presenting a half-rendered frame. To sum up:</p>
<ol>
<li>The <code>ack_configure</code> event signals us that we can start rendering the frame</li>
<li>We render the frame client-side by setting the pixel data to whatever we want</li>
<li>We send the <code>attach</code> + <code>commit</code> messages to notify the compositor that the frame is ready to be presented</li>
<li>We advance our state machine to avoid writing to the frame data while the compositor is presenting it</li>
</ol>
<p>So let's show a red rectangle as a warm-up. The alpha component is completely ignored as far as I can tell in this color format:</p>
<pre><code class="language-c">    if (state.state == STATE_SURFACE_ACKED_CONFIGURE) {
      // Render a frame.
      assert(state.wl_surface != 0);
      assert(state.xdg_surface != 0);
      assert(state.xdg_toplevel != 0);

      if (state.wl_shm_pool == 0)
        state.wl_shm_pool = wayland_wl_shm_create_pool(fd, &amp;state);
      if (state.wl_buffer == 0)
        state.wl_buffer = wayland_wl_shm_pool_create_buffer(fd, &amp;state);

      assert(state.shm_pool_data != 0);
      assert(state.shm_pool_size != 0);

      uint32_t *pixels = (uint32_t *)state.shm_pool_data;
      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = 0xff;
        uint8_t g = 0;
        uint8_t b = 0;
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
      wayland_wl_surface_attach(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);

      state.state = STATE_SURFACE_ATTACHED;
    }
</code></pre>
<p>Result:</p>
<p><img src="wayland-screenshot-red.png" alt="Result, red" /></p>
<h3 id="2090170599-rendering-a-frame-the-wayland-logo">
	<a class="title" href="#2090170599-rendering-a-frame-the-wayland-logo">Rendering a frame: The Wayland logo</a>
	<a class="hash-anchor" href="#2090170599-rendering-a-frame-the-wayland-logo" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>Let's render something more interesting. We download the <a href="https://wayland.freedesktop.org/wayland.png">Wayland logo</a>, but we do not want to have to deal with a complicated format like PNG (because we then have to uncompress the image data with <code>zlib</code> or similar).</p>
<p>We thus convert it offline to a simpler image format, PPM6, and then embed the raw pixel data in our code as an byte array, skipping over the first 15 bytes which are metadata:</p>
<pre><code class="language-shell">$ file wayland.png
wayland.png: PNG image data, 117 x 150, 8-bit/color RGBA, non-interlaced
$ convert wayland.png wayland.ppm
$ file wayland.ppm
wayland.ppm: Netpbm image data, size = 117 x 150, rawbits, pixmap
$ xxd -s +15 -i wayland.ppm  &gt; wayland-logo.h
$ sed -i 's/wayland_ppm/wayland_logo/g' wayland-logo.h
</code></pre>
<p><em>The resulting C array created by <code>xxd</code> will be named after the input file i.e. <code>wayland_ppm</code>. We rename it with the last command to something more human-readable.</em></p>
<p>The image is now in the <code>RGB</code> format (3 bytes per pixel), which we have to convert to the <code>XRGB</code> format (4 bytes per pixel). Our frame rendering loop becomes:</p>
<pre><code class="language-c">#include &quot;wayland-logo.h&quot;

[...]

      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = wayland_logo[i * 3 + 0];
        uint8_t g = wayland_logo[i * 3 + 1];
        uint8_t b = wayland_logo[i * 3 + 2];
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
</code></pre>
<p>And finally we see the result.</p>
<p>Tiled: <img src="wayland-screenshot-tiled1.png" alt="Result, tiled" /></p>
<p>Floating: <img src="wayland-screenshot-floating.png" alt="Result, floating" /></p>
<p><em>Note: We handle the absolute minimum set of events coming from the compositor to make it work in a simple way. If your particular compositor sends more events, they will have to be read (and possibly ignored). Since the Wayland protocol uses a Tag-Length-Value (TLV) encoding, one can simply skip over <code>&lt;length&gt;</code> bytes if the opcode is unknown. But some events will demand a reply (e.g. ping/pong)!</em></p>
<h2 id="2533850313-the-end">
	<a class="title" href="#2533850313-the-end">The end</a>
	<a class="hash-anchor" href="#2533850313-the-end" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>It was not that much work to go from zero to a working GUI application, albeit a simplistic one.</p>
<p>Compared to X11, it was a bit more work, but not that much. The barrier of entry is higher but the concepts and architecture are more sound, it seems to me.</p>
<p>The setup is a bit tedious but once this is done, we are in practice going to spend all of our time in the frame rendering code, and perhaps add support for a few additional events (we do not yet support keyboard or mouse events, for example, or animations, which would require us to notify the compositor that a region was 'damaged' meaning modified, and needs re-rendering).</p>
<p>Thus, I have the feeling that Wayland really goes out of the way once the initial scaffolding is done.</p>
<p>As for the next steps, I would like to draw some text, and react to user input events. Maybe even port something like <a href="https://github.com/rxi/microui">microui</a>, which only needs a few drawing routines, to our application.</p>
<h2 id="3976453400-addendum-the-full-code">
	<a class="title" href="#3976453400-addendum-the-full-code">Addendum: the full code</a>
	<a class="hash-anchor" href="#3976453400-addendum-the-full-code" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p><em>Do not forget to generate <code>wayland-logo.h</code> with the aforementioned commands!</em></p>
<p>Compile with: <code>cc -std=c99 wayland.c -Ofast</code>.</p>
<details>
  <summary>The full code</summary>
<pre><code class="language-c">#define _POSIX_C_SOURCE 200112L
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;

#include &quot;wayland-logo.h&quot;

#define cstring_len(s) (sizeof(s) - 1)

#define roundup_4(n) (((n) + 3) &amp; -4)

static uint32_t wayland_current_id = 1;

static const uint32_t wayland_display_object_id = 1;
static const uint16_t wayland_wl_registry_event_global = 0;
static const uint16_t wayland_shm_pool_event_format = 0;
static const uint16_t wayland_wl_buffer_event_release = 0;
static const uint16_t wayland_xdg_wm_base_event_ping = 0;
static const uint16_t wayland_xdg_toplevel_event_configure = 0;
static const uint16_t wayland_xdg_toplevel_event_close = 1;
static const uint16_t wayland_xdg_surface_event_configure = 0;
static const uint16_t wayland_wl_display_get_registry_opcode = 1;
static const uint16_t wayland_wl_registry_bind_opcode = 0;
static const uint16_t wayland_wl_compositor_create_surface_opcode = 0;
static const uint16_t wayland_xdg_wm_base_pong_opcode = 3;
static const uint16_t wayland_xdg_surface_ack_configure_opcode = 4;
static const uint16_t wayland_wl_shm_create_pool_opcode = 0;
static const uint16_t wayland_xdg_wm_base_get_xdg_surface_opcode = 2;
static const uint16_t wayland_wl_shm_pool_create_buffer_opcode = 0;
static const uint16_t wayland_wl_surface_attach_opcode = 1;
static const uint16_t wayland_xdg_surface_get_toplevel_opcode = 1;
static const uint16_t wayland_wl_surface_commit_opcode = 6;
static const uint16_t wayland_wl_display_error_event = 0;
static const uint32_t wayland_format_xrgb8888 = 1;
static const uint32_t wayland_header_size = 8;
static const uint32_t color_channels = 4;

typedef enum state_state_t state_state_t;
enum state_state_t {
  STATE_NONE,
  STATE_SURFACE_ACKED_CONFIGURE,
  STATE_SURFACE_ATTACHED,
};

typedef struct state_t state_t;
struct state_t {
  uint32_t wl_registry;
  uint32_t wl_shm;
  uint32_t wl_shm_pool;
  uint32_t wl_buffer;
  uint32_t xdg_wm_base;
  uint32_t xdg_surface;
  uint32_t wl_compositor;
  uint32_t wl_surface;
  uint32_t xdg_toplevel;
  uint32_t stride;
  uint32_t w;
  uint32_t h;
  uint32_t shm_pool_size;
  int shm_fd;
  uint8_t *shm_pool_data;

  state_state_t state;
};

static int wayland_display_connect() {
  char *xdg_runtime_dir = getenv(&quot;XDG_RUNTIME_DIR&quot;);
  if (xdg_runtime_dir == NULL)
    return EINVAL;

  uint64_t xdg_runtime_dir_len = strlen(xdg_runtime_dir);

  struct sockaddr_un addr = {.sun_family = AF_UNIX};
  assert(xdg_runtime_dir_len &lt;= cstring_len(addr.sun_path));
  uint64_t socket_path_len = 0;

  memcpy(addr.sun_path, xdg_runtime_dir, xdg_runtime_dir_len);
  socket_path_len += xdg_runtime_dir_len;

  addr.sun_path[socket_path_len++] = '/';

  char *wayland_display = getenv(&quot;WAYLAND_DISPLAY&quot;);
  if (wayland_display == NULL) {
    char wayland_display_default[] = &quot;wayland-0&quot;;
    uint64_t wayland_display_default_len = cstring_len(wayland_display_default);

    memcpy(addr.sun_path + socket_path_len, wayland_display_default,
           wayland_display_default_len);
    socket_path_len += wayland_display_default_len;
  } else {
    uint64_t wayland_display_len = strlen(wayland_display);
    memcpy(addr.sun_path + socket_path_len, wayland_display,
           wayland_display_len);
    socket_path_len += wayland_display_len;
  }

  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (fd == -1)
    exit(errno);

  if (connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1)
    exit(errno);

  return fd;
}

static void buf_write_u32(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint32_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint32_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_u16(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                          uint16_t x) {
  assert(*buf_size + sizeof(x) &lt;= buf_cap);
  assert(((size_t)buf + *buf_size) % sizeof(x) == 0);

  *(uint16_t *)(buf + *buf_size) = x;
  *buf_size += sizeof(x);
}

static void buf_write_string(char *buf, uint64_t *buf_size, uint64_t buf_cap,
                             char *src, uint32_t src_len) {
  assert(*buf_size + src_len &lt;= buf_cap);

  buf_write_u32(buf, buf_size, buf_cap, src_len);
  memcpy(buf + *buf_size, src, roundup_4(src_len));
  *buf_size += roundup_4(src_len);
}

static uint32_t buf_read_u32(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint32_t));
  assert((size_t)*buf % sizeof(uint32_t) == 0);

  uint32_t res = *(uint32_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static uint16_t buf_read_u16(char **buf, uint64_t *buf_size) {
  assert(*buf_size &gt;= sizeof(uint16_t));
  assert((size_t)*buf % sizeof(uint16_t) == 0);

  uint16_t res = *(uint16_t *)(*buf);
  *buf += sizeof(res);
  *buf_size -= sizeof(res);

  return res;
}

static void buf_read_n(char **buf, uint64_t *buf_size, char *dst, uint64_t n) {
  assert(*buf_size &gt;= n);

  memcpy(dst, *buf, n);

  *buf += n;
  *buf_size -= n;
}

static uint32_t wayland_wl_display_get_registry(int fd) {
  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_display_object_id);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_display_get_registry_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_display@%u.get_registry: wl_registry=%u\n&quot;,
         wayland_display_object_id, wayland_current_id);

  return wayland_current_id;
}

static uint32_t wayland_wl_registry_bind(int fd, uint32_t registry,
                                         uint32_t name, char *interface,
                                         uint32_t interface_len,
                                         uint32_t version) {
  uint64_t msg_size = 0;
  char msg[512] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), registry);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_registry_bind_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(name) + sizeof(interface_len) +
      roundup_4(interface_len) + sizeof(version) + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), name);
  buf_write_string(msg, &amp;msg_size, sizeof(msg), interface, interface_len);
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), version);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  assert(msg_size == roundup_4(msg_size));

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_registry@%u.bind: name=%u interface=%.*s version=%u\n&quot;,
         registry, name, interface_len, interface, version);

  return wayland_current_id;
}

static uint32_t wayland_wl_compositor_create_surface(int fd, state_t *state) {
  assert(state-&gt;wl_compositor &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_compositor);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_compositor_create_surface_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_compositor@%u.create_surface: wl_surface=%u\n&quot;,
         state-&gt;wl_compositor, wayland_current_id);

  return wayland_current_id;
}

static void create_shared_memory_file(uint64_t size, state_t *state) {
  char name[255] = &quot;/&quot;;
  for (uint64_t i = 1; i &lt; cstring_len(name); i++) {
    name[i] = ((double)rand()) / (double)RAND_MAX * 26 + 'a';
  }

  int fd = shm_open(name, O_RDWR | O_EXCL | O_CREAT, 0600);
  if (fd == -1)
    exit(errno);

  assert(shm_unlink(name) != -1);

  if (ftruncate(fd, size) == -1)
    exit(errno);

  state-&gt;shm_pool_data =
      mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  assert(state-&gt;shm_pool_data != NULL);
  state-&gt;shm_fd = fd;
}

static void wayland_xdg_wm_base_pong(int fd, state_t *state, uint32_t ping) {
  assert(state-&gt;xdg_wm_base &gt; 0);
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_wm_base);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_xdg_wm_base_pong_opcode);

  uint16_t msg_announced_size = wayland_header_size + sizeof(ping);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), ping);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_wm_base@%u.pong: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
}

static void wayland_xdg_surface_ack_configure(int fd, state_t *state,
                                              uint32_t configure) {
  assert(state-&gt;xdg_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_surface_ack_configure_opcode);

  uint16_t msg_announced_size = wayland_header_size + sizeof(configure);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), configure);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_surface@%u.ack_configure: configure=%u\n&quot;, state-&gt;xdg_surface,
         configure);
}

static uint32_t wayland_wl_shm_create_pool(int fd, state_t *state) {
  assert(state-&gt;shm_pool_size &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_shm);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_shm_create_pool_opcode);

  uint16_t msg_announced_size = wayland_header_size +
                                sizeof(wayland_current_id) +
                                sizeof(state-&gt;shm_pool_size);

  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;shm_pool_size);

  assert(roundup_4(msg_size) == msg_size);

  // Send the file descriptor as ancillary data.
  // UNIX/Macros monstrosities ahead.
  char buf[CMSG_SPACE(sizeof(state-&gt;shm_fd))] = &quot;&quot;;

  struct iovec io = {.iov_base = msg, .iov_len = msg_size};
  struct msghdr socket_msg = {
      .msg_iov = &amp;io,
      .msg_iovlen = 1,
      .msg_control = buf,
      .msg_controllen = sizeof(buf),
  };

  struct cmsghdr *cmsg = CMSG_FIRSTHDR(&amp;socket_msg);
  cmsg-&gt;cmsg_level = SOL_SOCKET;
  cmsg-&gt;cmsg_type = SCM_RIGHTS;
  cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(state-&gt;shm_fd));

  *((int *)CMSG_DATA(cmsg)) = state-&gt;shm_fd;
  socket_msg.msg_controllen = CMSG_SPACE(sizeof(state-&gt;shm_fd));

  if (sendmsg(fd, &amp;socket_msg, 0) == -1)
    exit(errno);

  printf(&quot;-&gt; wl_shm@%u.create_pool: wl_shm_pool=%u\n&quot;, state-&gt;wl_shm,
         wayland_current_id);

  return wayland_current_id;
}

static uint32_t wayland_xdg_wm_base_get_xdg_surface(int fd, state_t *state) {
  assert(state-&gt;xdg_wm_base &gt; 0);
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_wm_base);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_wm_base_get_xdg_surface_opcode);

  uint16_t msg_announced_size = wayland_header_size +
                                sizeof(wayland_current_id) +
                                sizeof(state-&gt;wl_surface);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_wm_base@%u.get_xdg_surface: xdg_surface=%u wl_surface=%u\n&quot;,
         state-&gt;xdg_wm_base, wayland_current_id, state-&gt;wl_surface);

  return wayland_current_id;
}

static uint32_t wayland_wl_shm_pool_create_buffer(int fd, state_t *state) {
  assert(state-&gt;wl_shm_pool &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_shm_pool);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_wl_shm_pool_create_buffer_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id) + sizeof(uint32_t) * 5;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  uint32_t offset = 0;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), offset);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;w);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;h);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;stride);

  uint32_t format = wayland_format_xrgb8888;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), format);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_shm_pool@%u.create_buffer: wl_buffer=%u\n&quot;, state-&gt;wl_shm_pool,
         wayland_current_id);

  return wayland_current_id;
}

static void wayland_wl_surface_attach(int fd, state_t *state) {
  assert(state-&gt;wl_surface &gt; 0);
  assert(state-&gt;wl_buffer &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_surface_attach_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(state-&gt;wl_buffer) + sizeof(uint32_t) * 2;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_buffer);

  uint32_t x = 0, y = 0;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), x);
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), y);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_surface@%u.attach: wl_buffer=%u\n&quot;, state-&gt;wl_surface,
         state-&gt;wl_buffer);
}

static uint32_t wayland_xdg_surface_get_toplevel(int fd, state_t *state) {
  assert(state-&gt;xdg_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;xdg_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg),
                wayland_xdg_surface_get_toplevel_opcode);

  uint16_t msg_announced_size =
      wayland_header_size + sizeof(wayland_current_id);
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  wayland_current_id++;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), wayland_current_id);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; xdg_surface@%u.get_toplevel: xdg_toplevel=%u\n&quot;,
         state-&gt;xdg_surface, wayland_current_id);

  return wayland_current_id;
}

static void wayland_wl_surface_commit(int fd, state_t *state) {
  assert(state-&gt;wl_surface &gt; 0);

  uint64_t msg_size = 0;
  char msg[128] = &quot;&quot;;
  buf_write_u32(msg, &amp;msg_size, sizeof(msg), state-&gt;wl_surface);

  buf_write_u16(msg, &amp;msg_size, sizeof(msg), wayland_wl_surface_commit_opcode);

  uint16_t msg_announced_size = wayland_header_size;
  assert(roundup_4(msg_announced_size) == msg_announced_size);
  buf_write_u16(msg, &amp;msg_size, sizeof(msg), msg_announced_size);

  if ((int64_t)msg_size != send(fd, msg, msg_size, 0))
    exit(errno);

  printf(&quot;-&gt; wl_surface@%u.commit: \n&quot;, state-&gt;wl_surface);
}

static void wayland_handle_message(int fd, state_t *state, char **msg,
                                   uint64_t *msg_len) {
  assert(*msg_len &gt;= 8);

  uint32_t object_id = buf_read_u32(msg, msg_len);
  assert(object_id &lt;= wayland_current_id);

  uint16_t opcode = buf_read_u16(msg, msg_len);

  uint16_t announced_size = buf_read_u16(msg, msg_len);
  assert(roundup_4(announced_size) &lt;= announced_size);

  uint32_t header_size =
      sizeof(object_id) + sizeof(opcode) + sizeof(announced_size);
  assert(announced_size &lt;= header_size + *msg_len);

  if (object_id == state-&gt;wl_registry &amp;&amp;
      opcode == wayland_wl_registry_event_global) {
    uint32_t name = buf_read_u32(msg, msg_len);

    uint32_t interface_len = buf_read_u32(msg, msg_len);
    uint32_t padded_interface_len = roundup_4(interface_len);

    char interface[512] = &quot;&quot;;
    assert(padded_interface_len &lt;= cstring_len(interface));

    buf_read_n(msg, msg_len, interface, padded_interface_len);
    // The length includes the NULL terminator.
    assert(interface[interface_len - 1] == 0);

    uint32_t version = buf_read_u32(msg, msg_len);

    printf(&quot;&lt;- wl_registry@%u.global: name=%u interface=%.*s version=%u\n&quot;,
           state-&gt;wl_registry, name, interface_len, interface, version);

    assert(announced_size == sizeof(object_id) + sizeof(announced_size) +
                                 sizeof(opcode) + sizeof(name) +
                                 sizeof(interface_len) + padded_interface_len +
                                 sizeof(version));

    char wl_shm_interface[] = &quot;wl_shm&quot;;
    if (strcmp(wl_shm_interface, interface) == 0) {
      state-&gt;wl_shm = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char xdg_wm_base_interface[] = &quot;xdg_wm_base&quot;;
    if (strcmp(xdg_wm_base_interface, interface) == 0) {
      state-&gt;xdg_wm_base = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    char wl_compositor_interface[] = &quot;wl_compositor&quot;;
    if (strcmp(wl_compositor_interface, interface) == 0) {
      state-&gt;wl_compositor = wayland_wl_registry_bind(
          fd, state-&gt;wl_registry, name, interface, interface_len, version);
    }

    return;
  } else if (object_id == wayland_display_object_id &amp;&amp;
             opcode == wayland_wl_display_error_event) {
    uint32_t target_object_id = buf_read_u32(msg, msg_len);
    uint32_t code = buf_read_u32(msg, msg_len);
    char error[512] = &quot;&quot;;
    uint32_t error_len = buf_read_u32(msg, msg_len);
    buf_read_n(msg, msg_len, error, roundup_4(error_len));

    fprintf(stderr, &quot;fatal error: target_object_id=%u code=%u error=%s\n&quot;,
            target_object_id, code, error);
    exit(EINVAL);
  } else if (object_id == state-&gt;wl_shm &amp;&amp;
             opcode == wayland_shm_pool_event_format) {

    uint32_t format = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- wl_shm: format=%#x\n&quot;, format);
    return;
  } else if (object_id == state-&gt;wl_buffer &amp;&amp;
             opcode == wayland_wl_buffer_event_release) {
    // No-op, for now.

    printf(&quot;&lt;- xdg_wl_buffer@%u.release\n&quot;, state-&gt;wl_buffer);
    return;
  } else if (object_id == state-&gt;xdg_wm_base &amp;&amp;
             opcode == wayland_xdg_wm_base_event_ping) {
    uint32_t ping = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_wm_base@%u.ping: ping=%u\n&quot;, state-&gt;xdg_wm_base, ping);
    wayland_xdg_wm_base_pong(fd, state, ping);

    return;
  } else if (object_id == state-&gt;xdg_toplevel &amp;&amp;
             opcode == wayland_xdg_toplevel_event_configure) {
    uint32_t w = buf_read_u32(msg, msg_len);
    uint32_t h = buf_read_u32(msg, msg_len);
    uint32_t len = buf_read_u32(msg, msg_len);
    char buf[256] = &quot;&quot;;
    assert(len &lt;= sizeof(buf));
    buf_read_n(msg, msg_len, buf, len);

    printf(&quot;&lt;- xdg_toplevel@%u.configure: w=%u h=%u states[%u]\n&quot;,
           state-&gt;xdg_toplevel, w, h, len);

    return;
  } else if (object_id == state-&gt;xdg_surface &amp;&amp;
             opcode == wayland_xdg_surface_event_configure) {
    uint32_t configure = buf_read_u32(msg, msg_len);
    printf(&quot;&lt;- xdg_surface@%u.configure: configure=%u\n&quot;, state-&gt;xdg_surface,
           configure);
    wayland_xdg_surface_ack_configure(fd, state, configure);
    state-&gt;state = STATE_SURFACE_ACKED_CONFIGURE;

    return;
  } else if (object_id == state-&gt;xdg_toplevel &amp;&amp;
             opcode == wayland_xdg_toplevel_event_close) {
    printf(&quot;&lt;- xdg_toplevel@%u.close\n&quot;, state-&gt;xdg_toplevel);
    exit(0);
  }

  fprintf(stderr, &quot;object_id=%u opcode=%u msg_len=%lu\n&quot;, object_id, opcode,
          *msg_len);
  assert(0 &amp;&amp; &quot;todo&quot;);
}

int main() {
  struct timeval tv = {0};
  assert(gettimeofday(&amp;tv, NULL) != -1);
  srand(tv.tv_sec * 1000 * 1000 + tv.tv_usec);

  int fd = wayland_display_connect();

  state_t state = {
      .wl_registry = wayland_wl_display_get_registry(fd),
      .w = 117,
      .h = 150,
      .stride = 117 * color_channels,
  };

  // Single buffering.
  state.shm_pool_size = state.h * state.stride;
  create_shared_memory_file(state.shm_pool_size, &amp;state);

  while (1) {
    char read_buf[4096] = &quot;&quot;;
    int64_t read_bytes = recv(fd, read_buf, sizeof(read_buf), 0);
    if (read_bytes == -1)
      exit(errno);

    char *msg = read_buf;
    uint64_t msg_len = (uint64_t)read_bytes;

    while (msg_len &gt; 0)
      wayland_handle_message(fd, &amp;state, &amp;msg, &amp;msg_len);

    if (state.wl_compositor != 0 &amp;&amp; state.wl_shm != 0 &amp;&amp;
        state.xdg_wm_base != 0 &amp;&amp;
        state.wl_surface == 0) { // Bind phase complete, need to create surface.
      assert(state.state == STATE_NONE);

      state.wl_surface = wayland_wl_compositor_create_surface(fd, &amp;state);
      state.xdg_surface = wayland_xdg_wm_base_get_xdg_surface(fd, &amp;state);
      state.xdg_toplevel = wayland_xdg_surface_get_toplevel(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);
    }

    if (state.state == STATE_SURFACE_ACKED_CONFIGURE) {
      // Render a frame.
      assert(state.wl_surface != 0);
      assert(state.xdg_surface != 0);
      assert(state.xdg_toplevel != 0);

      if (state.wl_shm_pool == 0)
        state.wl_shm_pool = wayland_wl_shm_create_pool(fd, &amp;state);
      if (state.wl_buffer == 0)
        state.wl_buffer = wayland_wl_shm_pool_create_buffer(fd, &amp;state);

      assert(state.shm_pool_data != 0);
      assert(state.shm_pool_size != 0);

      uint32_t *pixels = (uint32_t *)state.shm_pool_data;
      for (uint32_t i = 0; i &lt; state.w * state.h; i++) {
        uint8_t r = wayland_logo[i * 3 + 0];
        uint8_t g = wayland_logo[i * 3 + 1];
        uint8_t b = wayland_logo[i * 3 + 2];
        pixels[i] = (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;
      }
      wayland_wl_surface_attach(fd, &amp;state);
      wayland_wl_surface_commit(fd, &amp;state);

      state.state = STATE_SURFACE_ATTACHED;
    }
  }
}
</code></pre>
  </summary>
</details>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
