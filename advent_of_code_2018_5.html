<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico"/>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/highlight.min.js"></script>
<script>
window.addEventListener("load", (event) => {
  hljs.highlightAll();
});
</script>
</head>
<body>

<div id="banner">
    <a id="name" href="/blog"><img id="me" src="me.jpeg"/> Philippe Gaultier </a>
    <ul>
      <li>
      <a href="/blog/body_of_work.html">Body of work</a>
      </li>
      <li>
        <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">Resume</a>
      </li>
      <li>
      <a href="https://www.linkedin.com/in/philippegaultier/">LinkedIn</a>
      </li>
      <li>
        <a href="https://github.com/gaultier">Github</a>
      </li>
      <li>
      <a href="/blog/feed.xml">Feed</a>
      </li>
    </ul>
</div>
<div class="body">

<h1
id="getting-started-with-scheme-by-solving-an-advent-of-code-2018-challenge">Getting
started with Scheme by solving an Advent of Code 2018 challenge</h1>
<p>I started learning <a
href="https://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>
very recently. <a href="http://wiki.call-cc.org/">Chicken Scheme</a> is
a wonderful small and performant implementation of Scheme, a programming
language in the family of LISPs. Since I learn by doing, let’s solve the
<a href="https://adventofcode.com/2018/day/5">Advent of Code 2018 day 5
challenge</a> with a tiny Scheme program. I encourage you to check out
<a href="https://adventofcode.com/2018/about">Advent of Code</a> and try
to solve the challenges yourself.</p>
<p>Many people have the feeling that LISPs are slow and cryptic with all
those parentheses. I hope to show that it is in fact very approachable,
easy to work with, and even fast to run!</p>
<p>I will not go through installing Chicken Scheme and learning the
basics, because it was <a
href="http://blog.klipse.tech/scheme/2016/09/11/scheme-tutorial-1.html">already
done better than I can</a>.</p>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#the-problem">The problem</a></li>
<li><a
href="#working-with-the-repl-to-iteratively-close-in-on-a-solution">Working
with the REPL to iteratively close in on a solution</a>
<ul>
<li><a href="#a-small-detour-pattern-matching">A small detour: pattern
matching</a></li>
<li><a href="#using-pattern-matching-to-solve-our-problem">Using pattern
matching to solve our problem</a></li>
</ul></li>
<li><a href="#the-final-solution">The final solution</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="the-problem">The problem</h2>
<p>We have a string looking like this: <code>AabcdZZqQ</code> which
represents a chain of chemical units. Adjacent units of the same type
(i.e letter) and opposite polarity (i.e casing) react together and
disappear. It means we want to remove adjacent characters which are the
same letter and have opposite casing, e.g <code>Aa</code> and
<code>qQ</code> disappear while <code>bc</code> and <code>ZZ</code>
remain. Once we are finished, we have: <code>bcdZZ</code>.</p>
<p>The final output is the number of characters in the final string,
i.e, <code>5</code>.</p>
<h2
id="working-with-the-repl-to-iteratively-close-in-on-a-solution">Working
with the REPL to iteratively close in on a solution</h2>
<p>First, let’s define our input, which is a string:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> input </span><span class="st">&quot;aAbxXBctTCz&quot;</span>)</span></code></pre></div>
<p>Later, we will read our input string from a file, but for now it is
simpler to just hard-code it.</p>
<p>Most functions in Scheme are immutable, meaning they do not modify
their arguments, they instead return a new item which is slightly
different.</p>
<p>We could work with strings, but it turns out it is simpler to work
with lists instead in our case. We do not want to keep track of indices,
risking doing off-by-one mistakes. Also, LISPs are good at handling
lists (LISP stands for LISt Processor), and we’ll that we can use
pattern matching to make the code very concise. I am not aware of
pattern matching capabilities on string, so let’s use lists:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">string-&gt;list</span> input)</span></code></pre></div>
<p>Here, the <code>string-&gt;list</code> function just returns a list
of characters for a string (in other languages it is usually named
<code>split</code>).</p>
<p>Now, we need to detect if two characters are the same latter, with
opposite casing. Let’s write a <code>char-opposite-casing?</code>
function to do just that. It will take 2 arguments, the letters we are
inspecting, and will return a boolean. For now, let’s just make it
always return true:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(char-opposite-casing? a b) <span class="ch">#\t</span>)</span></code></pre></div>
<p>We only deal with ASCII, so it is safe to compare ASCII codes to
detect casing.</p>
<p>What is the ASCII code of <code>A</code>? Let’s try it by using the
function <code>char-&gt;integer</code>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">char-&gt;integer</span> <span class="ch">#\A</span>) </span></code></pre></div>
<p>What about <code>a</code>?</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">char-&gt;integer</span> <span class="ch">#\a</span>)</span></code></pre></div>
<p>So there is a difference of <code>32</code> between the same ASCII
letter in lowercase and uppercase. Peeking at <code>man ascii</code> in
the terminal confirms this hunch for all letters of the alphabet.</p>
<p>So, time to implement <code>char-opposite-casing?</code>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(char-case-opposite-casing? a b)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let*</span> ((a-code (<span class="kw">char-&gt;integer</span> a))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>         (b-code (<span class="kw">char-&gt;integer</span> b))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>         (diff (<span class="op">-</span> a-code b-code)))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">=</span> (<span class="op">*</span> <span class="dv">32</span> <span class="dv">32</span>) (<span class="op">*</span> diff diff))))</span></code></pre></div>
<p>Let’s try it with <code>a</code> and <code>A</code>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(char-case-opposite-casing? <span class="ch">#\a</span> <span class="ch">#\A</span>) </span></code></pre></div>
<p>And flipped:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(char-case-opposite-casing? <span class="ch">#\A</span> <span class="ch">#\a</span>)</span></code></pre></div>
<p>And <code>A</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(char-case-opposite-casing? <span class="ch">#\A</span> <span class="ch">#\b</span>)</span></code></pre></div>
<p><code>let*</code> is used to define local bindings which are only
visible in this function. It evaluates each binding in order which means
we can define <code>diff</code> in terms of <code>a</code> and
<code>b</code> (contrary to <code>let</code>).</p>
<p>We could have done without it but it makes the function more
readable.</p>
<p>The only hurdle is not caring about the sign of the difference: if
the difference is <code>32</code> or <code>-32</code>, it is the same.
We could compare the absolute value, but I (arbitrarily) chose to
implement it without branches, by comparing the squared values (which
swallows the signs).</p>
<hr />
<p>Now let’s work on the central problem: how to remove characters in a
list, in a functional, immutable way?</p>
<p>The idea is to write a recursive function taking two arguments: an
accumulator (let’s call it <code>acc</code> from now on), which will be
eventually the end result, and the input list (<code>input</code>), from
which we gradually remove items until it is empty. We can view the first
list as the work we have done, and the second list as the work to
do.</p>
<p>Let’s first define the function. For now, it just returns the empty
list:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  &#39;())</span></code></pre></div>
<p>At first, the accumulator is the empty list, so we will always call
our function like this:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(chem-react &#39;() (<span class="kw">string-&gt;list</span> input))</span></code></pre></div>
<p>It is import to know that most list functions do not work on the
empty list in Chicken Scheme. For example, to get the first element of a
list, we use the <code>car</code> function:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> my-list </span>(<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Note that this doest **not** mutate `my-list`</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">car</span> my-list)</span></code></pre></div>
<p>But it won’t work on the empty list:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> my-list </span>&#39;())</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">car</span> my-list)</span></code></pre></div>
<p>So we need to treat the case of the empty list (both for the first
and the second argument) explicitly. We could do that by using lots of
<code>if</code>, but it is more readable and concise to use pattern
matching.</p>
<h3 id="a-small-detour-pattern-matching">A small detour: pattern
matching</h3>
<p>Scheme has a minimalist core, so we do not get pattern matching out
of the box, but we can easily add it with the package
<code>matchable</code>. Let’s install it in the terminal:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> chicken-install matchable</span></code></pre></div>
<p>Now we can import it at the top of our code:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>(import matchable)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; At this point we can refer to any function in this module `matchable`.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">;; No need to prefix them either with `matchable`.</span></span></code></pre></div>
<p>Let’s try to match the empty list in our function, and return (as an
example) a number, e.g <code>42</code>. We also want to match the case
of both lists containing one element, and returning the sum of those 2
elements:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  (match (<span class="kw">list</span> acc input)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(<span class="op">_</span> ()) <span class="dv">42</span><span class="op">]</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>((a) (b)) (<span class="op">+</span> a b)<span class="op">]</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>(chem-react &#39;() &#39;()) <span class="co">;; =&gt; 42</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>(chem-react (<span class="kw">list</span> <span class="dv">2</span>) (<span class="kw">list</span> <span class="dv">3</span>)) <span class="co">;; =&gt; 5</span></span></code></pre></div>
<p>A few interesting things here: <code>_</code> allows us to match
anything, so the first case is equivalent to checking if the second list
is empty. Additionally, we can bind variables to our patterns: we do
that in the second case, binding the first element of the first list to
<code>a</code>, and the fist element of the second list to
<code>b</code>, and summing the two.</p>
<p>Note that not all possible cases are covered here, and we will get a
(runtime) error if we trigger one of them, for example with a list
containing several numbers:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(chem-react (<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span>) (<span class="kw">list</span> <span class="dv">3</span>)) <span class="co">;; =&gt; Error: (match) &quot;no matching pattern&quot;: ()</span></span></code></pre></div>
<p>Let’s go ahead and match the case of a list of one or more elements
(<code>(a . arest)</code>) to avoid that:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  (match (<span class="kw">list</span> acc input)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(<span class="op">_</span> ()) <span class="dv">42</span><span class="op">]</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>((a) (b)) (<span class="op">+</span> a b)<span class="op">]</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>((a <span class="op">.</span> arest) (b <span class="op">.</span> brest)) (<span class="op">*</span> a b)<span class="op">]</span>))</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>(chem-react (<span class="kw">list</span> <span class="dv">2</span> <span class="dv">3</span>) (<span class="kw">list</span> <span class="dv">4</span>)) <span class="co">;; =&gt; 8</span></span></code></pre></div>
<p>Here we choose to (arbitrarily) return the product of the first
elements of both list, to show that pattern matching is also a way to do
destructuring.</p>
<h3 id="using-pattern-matching-to-solve-our-problem">Using pattern
matching to solve our problem</h3>
<p>If the second list (the input) is empty, it means we are finished, so
we return the first list (<code>acc</code>):</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (match (<span class="kw">list</span> acc input)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(<span class="op">_</span> ()) acc<span class="op">]</span>))</span></code></pre></div>
<p>Our recursion will work as follows: we look at the first element of
the second list (<code>input</code>, which is the work to do), let’s
call it <code>b</code>, and the first element of the first list
(<code>acc</code>, the work done), let’s call it <code>a</code>.</p>
<p>If <code>a</code> and <code>b</code> are the same letter of opposite
casing, we ‘drop’ the two. Otherwise, we add <code>b</code> to the first
list, and ‘continue’. ‘drop’ and ‘continue’ are put in quotes because
that is vocabulary from imperative languages such as C; we’ll see in a
minute how we implement it in a functional way.</p>
<p>If the first list is empty, this is our starting case: the only thing
we can do is mark <code>b</code> as ‘processed’, i.e add it to the first
list, and call ourselves with the remainder of <code>input</code>.
Indeed, we can only work with two characters, so if we only have one, we
cannot do much.</p>
<p>It’s time to learn about a new function: <code>cons</code>.
<code>cons</code> just adds an item to a list, and returns the new list
with the added item:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> my-list </span>(<span class="kw">list</span> <span class="dv">2</span> <span class="dv">3</span>))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">;; Note: `my-list` is **not** modified</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">cons</span> <span class="dv">1</span> my-list) </span></code></pre></div>
<p>We can now use <code>cons</code> to implement the new case:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  (match (<span class="kw">list</span> acc input)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(<span class="op">_</span> ()) acc<span class="op">]</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(() (b <span class="op">.</span> brest)) (chem-react (<span class="kw">cons</span> b acc) brest)<span class="op">]</span>))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>(chem-react &#39;() &#39;(<span class="ch">#\A</span>)) <span class="co">;; =&gt; (#\A)</span></span></code></pre></div>
<p>This new pattern is required for the recursion to work, but it also
covers the trivial case of an input string of only one character.</p>
<p>Now, let’s treat the main case: we have at least an element
<code>a</code> in <code>acc</code> and at least an element
<code>b</code> in <code>input</code>. If they are the same letters of
opposite casing, we call ourselves with the remainder of
<code>acc</code> and the remainder of <code>input</code>, which is
equivalent to ‘drop’ <code>a</code> and <code>b</code>. Otherwise, we
add <code>b</code> to <code>acc</code>, and we call ourselves with the
remainder of <code>input</code>, which is the equivalent of
‘continuing’:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc input)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  (match (<span class="kw">list</span> acc input)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(<span class="op">_</span> ()) acc<span class="op">]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(() (b <span class="op">.</span> brest)) (chem-react (<span class="kw">cons</span> b acc) brest)<span class="op">]</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>((a <span class="op">.</span> arest) (b <span class="op">.</span> brest)) (<span class="kw">if</span> (char-case-opposite-casing? a b)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                                   (chem-react arest brest)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                                   (chem-react (<span class="kw">cons</span> b acc) brest))<span class="op">]</span>))</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>(chem-react &#39;() (<span class="kw">list</span> <span class="ch">#\A</span> <span class="ch">#\a</span> <span class="ch">#\b</span>)) <span class="co">;; =&gt; (#\b)</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>(chem-react &#39;() (<span class="kw">string-&gt;list</span> <span class="st">&quot;aAbxXBctTCz&quot;</span>)) <span class="co">;; =&gt; (#\z)</span></span></code></pre></div>
<p>But wait a minute…Doesn’t it look familiar? Yes, what we are doing
here is a fold (sometimes called reduce)!</p>
<p>Let’s replace our custom recursion by <code>fold</code>.
<code>chem-react</code> becomes the reduction function. It becomes
simpler because <code>fold</code> will not call it on the empty list, so
we only need to patter match <code>acc</code> (which is the empty list
at the beginning):</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc x)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  (match acc</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>() (<span class="kw">cons</span> x acc)<span class="op">]</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(a <span class="op">.</span> arest) (<span class="kw">if</span> (char-case-opposite-casing? a x)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                     arest</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">cons</span> x acc))<span class="op">]</span>))</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>(foldl chem-react &#39;() input) <span class="co">;; =&gt; (#\z)</span></span></code></pre></div>
<p>My experience writing code in a LISP is that I usually find a
solution that is relatively big, and I start replacing parts of it with
standard functions such as <code>fold</code> and it ends up very
small.</p>
<blockquote>
<p>How do I read the input from a file?</p>
</blockquote>
<p>It’s quite simple: we use the modules <code>chicken.file.posix</code>
and <code>chicken.io</code>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(import chicken.file.posix</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        chicken.io)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>(read-line (<span class="kw">open-input-file</span> <span class="st">&quot;/Users/pgaultier/Downloads/aoc5.txt&quot;</span>)) <span class="co">;; =&gt; &quot;a big string...&quot;</span></span></code></pre></div>
<h2 id="the-final-solution">The final solution</h2>
<p>Here I use the package <code>clojurian</code>
(<code>chicken-install clojurian</code>) to have access to the
<code>-&gt;&gt;</code> macro which makes code more readable. It works
like the pipe in the shell. Instead of writing:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(foo (bar <span class="st">&quot;foo&quot;</span> (baz <span class="dv">1</span> <span class="dv">2</span>)))</span></code></pre></div>
<p>We write:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(-&gt;&gt; (baz <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>     (bar <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>     (foo))</span></code></pre></div>
<p>The macro reorders the functions calls to make it flat and avoid
nesting. It is not strictly required, but I like that my code looks like
a pipeline of data transformations.</p>
<p>The final code:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode scheme"><code class="sourceCode scheme"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>(import matchable</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>        clojurian.syntax</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        chicken.file.posix</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        chicken.io)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(char-case-opposite-casing? a b)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let*</span> ((a-code (<span class="kw">char-&gt;integer</span> a))</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>         (b-code (<span class="kw">char-&gt;integer</span> b))</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>         (diff (<span class="op">-</span> a-code b-code)))</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    (<span class="op">=</span> (<span class="op">*</span> <span class="dv">32</span> <span class="dv">32</span>) (<span class="op">*</span> diff diff))))</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>(<span class="ex">define</span><span class="fu"> </span>(chem-react acc x)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>  (match acc</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>() (<span class="kw">cons</span> x acc)<span class="op">]</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>(a <span class="op">.</span> arest) (<span class="kw">if</span> (char-case-opposite-casing? a x)</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>                     arest</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>                     (<span class="kw">cons</span> x acc))<span class="op">]</span>))</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>(-&gt;&gt; (<span class="kw">open-input-file</span> <span class="st">&quot;/Users/pgaultier/Downloads/aoc5.txt&quot;</span>)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>     (read-line)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">string-&gt;list</span>)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>     (foldl chem-react &#39;())</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">length</span>)</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>     (print))</span></code></pre></div>
<blockquote>
<p>But we will get a stack overflow on a big input!</p>
</blockquote>
<p>Scheme has a nice requirement for all implementations: they must
implement tail-call optimization, which is to say that the compiler can
transform our function into an equivalent for-loop. So we won’t get a
stack overflow, and it will be quite efficient in terms of memory and
time.</p>
<blockquote>
<p>But we are making thousands of copies, it will be slow as hell!</p>
</blockquote>
<p>Let’s benchmark it on the real input (50 000 characters), with
<code>-O3</code> to enable optimizations:</p>
<p><em>Note 1: The real output of the program is not shown to avoid
spoiling the final result</em></p>
<p><em>Note 2: This is a simplistic way to do benchmarking. A more
correct way would be: warming up the file cache, making many runs,
averaging the results, etc. I did exactly that and it did not change the
results in a significant manner.</em></p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> csc aoc5.scm <span class="at">-o</span> aoc5 <span class="at">-O3</span> <span class="kw">&amp;&amp;</span> <span class="bu">time</span> ./aoc5</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./aoc5</span>  0.01s user 0.00s system 82% cpu 0.021 total</span></code></pre></div>
<p>It takes 21 milliseconds. Not too bad for a garbage collected,
functional, immutable program.</p>
<p>Here is a hand-written C version which only does one allocation and
removes letters in place:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;/home/pg/Downloads/aoc2020_5.txt&quot;</span><span class="op">,</span> O_RDONLY<span class="op">);</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>fd <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> errno<span class="op">;</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> stat st <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>stat<span class="op">(</span><span class="st">&quot;/home/pg/Downloads/aoc2020_5.txt&quot;</span><span class="op">,</span> <span class="op">&amp;</span>st<span class="op">)</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> errno<span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> input_len <span class="op">=</span> st<span class="op">.</span>st_size<span class="op">;</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> <span class="op">*</span><span class="dt">const</span> input <span class="op">=</span> calloc<span class="op">(</span>input_len<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>read<span class="op">(</span>fd<span class="op">,</span> input<span class="op">,</span> input_len<span class="op">)</span> <span class="op">!=</span> input_len<span class="op">)</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> errno<span class="op">;</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>input<span class="op">[</span>input_len <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;\n&#39;</span> <span class="op">||</span> input<span class="op">[</span>input_len <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39; &#39;</span><span class="op">)</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    input_len<span class="op">--;</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int64_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> input_len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>abs<span class="op">(</span>input<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> input<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">==</span> <span class="dv">32</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>      memmove<span class="op">(</span>input <span class="op">+</span> i<span class="op">,</span> input <span class="op">+</span> i <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> input_len <span class="op">-</span> i <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>      input_len <span class="op">-=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>      i <span class="op">=</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> i <span class="op">-</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>      i<span class="op">++;</span></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;`%zu`</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> input_len<span class="op">);</span></span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Let’s benchmark it on the same input:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cc <span class="at">-std</span><span class="op">=</span>c99 <span class="at">-O3</span> <span class="at">-Weverything</span> aoc5.c <span class="at">-march</span><span class="op">=</span>native <span class="kw">&amp;&amp;</span> <span class="bu">time</span> ./a.out</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./a.out</span>  0.01s user 0.00s system 86% cpu 0.012 total</span></code></pre></div>
<p>It took 12 milliseconds. So the scheme version is very close, and
takes an acceptable amount of time.</p>
<blockquote>
<p>Can’t we use strings and not lists?</p>
</blockquote>
<p>Yes, of course. However we need to be careful about how strings are
implemented and what we we do with those. Most runtimes (e.g the JVM)
use immutable strings, meaning we could end up allocating thousands of
big strings, and being quite slow.</p>
<h2 id="conclusion">Conclusion</h2>
<p>That’s it, we solved the fifth Advent of Code challenge in Scheme.
The solution is under 30 lines of code, is (hopefully) simple and
readable, and has a performance close to C, while having memory safety
(I had several segfaults while doing the C version).</p>
<p>But more than that, I think the real value in LISPs is interactive
programming, instead of the classical write-compile-execute-repeat,
which is much more time consuming. It is really important to get
feedback as early as possible, and LISPs give us that.</p>
<p>I hope it gave you a glance at what Scheme can do, and stay tuned for
more blog posts about programming. I intend to post more solutions to
other coding challenges, solved with a variety of programming
languages.</p>
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/languages/scheme.min.js"></script>

<blockquote>
  <p>If you liked this article and you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Donate</a></p>
</blockquote>

</div>
</body>
</html>
