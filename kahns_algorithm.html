<!DOCTYPE html>
<html>
<head>
<title>Cycle detection in graphs does not have to be hard: A lesser known, simple way with Kahn's algorithm</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self"/>
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js"></script>
<script>
  window.onload = function() {
      hljs.registerLanguage("odin", function(e) {
      return {
          aliases: ["odin", "odinlang", "odin-lang"],
          keywords: {
              keyword: "auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",
              literal: "true false nil",
              built_in: "abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"
          },
          illegal: "</",
          contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e.QUOTE_STRING_MODE, {
                  begin: "'",
                  end: "[^\\\\]'"
              }, {
                  begin: "`",
                  end: "`"
              }]
          }, {
              className: "number",
              variants: [{
                  begin: e.C_NUMBER_RE + "[ijk]",
                  relevance: 1
              }, e.C_NUMBER_MODE]
          }]
      }
    });

    hljs.highlightAll();

    document.querySelectorAll('code').forEach((el, _i) => {
        if (0 == el.classList.length || el.classList.contains('language-sh') || el.classList.contains('language-shell') || el.classList.contains('language-bash')){
          el.classList.add('code-no-line-numbers');
          return; 
        }

        var lines = el.innerHTML.trimEnd().split('\n');
        var out = [];
        lines.forEach(function(l, i){
          out.push('<span class="line-number">' + (i+1).toString() + '</span> ' + l);
        });
        el.innerHTML = out.join('\n');
    });
  }
</script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <ul>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="#000000"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" class="mercado-match" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"></path>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z" fill="url(#paint0_linear_549_34)"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="white"/>
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="none" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path fill="#0085ff" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"></path></svg>
        </a> </li>
    </ul>
</div>
<div class="body">

		<div class="article-prelude">
			<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

			<p class="publication-date">Published on 2023-06-03</p>
		</div>
		<div class="article-title">
		<h1>Cycle detection in graphs does not have to be hard: A lesser known, simple way with Kahn's algorithm</h1>
		  <div class="tags"> <a href="/blog/articles-by-tag.html#graph" class="tag">Graph</a> <a href="/blog/articles-by-tag.html#algorithm" class="tag">Algorithm</a> <a href="/blog/articles-by-tag.html#javascript" class="tag">JavaScript</a> <a href="/blog/articles-by-tag.html#sql" class="tag">SQL</a></div>
 </div>
 <strong>Table of contents</strong>
<ul>

	<li>
		<a href="#4275806978-introduction">Introduction</a>
		  </li>

	<li>
		<a href="#3658996082-the-database">The database</a>
		  </li>

	<li>
		<a href="#3448959225-topological-sort">Topological sort</a>
		  </li>

	<li>
		<a href="#1273712339-how-to-store-the-graph-in-memory">How to store the graph in memory</a>
		  </li>

	<li>
		<a href="#1475551869-kahn-s-algorithm">Kahn's algorithm</a>
		  </li>

	<li>
		<a href="#3410597752-implementation">Implementation</a>
		<ul>

	<li>
		<a href="#3667958886-helpers">Helpers</a>
		  </li>

	<li>
		<a href="#1391191453-the-algorithm">The algorithm</a>
		  </li>

	<li>
		<a href="#266987965-inserting-entries-in-the-database">Inserting entries in the database</a>
		  </li>

	<li>
		<a href="#1211708065-detecting-cycles">Detecting cycles</a>
		  </li>

	<li>
		<a href="#2939355639-detecting-multiple-roots">Detecting multiple roots</a>
		  </li>
</ul>
  </li>

	<li>
		<a href="#782257250-playing-with-the-database">Playing with the database</a>
		  </li>

	<li>
		<a href="#3440295979-closing-thoughts">Closing thoughts</a>
		  </li>

	<li>
		<a href="#1512890027-addendum-the-full-code">Addendum: the full code</a>
		  </li>
</ul>

<h2>Introduction</h2>
<p>Graphs are everywhere in Software Engineering, or so we are told by Computer Science teachers and interviewers. But sometimes, they do show up in real problems.</p>
<p>Not too long ago, I was tasked to create a Web API to create and update a company's hierarchy of employee, and display that on a web page. Basically, who reports to whom.</p>
<p>In the simple case, it's a tree, when an employee reports to exactly one manager.</p>
<p><img src="kahns_algorithm_1.svg" alt="Employee hierarchy" /></p>
<p>Here's the tree of employees in an organization. An employee reports to a manager, and this forms a tree. The root is the CEO since they report to no one and so they have no outgoing edge.</p>
<p>An arrow (or 'edge') between two nodes means <code>&lt;source&gt; reports to &lt;destination&gt;</code>, for example: <code>Jane the CFO reports to Ellen the CEO</code>.</p>
<p>But here is the twist: our API receives a list of <code>employee -&gt; manager</code> links, in any order:</p>
<pre><code>Jane -&gt; Ellen
Angela -&gt; Ellen
Zoe -&gt; Jane
Zoe -&gt; Angela
Bella -&gt; Angela
Miranda -&gt; Angela
</code></pre>
<p>It opens the door to various invalid inputs: links that form a graph (an employee has multiple managers), multiple roots (e.g. multiple CEOs) or cycles.</p>
<p>We have to detect those and reject them, such as this one:</p>
<p><img src="kahns_algorithm_1_invalid.svg" alt="Invalid employee hierarchy" /></p>
<h2>The database</h2>
<p>So how do we store all of those people in the database?</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS people(name TEXT NOT NULL UNIQUE, manager BIGINT REFERENCES people)
</code></pre>
<p>Each employee has a optional reference to a manager.</p>
<blockquote>
<p>This is not a novel idea, actually this is one of the examples in the official <a href="https://www.sqlite.org/lang_with.html">SQLite documentation</a>.</p>
</blockquote>
<p>For example, to save <code>Ellen, CEO</code> inside the database, we do:</p>
<pre><code class="language-sql">INSERT INTO people VALUES('Ellen, CEO', NULL)
</code></pre>
<p>And to save <code>Jane, CFO</code> in the database:</p>
<pre><code class="language-sql">INSERT INTO people VALUES('Jane, CFO', 1)
</code></pre>
<p>Where <code>Ellen, CEO</code>, Jane's boss, which we just inserted before, has the id <code>1</code>.</p>
<p>Immediately, we notice that to insert an employee, their manager needs to already by in the database, by virtue of the self-referential foreign key <code>manager BIGINT REFERENCES people</code>.</p>
<p>So we need a way to sort the big list of <code>employee -&gt; manager</code> links (or 'edges' in graph parlance), to insert them in the right order. First we insert the CEO, who reports to no one. Then we insert the employees directly reporting to the CEO. Then the employees reporting to those. Etc.</p>
<p>And that's called a topological sort.</p>
<p>A big benefit is that we hit three birds with one stone:</p>
<ul>
<li>We detect cycles</li>
<li>We have the nodes in an convenient order to insert them in the database</li>
<li>Since the algorithm for the topological sort takes as input an adjacency matrix (more on this later), we can easily detect the invalid case of a node having more than one outgoing edge (i.e. more than one manager, i.e. multiple roots).</li>
</ul>
<p>From now one, I will use the graph of employees (where <code>Zoe</code> has two managers) as example since that's a possible input to our API and we need to detect this case.</p>
<h2>Topological sort</h2>
<p>From Wikipedia:</p>
<blockquote>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks</p>
</blockquote>
<p>That's a mouthful but it's not too hard.</p>
<p>A useful command line utility that's already on your (Unix) machine is <code>tsort</code>, which takes a list of edges as input, and outputs a topological sort. Here is the input in a text file (<code>people.txt</code>):</p>
<pre><code>Jane Ellen
Angela Ellen
Zoe Jane
Zoe Angela
Bella Angela
Miranda Angela
</code></pre>
<blockquote>
<p><code>tsort</code> uses a simple way of defining each edge <code>A -&gt; B</code> on its own line with the syntax: <code>A B</code>. The order of the lines does not matter.</p>
</blockquote>
<p>And here's the <code>tsort</code> output:</p>
<pre><code class="language-sh">$ tsort &lt; people.txt
Bella
Miranda
Zoe
Angela
Jane
Ellen
</code></pre>
<p>The first 3 elements are the ones with no incoming edge, the Software Engineers, since no one reports to them. Then come their respective managers, Angela and Jane. Finally comes their manager, <code>Ellen</code>.</p>
<p>So to insert all those people in our <code>people</code> SQL table, we go through that list in reverse order: We can first insert <code>Ellen</code>, then <code>Jane</code>, etc, until we finally insert <code>Bella</code>.</p>
<p>Also, <code>tsort</code> detects cycles, for example if we add the line: <code>Ellen Zoe</code> at the end of <code>people.txt</code>, we get:</p>
<pre><code class="language-sh">$ tsort &lt; people.txt
Bella
Miranda
tsort: -: input contains a loop:
tsort: Jane
tsort: Ellen
tsort: Zoe
Jane
tsort: -: input contains a loop:
tsort: Angela
tsort: Ellen
tsort: Zoe
Angela
Ellen
Zoe
</code></pre>
<p>So, how can we implement something like <code>tsort</code> for our problem at hand? That's where <a href="https://en.wikipedia.org/wiki/Topological_sorting#Kahn&#x27;s_algorithm">Kahn's algorithm</a> comes in to do exactly that: find cycles in the graph and output a topological sort.</p>
<p><em>Note that that's not the only solution and there are ways to detect cycles without creating a topological sort, but this algorithm seems relatively unknown and does not come up often on the Internet, so let's discover how it works and implement it. I promise, it's not complex.</em></p>
<h2>How to store the graph in memory</h2>
<p>There are many ways to do so, and Kahn's algorithm does not dictate which one to use.</p>
<p>We'll use an <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>, because it's simple conceptually, maps well to Kahn's algorithm, and can be optimized if needed.</p>
<p>It's just a 2D square table of size <code>n x n</code> (where <code>n</code> is the number of nodes), where the cell at row <code>i</code> and column <code>j</code> is 1 if there is an edge from the node <code>i</code> to the node <code>j</code>, and otherwise, <code>0</code>.</p>
<p>The order of the nodes is arbitrary, I'll use the alphabetical order because again, it's simple to do:</p>
<pre><code>Angela
Bella
Ellen
Jane
Miranda
Zoe
</code></pre>
<p>Here, <code>Angela</code> is the node <code>0</code> and <code>Zoe</code> is the node <code>5</code>.</p>
<p>Since there is an edge from <code>Zoe</code> to <code>Angela</code>, i.e. from the node <code>5</code> to the node <code>0</code>, the cell at the position <code>(5, 0)</code> is set to <code>1</code>.</p>
<p>The full adjacency matrix for the employee graph in the example above looks like:</p>
<table>
 <tbody>
 <tr> <th></th> <th>Angela</th> <th>Bella</th> <th>Ellen</th> <th>Jane</th> <th>Miranda</th> <th>Zoe</th> </tr>
 <tr> <td>Angela</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> </tr>
 <tr> <td>Bella</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> </tr>
 <tr> <td>Ellen</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> </tr>
 <tr> <td>Jane</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> </tr>
 <tr> <td>Miranda</td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> <td>0</td> </tr>
 <tr> <td>Zoe</td> <td>1</td> <td>0</td> <td>0</td> <td>1</td> <td>0</td> <td>0</td> </tr>
 </tbody>
</table>
<p>The way to read this table is:</p>
<ul>
<li>For a given row, all the <code>1</code>'s indicate outgoing edges</li>
<li>For a given column, all the <code>1</code>'s indicate incoming edges</li>
<li>If there is a <code>1</code> on the diagonal, it means there is an edge going out of a node and going to the same node.</li>
</ul>
<p>There are a lot of zeroes in this table. Some may think this is horribly inefficient, which it is, but it really depends on number of nodes, i.e. the number of employees in the organization.
But note that this adjacency matrix is a concept, it shows what information is present, but not how it is stored.</p>
<p>For this article, we will store it the naive way, in a 2D array. Here are two optimization ideas I considered but have not had time to experiment with:</p>
<ul>
<li>Make this a bitarray. We are already only storing zeroes and ones, so it maps perfectly to this format.</li>
<li>Since there are a ton of zeroes (in the valid case, a regular employee's row only has one <code>1</code> and the CEO's row is only zeroes), it is very compressible. An easy way would be to use run-length encoding, meaning, instead of <code>0 0 0 0</code>, we just store the number of times the number occurs: <code>4 0</code>. Easy to implement, easy to understand. A row compresses to just a few bytes. And this size would be constant, whatever the size of the organization (i.e. number of employees) is.</li>
</ul>
<p>Wikipedia lists others if you are interested, it's a well-known problem.</p>
<p>Alright, now that we know how our graph is represented, on to the algorithm.</p>
<h2>Kahn's algorithm</h2>
<p><a href="https://en.wikipedia.org/wiki/Topological_sorting#Kahn&#x27;s_algorithm">Kahn's algorithm</a> keeps track of nodes with no incoming edge, and mutates the graph (in our case the adjacency matrix), by removing one edge at a time, until there are no more edges, and builds a list of nodes in the right order, which is the output.</p>
<p>Here's the pseudo-code:</p>
<pre><code>L ‚Üê Empty list that will contain the sorted elements
S ‚Üê Set of all nodes with no incoming edge

while S is not empty do
    remove a node n from S
    add n to L
    for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S

if graph has edges then
    return error   (graph has at least one cycle)
else 
    return L   (a topologically sorted order)
</code></pre>
<p>And in plain English:</p>
<ul>
<li>Line 1: The result of this algorithm is the list of nodes in the desired order (topological). It starts empty, and we add nodes one-by one during the algorithm. We can simply use an array in our implementation.</li>
<li>Line 2: We first collect all nodes with no incoming edge. In terms of adjacency matrix, it means picking columns with only zeroes. The algorithm calls it a set, but we are free in our implementation to use whatever data structure we see fit. It just means a given node appears at most once in it. In our example, this set is: <code>[Zoe, Bella, Miranda]</code>. During the algorithm course, we will add further nodes to this set. Note that this is a working set, not the final result. Also, the order does not matter.</li>
<li>Line 4: Self-explanatory, we continue until the working set is empty and there is no more work to do.</li>
<li>Line 5: We first pick a node with no incoming edge (it does not matter which one). For example, <code>Zoe</code>, and remove it from <code>S</code>. <code>S</code> is now: <code>[Bella, Miranda]</code>.</li>
<li>Line 6: We add this node to the list of topologically sorted nodes, <code>L</code>. It now is: <code>[Zoe]</code>.</li>
<li>Line 7: We then inspect each node that <code>Zoe</code> has an edge to. That means <code>Jane</code> and <code>Angela</code>. In terms of adjacency matrix, we simply read <code>Zoe's</code> row, and inspect cells with a <code>1</code> in it.</li>
<li>Line 8: We remove such an edge, for example, <code>Zoe -&gt; Jane</code>. In terms of adjacency matrix, it means setting the cell on the row <code>Zoe</code> and column <code>Jane</code> to <code>0</code>. At this point, the graph looks like this: <img src="kahns_algorithm_2.svg" alt="Employee hierarchy, step 1" /></li>
<li>Line 9: If <code>Jane</code> does not have another incoming edge, we add it to the set of all nodes with no incoming edge. That's the case here, so <code>S</code> now looks like: <code>[Bella, Miranda, Jane]</code>. We now loop to line 7 and handle the node <code>Angela</code> since <code>Jane</code> is taken care of.</li>
<li>Line 7-10: We are now handling the node <code>Angela</code>. We remove the edge <code>Zoe -&gt; Angela</code>. We check whether the node <code>Angela</code> has incoming edges. It does, so we do <strong>not</strong> add it to <code>S</code>. The graph is now: <img src="kahns_algorithm_2_1.svg" alt="Employee hierarchy, step 2" />.</li>
<li>We are now done with the line 7 for loop, so go back to line 5 and pick this time <code>Bella</code>. And so on. The graph would now, to the algorithm, look like: <img src="kahns_algorithm_2_2.svg" alt="Employee hierarchy, step 3" /></li>
</ul>
<hr />
<p>And here are the next steps in images:</p>
<ol>
<li><img src="kahns_algorithm_2_3.svg" alt="Employee hierarchy, step 4" /></li>
<li><img src="kahns_algorithm_2_4.svg" alt="Employee hierarchy, step 5" /></li>
<li><img src="kahns_algorithm_2_5.svg" alt="Employee hierarchy, step 6" /></li>
<li><img src="kahns_algorithm_2_6.svg" alt="Employee hierarchy, step 7" /></li>
<li><img src="kahns_algorithm_2_7.svg" alt="Employee hierarchy, step 8" /></li>
<li><img src="kahns_algorithm_2_8.svg" alt="Employee hierarchy, step 9" /></li>
<li><img src="kahns_algorithm_2_9.svg" alt="Employee hierarchy, step 10" /></li>
</ol>
<hr />
<ul>
<li>Line 12-15: Once the loop at line 4 is finished, we inspect our graph. If there are no more edges, we are done. If there is still an edge, it means there was a cycle in the graph, and we return an error.
Note that this algorithm is not capable by itself to point out which cycle there was exactly, only that there was one. That's because we mutated the graph by removing edges. If this information was important, we could keep track of which edges we removed in order, and re-add them back, or perhaps apply the algorithm to a copy of the graph (the adjacency matrix is trivial to clone).</li>
</ul>
<p>This algorithm is loose concerning the order of some operations, for example, picking a node with no incoming edge, or in which order the nodes in <code>S</code> are stored. That gives room for an implementation to use certain data structures or orders that are faster, but in some cases we want the order to be always the same to solve ties in the stable way and to be reproducible. In order to do that, we simply use the alphabetical order. So in our example above, at line 5, we picked <code>Zoe</code> out of <code>[Zoe, Bella, Miranda]</code>. Using this method, we would keep the working set <code>S</code> sorted alphabetically and pick <code>Bella</code> out of <code>[Bella, Miranda, Zoe]</code>.</p>
<h2>Implementation</h2>
<p>I implemented this at the time in Go, but I will use for this article the lingua franca of the 2010s, Javascript.</p>
<p><em>I don't write Javascript these days, I stopped many years ago, so apologies in advance if I am not using all the bells and whistles of 'Modern Javascript', or if the code is not quite idiomatic.</em></p>
<p>First, we define our adjacency matrix and the list of nodes. This is the naive format. We would get the nodes and edges in some format, for example JSON, in the API, and build the adjacency matrix, which is trivial. Let's take the very first example, the (valid) tree  of employees:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];
</code></pre>
<h3>Helpers</h3>
<p>We need a helper function to check if a node has no incoming edge (line 9 in the algorithm):</p>
<pre><code class="language-js">function hasNodeNoIncomingEdge(adjacencyMatrix, nodeIndex) {
  const column = nodeIndex;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    const cell = adjacencyMatrix[row][column];
    if (cell != 0) {
      return false;
    }
  }

  return true;
}
</code></pre>
<p>Then, using this helper, we can define a second helper to initially collect all the nodes with no incoming edge (line 2 in the algorithm):</p>
<pre><code class="language-js">function getNodesWithNoIncomingEdge(adjacencyMatrix, nodes) {
  return nodes.filter((_, i) =&gt; hasNodeNoIncomingEdge(adjacencyMatrix, i));
}
</code></pre>
<p>We can try it:</p>
<pre><code class="language-js">console.log(getNodesWithNoIncomingEdge(adjacencyMatrix, nodes));
</code></pre>
<p>And it outputs:</p>
<pre><code class="language-js">[ 'Bella', 'Miranda', 'Zoe' ]
</code></pre>
<p>We need one final helper, to determine if the graph has edges (line 12), which is straightforward:</p>
<pre><code class="language-js">function graphHasEdges(adjacencyMatrix) {
  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] == 1) return true;
    }
  }

  return false;
}
</code></pre>
<h3>The algorithm</h3>
<p>We are finally ready to implement the algorithm. It's a straightforward, line by line, translation of the pseudo-code:</p>
<pre><code class="language-js">function topologicalSort(adjacencyMatrix) {
  const L = [];
  const S = getNodesWithNoIncomingEdge(adjacencyMatrix, nodes);

  while (S.length &gt; 0) {
    const node = S.pop();
    L.push(node);
    const nodeIndex = nodes.indexOf(node);

    for (let mIndex = 0; mIndex &lt; nodes.length; mIndex += 1) {
      const hasEdgeFromNtoM = adjacencyMatrix[nodeIndex][mIndex];
      if (!hasEdgeFromNtoM) continue;

      adjacencyMatrix[nodeIndex][mIndex] = 0;

      if (hasNodeNoIncomingEdge(adjacencyMatrix, mIndex)) {
        const m = nodes[mIndex];
        S.push(m);
      }
    }
  }

  if (graphHasEdges(adjacencyMatrix)) {
    throw new Error(&quot;Graph has at least one cycle&quot;);
  }

  return L;
}
</code></pre>
<p>Let's try it:</p>
<pre><code class="language-js">console.log(topologicalSort(adjacencyMatrix, nodes));
</code></pre>
<p>We get:</p>
<pre><code class="language-js">[ 'Zoe', 'Jane', 'Miranda', 'Bella', 'Angela', 'Ellen' ]
</code></pre>
<p>Interestingly, it is not the same order as <code>tsort</code>, but it is indeed a valid topological ordering. That's because there are ties between some nodes and we do not resolve those ties the exact same way <code>tsort</code> does.</p>
<p>But in our specific case, we just want a valid insertion order in the database, and so this is enough.</p>
<h3>Inserting entries in the database</h3>
<p>Now, we can produce the SQL code to insert our entries. We operate on a clone of the adjacency matrix for convenience because we later need to know what is the outgoing edge for a given node.</p>
<p>We handle the special case of the root first, which is the last element, and then we go through the topologically sorted list of employees in reverse order, and insert each one. We use a one liner to get the manager id by name when inserting to avoid many round trips to the database:</p>
<pre><code class="language-js">const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes)

const root = employeesTopologicallySorted[employeesTopologicallySorted.length - 1];
console.log(`INSERT INTO people VALUES(&quot;${root}&quot;, NULL)`);

for (let i = employeesTopologicallySorted.length - 2; i &gt;= 0; i -= 1) {
  const employee = employeesTopologicallySorted[i];
  const employeeIndex = nodes.indexOf(employee);

  const managerIndex = adjacencyMatrix[employeeIndex].indexOf(1);
  const manager = nodes[managerIndex];
  console.log(
    `INSERT INTO people SELECT &quot;${employee}&quot;, rowid FROM people WHERE name = &quot;${manager}&quot; LIMIT 1;`,
  );
}
</code></pre>
<p>Which outputs:</p>
<pre><code class="language-sql">INSERT INTO people VALUES(&quot;Ellen&quot;, NULL);
INSERT INTO people SELECT &quot;Angela&quot;, rowid FROM people WHERE name = &quot;Ellen&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Bella&quot;, rowid FROM people WHERE name = &quot;Angela&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Miranda&quot;, rowid FROM people WHERE name = &quot;Angela&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Jane&quot;, rowid FROM people WHERE name = &quot;Ellen&quot; LIMIT 1;
INSERT INTO people SELECT &quot;Zoe&quot;, rowid FROM people WHERE name = &quot;Jane&quot; LIMIT 1;
</code></pre>
<h3>Detecting cycles</h3>
<p>As we said earlier, we get that for free, so let's check our implementation against this invalid example:</p>
<p><img src="kahns_algorithm_4.svg" alt="Employee hierarchy with cycle" /></p>
<p>We add the edge <code>Ellen -&gt; Zoe</code> to create a cycle:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 1], // =&gt; We change the last element of this row (Ellen's row, Zoe's column) from 0 to 1.
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];

const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes);
</code></pre>
<p>And we get an error as expected:</p>
<pre><code class="language-sh">/home/pg/my-code/blog/kahns_algorithm.js:63
    throw new Error(&quot;Graph has at least one cycle&quot;);
    ^

Error: Graph has at least one cycle
</code></pre>
<h3>Detecting multiple roots</h3>
<p>One thing that topological sorting does not do for us is to detect the case of multiple roots in the graph, for example:</p>
<p><img src="kahns_algorithm_3.svg" alt="Employee hierarchy with multiple roots" /></p>
<p>To do this, we simply scan the adjacency matrix and verify that there is only one row with only zeroes, that is, only one node that has no outgoing edges:</p>
<pre><code class="language-js">function hasMultipleRoots(adjacencyMatrix) {
  let countOfRowsWithOnlyZeroes = 0;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    let rowHasOnlyZeroes = true;
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] != 0) {
        rowHasOnlyZeroes = false;
        break;
      }
    }
    if (rowHasOnlyZeroes) countOfRowsWithOnlyZeroes += 1;
  }

  return countOfRowsWithOnlyZeroes &gt; 1;
}
</code></pre>
<p>Let's try it with our invalid example from above:</p>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0, 0],
  [1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0, 0],
  [1, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;, &quot;Kelly&quot;];


console.log(hasMultipleRoots(adjacencyMatrix));
</code></pre>
<p>And we get: <code>true</code>. With our previous (valid) example, we get: <code>false</code>.</p>
<h2>Playing with the database</h2>
<p>We can query each employee along with their manager name so:</p>
<pre><code class="language-sql">SELECT a.name as employee_name, COALESCE(b.name, '') as manager_name FROM people a LEFT JOIN people b ON a.manager = b.rowid;
</code></pre>
<p>To query the manager (N+1) and the manager's manager (N+2) of an employee:</p>
<pre><code class="language-sql">SELECT COALESCE(n_plus_1.name, ''), COALESCE(n_plus_2.name, '')
FROM people employee
LEFT JOIN people n_plus_1 ON employee.manager = n_plus_1.rowid
LEFT JOIN people n_plus_2 ON n_plus_1.manager = n_plus_2.rowid
WHERE employee.name = ?
</code></pre>
<p>We can also do this with hairy recursive Common Table Expression (CTE) but I'll leave that to the reader.</p>
<h2>Closing thoughts</h2>
<p>Graphs and algorithms operating on them do not have to be complicated. Using an adjacency matrix and Kahn's algorithm, we can achieve a lot with little and it remains simple.</p>
<p>There are many ways to optimize the code in this article; the point was not to write the most efficient code, but to showcase in the clearest, simplest way possible to detect cycles and store a graph/tree in memory and in a database.</p>
<p>If you want to play with the code here and try to make it faster, go at it!</p>
<h2>Addendum: the full code</h2>
<details>
  <summary>The full code</summary>
<pre><code class="language-js">const adjacencyMatrix = [
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0],
];

const nodes = [&quot;Angela&quot;, &quot;Bella&quot;, &quot;Ellen&quot;, &quot;Jane&quot;, &quot;Miranda&quot;, &quot;Zoe&quot;];

function hasNodeNoIncomingEdge(adjacencyMatrix, nodeIndex) {
  const column = nodeIndex;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    const cell = adjacencyMatrix[row][column];

    if (cell != 0) {
      return false;
    }
  }

  return true;
}

function getNodesWithNoIncomingEdge(adjacencyMatrix, nodes) {
  return nodes.filter((_, i) =&gt; hasNodeNoIncomingEdge(adjacencyMatrix, i));
}

function graphHasEdges(adjacencyMatrix) {
  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] == 1) return true;
    }
  }

  return false;
}

function topologicalSort(adjacencyMatrix) {
  const L = [];
  const S = getNodesWithNoIncomingEdge(adjacencyMatrix, nodes);

  while (S.length &gt; 0) {
    const node = S.pop();
    L.push(node);
    const nodeIndex = nodes.indexOf(node);

    for (let mIndex = 0; mIndex &lt; nodes.length; mIndex += 1) {
      const hasEdgeFromNtoM = adjacencyMatrix[nodeIndex][mIndex];
      if (!hasEdgeFromNtoM) continue;

      adjacencyMatrix[nodeIndex][mIndex] = 0;

      if (hasNodeNoIncomingEdge(adjacencyMatrix, mIndex)) {
        const m = nodes[mIndex];
        S.push(m);
      }
    }
  }

  if (graphHasEdges(adjacencyMatrix)) {
    throw new Error(&quot;Graph has at least one cycle&quot;);
  }

  return L;
}

function hasMultipleRoots(adjacencyMatrix) {
  let countOfRowsWithOnlyZeroes = 0;

  for (let row = 0; row &lt; adjacencyMatrix.length; row += 1) {
    let rowHasOnlyZeroes = true;
    for (let column = 0; column &lt; adjacencyMatrix.length; column += 1) {
      if (adjacencyMatrix[row][column] != 0) {
        rowHasOnlyZeroes = false;
        break;
      }
    }
    if (rowHasOnlyZeroes) countOfRowsWithOnlyZeroes += 1;
  }

  return countOfRowsWithOnlyZeroes &gt; 1;
}

console.log(hasMultipleRoots(adjacencyMatrix));
const employeesTopologicallySorted = topologicalSort(structuredClone(adjacencyMatrix), nodes);
console.log(employeesTopologicallySorted);

const root = employeesTopologicallySorted[employeesTopologicallySorted.length - 1];
console.log(`INSERT INTO people VALUES(&quot;${root}&quot;, NULL)`);

for (let i = employeesTopologicallySorted.length - 2; i &gt;= 0; i -= 1) {
  const employee = employeesTopologicallySorted[i];
  const employeeIndex = nodes.indexOf(employee);

  const managerIndex = adjacencyMatrix[employeeIndex].indexOf(1);
  const manager = nodes[managerIndex];
  console.log(
    `INSERT INTO people SELECT &quot;${employee}&quot;, rowid FROM people WHERE name = &quot;${manager}&quot; LIMIT 1;`,
  );
}
</code></pre>
</details>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
