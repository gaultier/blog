<!--
This file has been auto-generated by main.c/main.bin from a markdown file of the same name.
Do not edit it by hand.
-->
<!DOCTYPE html>
<html>
<head>
<title>The missing cross-platform OS API for timers</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js" defer></script>
<script src="main.js" defer></script>
<script type="module" src="search_index.js" defer></script>
<script type="module" src="search.js" defer></script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <input id="search" placeholder="üîé Search" autocomplete=off>
    <ul>
      <li> <button id="dark-light-mode">Dark/Light</button> </li>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="currentColor"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"/>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" fill="currentColor">
          <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"/>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="#928374" />
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="currentColor" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"/></svg>
        </a> </li>
    </ul>
</div>
<div id="search-matches" hidden>
</div>
<div id="pseudo-body">

<div class="article-prelude">
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>
  <p class="publication-date">Published on 2026-02-27.</p>
</div>
<div class="article-title">
  <h1>The missing cross-platform OS API for timers</h1>
<div class="tags"> <a href="/blog/articles-by-tag.html#unix" class="tag">Unix</a> <a href="/blog/articles-by-tag.html#signals" class="tag">Signals</a> <a href="/blog/articles-by-tag.html#c" class="tag">C</a> <a href="/blog/articles-by-tag.html#linux" class="tag">Linux</a> <a href="/blog/articles-by-tag.html#freebsd" class="tag">FreeBSD</a> <a href="/blog/articles-by-tag.html#illumos" class="tag">Illumos</a> <a href="/blog/articles-by-tag.html#macos" class="tag">MacOS</a> <a href="/blog/articles-by-tag.html#windows" class="tag">Windows</a> <a href="/blog/articles-by-tag.html#openbsd" class="tag">OpenBSD</a> <a href="/blog/articles-by-tag.html#netbsd" class="tag">NetBSD</a> <a href="/blog/articles-by-tag.html#timers" class="tag">Timers</a> </div>
</div>
  <details class="toc"><summary>Table of contents</summary>
<ul>

  <li>
    <a href="#windows-settimer">Windows: SetTimer</a>
<ul>

  <li>
    <a href="#readers-suggestions-createwaitabletimer-createthreadpooltimer-createtimerqueuetimer">Readers suggestions: CreateWaitableTimer, CreateThreadpoolTimer, CreateTimerQueueTimer</a>
</li>
</ul>
</li>

  <li>
    <a href="#posix-timer-create-timer-settime">POSIX: timer_create, timer_settime</a>
</li>

  <li>
    <a href="#linux-timerfd-create-timerfd-settime">Linux: timerfd_create, timerfd_settime</a>
</li>

  <li>
    <a href="#bsd-kqueue-kevent">BSD: kqueue/kevent</a>
</li>

  <li>
    <a href="#illumos-port-create">Illumos: port_create</a>
</li>

  <li>
    <a href="#macos-dispatch-source-create">macOS: dispatch_source_create</a>
</li>

  <li>
    <a href="#linux-io-uring">Linux: io_uring</a>
</li>

  <li>
    <a href="#all-oses-timers-fully-implemented-in-userspace">All OSes: timers fully implemented in userspace</a>
</li>

  <li>
    <a href="#conclusion">Conclusion</a>
</li>
</ul>
</details>

<p><em>Discussions: <a href="https://old.reddit.com/r/programming/comments/1igik53/the_missing_crossplatform_os_api_for_timers/">/r/programming</a>, <a href="https://news.ycombinator.com/item?id=42915437">HN</a></em></p>
<p>Most serious programs will need to trigger some action at a delayed point in time, often repeatedly: set timeouts, clean up temporary files or entries in the database, send keep-alives, garbage-collect unused entities, etc. All while doing some work in the meantime. A blocking <code>sleep</code> won't cut it! For example, JavaScript has <code>setTimeout</code>. But how does it work under the hood? How does each OS handle that?</p>
<p>Lately, I have found myself in need of doing just that, repeatedly sending a keep-alive over the network to many remote peers, in C. My program has an event loop, a la NodeJS or Redis. It is doing lots of file I/O, network I/O, and handling timers, all in a single thread, in a non-blocking way.</p>
<p>And I wanted to do all that in a cross-platform way. And to my surprise, I could not find a (sane) libc function or syscall to create a timer, and that is the same on all Unices!</p>
<p>Each Unix variant had its own weird way to do it, as I discovered. I am used to Windows being the odd kid in its corner doing its thing, but usually, Unices (thanks to POSIX) agree on a simple API to do something. There's the elephant in the room, of course, with epoll/kqueue/event ports... Which is such a pain that numerous libraries have sprung up to paper over the differences and offer The <em>One API To Rule Them All</em>: libuv, libev, libevent, etc. So, are timers the same painful ordeal?</p>
<p>Well, let's take a tour of all the OS APIs to handle them.</p>
<h2 id="windows-settimer">
  <a class="title" href="#windows-settimer">Windows: SetTimer</a>
  <a class="hash-anchor" href="#windows-settimer" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>This will be brief because I do not develop on Windows. The official documentation mentions the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-settimer">SetTimer</a> function from Win32 and you pass it a timeout and a callback. Alternatively, since Windows applications come with a built-in event queue, an event of type <code>WM_TIMER</code> gets emitted and can be consumed from the queue. Simple, and it composes with other OS events, I like it.</p>
<h3 id="readers-suggestions-createwaitabletimer-createthreadpooltimer-createtimerqueuetimer">
  <a class="title" href="#readers-suggestions-createwaitabletimer-createthreadpooltimer-createtimerqueuetimer">Readers suggestions: CreateWaitableTimer, CreateThreadpoolTimer, CreateTimerQueueTimer</a>
  <a class="hash-anchor" href="#readers-suggestions-createwaitabletimer-createthreadpooltimer-createtimerqueuetimer" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h3>
<p>Readers with experience with <code>SetTimer</code> have pointed out that <code>SetTimer</code> has flaws:</p>
<ul>
<li>An invisible window must be created to get a message queue, which is opt-in.</li>
<li>The parameter size is limited which can be an issue.</li>
<li>The event <code>WM_TIMER</code> is low-priority so any other events, say mouse events, will take precedence.</li>
</ul>
<p>Worry not, there are alternatives (and again, I mention them in passing as someone who does not develop on Windows):</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/threadpoolapiset/nf-threadpoolapiset-createthreadpooltimer">CreateThreadpoolTimer</a> which works with the threadpool every Win32 process gets by default</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw">CreateWaitableTimer</a> does not need a window, and can be shared between processes to do inter-process synchronization. Which is pretty nifty. And a timer created by this function can be referred by name.</li>
</ul>
<h2 id="posix-timer-create-timer-settime">
  <a class="title" href="#posix-timer-create-timer-settime">POSIX: timer_create, timer_settime</a>
  <a class="hash-anchor" href="#posix-timer-create-timer-settime" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>POSIX has one API for timers, and it sucks. A timer is created with <code>timer_create</code>, which does initially nothing, and the timer is started with a timeout using <code>timer_settime</code>. When the timeout is reached, a signal is sent to the program. And that's the issue. Signals are <em>very</em> problematic, as seen in my <a href="/blog/way_too_many_ways_to_wait_for_a_child_process_with_a_timeout.html">previous article</a>:</p>
<ul>
<li>They do not compose with other OS primitives. This forces numerous syscalls to have a normal version and a signal-aware version that can block some signals for its duration: <code>poll/ppoll</code>, <code>select/pselect</code>, etc.</li>
<li>They are affected by the signal mask of the parent (e.g.: the shell, the service runner, etc)</li>
<li>They behave confusingly with child processes. Normally, a signal mask is inherited by the child. But some signal-triggering APIs (e.g.: <code>timer_settime</code>)  explicitly prevent child processes from inheriting their signals. I guess we'll have to read the fine prints in the man page!</li>
<li>It's hard to write complex programs with signals in mind due to their global nature. Code of our own, or in a library we use, could block some signals for some period of time, unbeknownst to us. Or simply modify the signal mask of the process, so we can never assume that the signal mask has a given value.</li>
<li>A signal handler has to use global variables, there is no way to pass it a pointer to some data.</li>
<li>Most functions are not async-signal-safe and should not be used from within a signal handler but no compiler warns about that and most example code is wrong. This is exacerbated by the fact that a given function may be async-signal safe on some OS but not on another. Or for some version of this OS but not for another version. This has caused real <a href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">security vulnerabilities</a> in the past.</li>
</ul>
<p>I'll just quote here the Linux man page for <a href="https://www.man7.org/linux/man-pages/man2/timer_create.2.html">timer_create</a>:</p>
<pre><code class="language-text"> /* Note: calling printf() from a signal handler is not safe
  (and should not be done in production programs), since
  printf() is not async-signal-safe; see signal-safety(7).
  Nevertheless, we use printf() here [...]. */
</code></pre>
<p>Enough said.</p>
<p>And this is really tricky to get right. For example, <code>malloc</code> is not async-signal-safe. By the way, you have to go out of your way to find this out, because the man page (at least on my system) does not mention anything about signals or async safety.</p>
<p>Well, you think, let's just remember to not use <code>malloc</code> in signal handlers! Done! Feeling confident, we happen to call <code>qsort</code> in our signal handler. Should be fine, right? We just sort some data in-place... Well, we just introduced a security vulnerability!</p>
<p>That's because in glibc, the innocent looking <code>qsort</code> <a href="https://www.qualys.com/2024/01/30/qsort.txt">calls</a> <code>malloc</code> under the hood! (And that was, in the past, the cause of <code>qsort</code> segfaulting, which I find hilarious):</p>
<blockquote>
<p>to our great surprise, we discovered
that the glibc's qsort() is not, in fact, a quick sort by default, but a
merge sort (in stdlib/msort.c).
[...]
But merge sort suffers from one
major drawback: it does not sort in-place -- it malloc()ates a copy of
the array of elements to be sorted.</p>
</blockquote>
<p>So...let's accept that writing signal handlers correctly is not feasible for us mere mortals. Many people have concluded the same in the past and have created better OS APIs that do not involve signals at all. Let's look into that.</p>
<h2 id="linux-timerfd-create-timerfd-settime">
  <a class="title" href="#linux-timerfd-create-timerfd-settime">Linux: timerfd_create, timerfd_settime</a>
  <a class="hash-anchor" href="#linux-timerfd-create-timerfd-settime" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>So, we all heard the saying: In Unix, everything is a file. So, what if a timer was also a file (descriptor)? And we could ask the OS to notify our program whenever there is data to read (i.e.: when our timer triggers), like with a file or a socket?
That's the whole idea behind <code>timerfd_create</code> and <code>timerfd_settime</code>. We create a timer, we get a file descriptor back.</p>
<p>In the previous article, we saw that Linux added similar APIs for signals with <code>signalfd</code> and processes with <code>pidfd_open</code>, so there is a consistent effort to indeed make everything a file.</p>
<p>That means that using the venerable <code>poll(2)</code>, we can wait on an array of very diverse things: sockets, files, signals, timers, processes, pipes, etc. This is great! That's simple (one API for all OS entities) and composable (handling an additional OS entity does not force our program to undergo big changes, and we can wait on diverse OS entities using the same API).</p>
<p>Let's see it in action by creating 10 timers and waiting for them to trigger:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;sys/timerfd.h&gt;
#include &lt;unistd.h&gt;

int main() {
  int queue = epoll_create(1 /* Ignored */);
  assert(-1 != queue);

  int res = 0;

  for (int i = 0; i &lt; 10; i++) {
    res = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
    assert(-1 != res);

    int fd = res;
    struct itimerspec ts = {.it_value.tv_nsec = i * 50 * 1000 * 1000};
    res = timerfd_settime(fd, 0, &amp;ts, NULL);
    assert(-1 != res);

    struct epoll_event ev = {
        .events = EPOLLIN,
        .data.fd = fd,
    };
    res = epoll_ctl(queue, EPOLL_CTL_ADD, fd, &amp;ev);
    assert(-1 != res);
  }

  int timeout_ms = 1000;

  struct epoll_event events[10] = {0};
  int events_len = 10;

  for (;;) {
    res = epoll_wait(queue, events, events_len, timeout_ms);
    assert(-1 != res);

    if (0 == res) { // The end.
      return 0;
    }

    for (int i = 0; i &lt; res; i++) {
      struct epoll_event event = events[i];
      if (event.events &amp; EPOLLIN) {
        struct timespec now = {0};
        clock_gettime(CLOCK_REALTIME, &amp;now);
        printf(&quot;[%ld.%03ld] timer %d triggered\n&quot;, now.tv_sec,
               now.tv_nsec / 1000 / 1000, event.data.fd);
        close(event.data.fd);
      }
    }
  }
}
</code></pre>
<p>And it prints:</p>
<pre><code class="language-text">[1738530944.233] timer 5 triggered
[1738530944.283] timer 6 triggered
[1738530944.333] timer 7 triggered
[1738530944.383] timer 8 triggered
[1738530944.433] timer 9 triggered
[1738530944.483] timer 10 triggered
[1738530944.533] timer 11 triggered
[1738530944.583] timer 12 triggered
[1738530944.633] timer 13 triggered
</code></pre>
<p>The only gotcha, which is mentioned by the man page, is that we need to remember to <code>read(2)</code> from the timer whenever it triggers. That only matters for repeating timers (also sometimes called interval timers).</p>
<p>There's even an additional benefit with this API: thanks to <code>ProcFS</code>, timers appear on the file system under <code>/proc/&lt;pid&gt;/fd/</code>, so troubleshooting is a bit easier.</p>
<p>However, it's unfortunate that this is a Linux-only API...or is it really?</p>
<ul>
<li><p>FreeBSD has it <a href="https://man.freebsd.org/cgi/man.cgi?query=timerfd&sektion=2&format=html">too</a>:</p>
<blockquote>
<p>The timerfd facility was	originally ported to FreeBSD's Linux  compatibility  layer  [...] in FreeBSD 12.0.
It  was	revised	 and  adapted  to   be	 native	  [...] in FreeBSD 14.0.</p>
</blockquote>
</li>
<li>Illumos has it <a href="https://smartos.org/man/3c/timerfd_create">too</a>.</li>
<li><p>NetBSD has it <a href="https://man.netbsd.org/timerfd_create.2">too</a>:</p>
<blockquote>
<p>The timerfd interface first appeared in NetBSD 10.  It is compatible with
the timerfd interface that appeared in Linux 2.6.25.</p>
</blockquote>
</li>
<li>OpenBSD does not seem to have it.</li>
<li>macOS does not seem to have it.</li>
</ul>
<p>So, pretty good, but not ubiquitous. The search continues.</p>
<h2 id="bsd-kqueue-kevent">
  <a class="title" href="#bsd-kqueue-kevent">BSD: kqueue/kevent</a>
  <a class="hash-anchor" href="#bsd-kqueue-kevent" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p><code>kqueue</code> might be my favorite OS API: it can watch any OS entity for changes with just one call. Even timers! As it is often the case for BSD-borne APIs, they are well designed and well documented. The man page says:</p>
<blockquote>
<p>EVFILT_TIMER   Establishes an arbitrary timer identified by ident.</p>
</blockquote>
<p>That's great, we do not even have to use various APIs to  create the timer, set the time, read from the timer, etc. We do not even have to destroy the timer ourselves, thanks to the <code>EV_ONESHOT</code> flag.</p>
<p>Let's see it in action:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/event.h&gt;
#include &lt;sys/time.h&gt;

int main() {
  int queue = kqueue();
  assert(-1 != queue);

  int res = 0;

  struct kevent changelist[10] = {0};
  for (int i = 0; i &lt; 10; i++) {
    changelist[i] = (struct kevent){
        .ident = i + 1,
        .flags = EV_ADD | EV_ONESHOT,
        .data = i * 50,
        .filter = EVFILT_TIMER,
        .fflags = NOTE_MSECONDS,
    };
  }

  res = kevent(queue, changelist, 10, NULL, 0, 0);
  assert(-1 != res);

  struct kevent eventlist[10] = {0};
  struct timespec timeout = {.tv_sec = 1};
  for (;;) {
    res = kevent(queue, NULL, 0, eventlist, 10, &amp;timeout);
    assert(-1 != res);

    if (0 == res) { // The end.
      return 0;
    }

    for (int i = 0; i &lt; res; i++) {
      struct kevent event = eventlist[i];
      if (event.filter &amp; EVFILT_TIMER) {
        struct timespec now = {0};
        clock_gettime(CLOCK_REALTIME, &amp;now);
        printf(&quot;[%ld.%03ld] timer %ld triggered\n&quot;, now.tv_sec,
               now.tv_nsec / 1000 / 1000, event.ident);
      }
    }
  }
}
</code></pre>
<p>And it prints:</p>
<pre><code class="language-text">[1738380963.984] timer 1 triggered
[1738380964.034] timer 2 triggered
[1738380964.084] timer 3 triggered
[1738380964.134] timer 4 triggered
[1738380964.184] timer 5 triggered
[1738380964.234] timer 6 triggered
[1738380964.284] timer 7 triggered
[1738380964.334] timer 8 triggered
[1738380964.384] timer 9 triggered
[1738380964.434] timer 10 triggered
</code></pre>
<p>What about the portability?</p>
<ul>
<li>FreeBSD has it</li>
<li>NetBSD has it</li>
<li>OpenBSD has it</li>
<li>macOS has it</li>
</ul>
<p><em>A past version of this section mentioned that this was not implemented on macOS. This used to be the case way back in the day, but an astute reader pointed out that Apple added this functionality at some point around macOS 10.9 (circa 2013).
Great news, and thanks, nice reader!</em></p>
<h2 id="illumos-port-create">
  <a class="title" href="#illumos-port-create">Illumos: port_create</a>
  <a class="hash-anchor" href="#illumos-port-create" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>So, Illumos (in)famously has its own API for multiplexing events from disjoint sources, that is different from <code>kqueue</code>, and some Illumos developers have publicly stated they now wished they had adopted <code>kqueue</code> back in the day.</p>
<p>Anyways, similarly to kqueue, their API (<code>port_create</code>) also supports timers! From the <a href="https://illumos.org/man/3C/port_create">man page</a>:</p>
<blockquote>
<p>PORT_SOURCE_TIMER events represent one or more timer expirations for a
given timer.  A timer is associated with a port by specifying SIGEV_PORT
as its notification mechanism.</p>
</blockquote>
<p>Interestingly, the timer is created using the POSIX API that normally triggers a signal upon timer expiration, but thanks to <code>port_create</code>, the signal is instead turned into an event ports notification, as if it was a file descriptor. I think it's pretty clever, because that means that historical code creating timers need not be modified. In other words, it makes the POSIX API sane by circumventing signals and integrating it into a more modern facility to make it composable with other OS entities.</p>
<h2 id="macos-dispatch-source-create">
  <a class="title" href="#macos-dispatch-source-create">macOS: dispatch_source_create</a>
  <a class="hash-anchor" href="#macos-dispatch-source-create" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Apple developers, in their infinite wisdom, decided to support <code>kqueue</code> timers, and also invented their own thing.</p>
<p>It's called <a href="https://man.archlinux.org/man/dispatch_source_create.3.en">dispatch_source_create</a> and it supports timers with <code>DISPATCH_SOURCE_TYPE_TIMER</code>.</p>
<p>I do not currently have access to an Apple computer so I have not tried it. All I know is that <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch">Grand Central Dispatch/libdispatch</a> is an effort to have applications have an event queue and thread pool managed for them by the OS. It's more of a task system, actually. All of this seems to me somewhat redundant with <code>kqueue</code> (which, on Apple platforms, came first!), but I am not an Apple engineer.</p>
<p><code>libdispatch</code> has technically been ported to many platforms but I suppose this is just like <code>libkqueue</code> on Linux: it exposes the familiar API, but under the hood, it translates all calls to the OS-specific API, so for all intents and purposes, this syscall is macOS specific (well, and iOS, tvOS, IpadOS, etc, but let's group them all into a 'macOS' bucket).</p>
<h2 id="linux-io-uring">
  <a class="title" href="#linux-io-uring">Linux: io_uring</a>
  <a class="hash-anchor" href="#linux-io-uring" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p><code>io_uring</code> is a fascinating Linux-only approach to essentially make every blocking system call... non-blocking. A syscall is enqueued into a ring buffer shared between userspace and the kernel, as a 'request', and at some point in time, a 'response' is enqueued by the kernel into a separate ring buffer that our program can read. It's simple, it's composable, it's great.</p>
<p>At the beginning I said that a blocking 'sleep' was not enough, because our program cannot do any work while sleeping. <code>io_uring</code> renders this moot: we can (conceptually) enqueue a sleep, do some work, for example enqueue other syscalls, and whenever our sleep finishes, we can dequeue it from the second ring buffer, and voila: we just implemented a timer.</p>
<p>It's so simple it's brilliant! Sadly, it's Linux only, only for recent-ish kernels, and some cloud providers disable this facility.</p>
<p>Let's see it in action:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;liburing.h&gt;
#include &lt;liburing/io_uring.h&gt;
#include &lt;stdio.h&gt;

int main() {
  struct io_uring ring = {0};
  if (io_uring_queue_init(10, &amp;ring, IORING_SETUP_SINGLE_ISSUER) &lt; 0) {
    return 1;
  }

  // Queue `sleep`.
  struct io_uring_sqe *sqe = NULL;
  for (int i = 1; i &lt;= 10; i++) {
    sqe = io_uring_get_sqe(&amp;ring);
    struct __kernel_timespec ts = {.tv_nsec = i * 50 * 1000 * 1000};
    io_uring_prep_timeout(sqe, &amp;ts, 1, IORING_TIMEOUT_ETIME_SUCCESS);
    sqe-&gt;user_data = i;
    assert(1 == io_uring_submit(&amp;ring));
  }

  for (int i = 0; i &lt; 10; i++) {
    struct io_uring_cqe *cqe = NULL;

    int ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);
    assert(0 == ret);
    assert(-ETIME == cqe-&gt;res);

    struct timespec now = {0};
    clock_gettime(CLOCK_REALTIME, &amp;now);
    printf(&quot;[%ld.%03ld] timer %lld triggered\n&quot;, now.tv_sec,
           now.tv_nsec / 1000 / 1000, cqe-&gt;user_data);
    io_uring_cqe_seen(&amp;ring, cqe);
  }
}
</code></pre>
<p>And it outputs:</p>
<pre><code class="language-text">[1738532785.771] timer 1 triggered
[1738532785.821] timer 2 triggered
[1738532785.871] timer 3 triggered
[1738532785.921] timer 4 triggered
[1738532785.971] timer 5 triggered
[1738532786.021] timer 6 triggered
[1738532786.071] timer 7 triggered
[1738532786.121] timer 8 triggered
[1738532786.171] timer 9 triggered
[1738532786.221] timer 10 triggered
</code></pre>
<h2 id="all-oses-timers-fully-implemented-in-userspace">
  <a class="title" href="#all-oses-timers-fully-implemented-in-userspace">All OSes: timers fully implemented in userspace</a>
  <a class="hash-anchor" href="#all-oses-timers-fully-implemented-in-userspace" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Frustrated by my research, not having found one sane API that exists on all Unices, I wondered: How does <code>libuv</code>, the C library powering all of the asynchronous I/O for NodeJS, do it? I knew they support <a href="https://docs.libuv.org/en/v1.x/timer.html">timers</a>. And they support all OSes, even the most obscure ones like AIX. Surely, they have found the best OS API!</p>
<p>Let's make a super simple C program using libuv timers (loosely adapted from their test suite):</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;uv.h&gt;

static void once_cb(uv_timer_t *handle) {
  printf(&quot;timer %#x triggered\n&quot;, handle);
}

int main() {
  uv_timer_t once_timers[10] = {0};
  int r = 0;

  /* Start 10 timers. */
  for (int i = 0; i &lt; 10; i++) {
    r = uv_timer_init(uv_default_loop(), &amp;once_timers[i]);
    assert(0 == r);
    r = uv_timer_start(&amp;once_timers[i], once_cb, i * i * 50, 0);
    assert(0 == r);
  }

  uv_run(uv_default_loop(), UV_RUN_DEFAULT);
}
</code></pre>
<p>We create 10 timers with increasing durations, and run the event loop. When a timer triggers, our callback is called by <code>libuv</code>.</p>
<p>Of course, in a real program, we would also do real work while the timers run, e.g. network I/O.</p>
<p>Let's compile our program and look at what syscalls are being done (here I am on Linux but we'll soon seen it does not matter at all):</p>
<pre><code class="language-shell">$ cc uv-timers.c -luv
$ strace ./a.out
[...]
epoll_pwait(3, [], 1024, 49, NULL, 8)   = 0
write(1, &quot;timer 0x27432398 triggered\n&quot;, 27timer 0x27432398 triggered
) = 27
epoll_pwait(3, [], 1024, 149, NULL, 8)  = 0
write(1, &quot;timer 0x27432430 triggered\n&quot;, 27timer 0x27432430 triggered
) = 27
epoll_pwait(3, [], 1024, 249, NULL, 8)  = 0
write(1, &quot;timer 0x274324c8 triggered\n&quot;, 27timer 0x274324c8 triggered
) = 27
epoll_pwait(3, [], 1024, 349, NULL, 8)  = 0
write(1, &quot;timer 0x27432560 triggered\n&quot;, 27timer 0x27432560 triggered
) = 27
[...]
</code></pre>
<p>Huh, no call to <code>timerfd_create</code> or something like this, just... <code>epoll_pwait</code> which is basically just <code>epoll_wait</code>, which is basically just a faster <code>poll</code>. And no events, just a timeout... So... are <code>libuv</code> timers fully implemented in userspace?</p>
<p>I was at this moment reminded of a <a href="https://smartos.org/man/7/timerfd">sentence</a> I had read from an Illumos man page:</p>
<blockquote>
<p>timerfd is a Linux-borne facility for creating POSIX timers and receiving
their subsequent events via a file descriptor.  The facility itself is
arguably unnecessary: portable code can [...] use the timeout value
present in poll(2) [...].</p>
</blockquote>
<p>So, what <code>libuv</code> does is quite simple in fact:</p>
<p>When a timer is created, it is added to an efficient data structure. It's a <a href="https://en.wikipedia.org/wiki/Binary_heap">min-heap</a>, i.e. a binary tree that is easy to implement and is designed to get the smallest element in a set quickly. It is typically used to implement priority queues, which is what this bookkeeping of user-space timers really is.</p>
<p>A typical event loop tick first gets the current time from the OS. Then, it computes the timeout to pass to poll/epoll/kqueue/etc.  If there are no active timers, it's easy, there is no timeout (that means that the program will block indefinitely until some I/O happens).</p>
<p>If there are active timers, get the 'smallest' one, meaning: the first that would trigger. The OS timeout is thus <code>now - timer.value</code>.
Whenever a timer expires, it is removed from the min-heap. Simple, (relatively) efficient. The only caveat is that <code>epoll</code> only offers a millisecond precision for the timeout parameter so that's also the precision of <code>libuv</code> timers.</p>
<p>This approach is reminiscent of this part from the <a href="https://www.man7.org/linux/man-pages/man2/select.2.html">man page</a> of <code>select</code> (which is basically <code>poll</code> with more limitations):</p>
<blockquote>
<p>Emulating usleep(3)</p>
<p>Before the advent of usleep(3), some code employed a call to
select() with all three sets empty, nfds zero, and a non-NULL
timeout as a fairly portable way to sleep with subsecond
precision.</p>
</blockquote>
<p>That way, we can 'sleep' while we also do meaningful work, for example network I/O. If some I/O completes before a timer triggers, we'll get notified by the OS and we can react to it. Then, during the next event loop tick, we'll compute a shorter timeout than the first one (since some time elapsed).</p>
<p>If no I/O happens at all, the OS will wake us up when our timeout is elapsed.</p>
<p>In short, we have multiplexed multiple timers using one system call (and a min-heap to remember what timers are on-going and when will the next one trigger).</p>
<p><em>Addendum</em>: A reader has pointed out that <a href="https://github.com/WebKit/WebKit/blob/main/Source/WebCore/platform/Timer.cpp">Webkit</a> does exactly the same.</p>
<h2 id="conclusion">
  <a class="title" href="#conclusion">Conclusion</a>
  <a class="hash-anchor" href="#conclusion" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>
</h2>
<p>Writing cross-platform C code typically means writing two code paths: one for Windows and one for Unix. But for multiplexed I/O, and for timers, each Unix has its own idea of what's the Right Way(tm).</p>
<p>To sum up:</p>
<p>| OS API                 | Windows | macOS | Linux | FreeBSD | NetBSD | OpenBSD | Illumos |
|------------------------|---------|-------|-------|---------|--------|---------|---------|
| SetTimer               | ‚úì       |       |       |         |        |         |         |
| POSIX timers [^1]      |         | ‚úì     | ‚úì     | ‚úì       | ‚úì      | ‚úì       | ‚úì       |
| timerfd                |         |       | ‚úì     | ‚úì       | ‚úì      |         | ‚úì       |
| kevent timer           |         | ‚úì     |       | ‚úì       | ‚úì      | ‚úì       |         |
| port_create timer      |         |       |       |         |        |         | ‚úì       |
| dispatch_source_create |         | ‚úì     |       |         |        |         |         |
| io_uring sleep [^2]    |         |       | ‚úì     |         |        |         |         |
| Userspace timers       | ‚úì       | ‚úì     | ‚úì     | ‚úì       | ‚úì      | ‚úì       | ‚úì       |</p>
<p>[^1]: Do not recommend using in non-trivial programs.
[^2]: Not always enabled.</p>
<p>For performant multiplexed I/O, that means that we have to have a code path for each OS (using <code>epoll</code> on Linux, <code>kqueue</code> on macOS and BSDs, event ports on Illumos, I/O completion ports on Windows).</p>
<p>For timers, it seems that the easiest approach is to implement them fully in userspace, as long as we have an efficient data structure to manage them.</p>

<p><a href="/blog"> ‚è¥ Back to all articles</a></p>
<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>

  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
