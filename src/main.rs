use markdown::{
    ParseOptions,
    mdast::{Node, Text},
};
use notify::{RecursiveMode, Result};
use notify_debouncer_mini::new_debouncer;
use rouille::{router, try_or_400, websocket};
use std::{
    ffi::OsString,
    fs::{self},
    path::{Path, PathBuf},
    thread,
    time::Duration,
};

use std::io::Write;

const AUTOGENERATED_COMMENT: &str = "<!--\nThis file has been auto-generated by main.c/main.bin from a markdown file of the same name.\nDo not edit it by hand.\n-->";
const BACK_LINK: &str = r#"<p><a href="/blog"> ‚è¥ Back to all articles</a></p>"#;

fn md_collect_titles(node: &Node, titles: &mut Vec<(String, u8)>) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_collect_titles(child, titles);
            }
        }
        Node::Heading(heading) => {
            let level = heading.depth;
            // TODO: Handle markdown title!
            assert_eq!(1, heading.children.len());
            let child = heading.children.first().unwrap();
            let content = match child {
                Node::Text(Text { value, .. }) => value.clone(),
                other => panic!("unexpected value: {:#?}", other),
            };
            titles.push((content, level));
        }
        Node::Paragraph(paragraph) => {
            for child in &paragraph.children {
                md_collect_titles(child, titles);
            }
        }
        _ => {}
    }
}

fn md_parse_metadata(md_content: &str) -> (&str, Vec<&str>) {
    let title_line = md_content.lines().next().unwrap();
    let title = title_line.strip_prefix("Title: ").unwrap().trim();

    let tags_line = md_content.lines().nth(1).unwrap();
    let tags_str = tags_line.strip_prefix("Tags: ").unwrap();
    let tags: Vec<&str> = tags_str.split(", ").map(|s| s.trim()).collect();

    (title, tags)
}

fn html_slug(s: &str) -> String {
    let mut res: Vec<u8> = Vec::with_capacity(s.len());

    for c in s.chars() {
        match c {
            '+' => res.extend(b"plus"),
            '#' => res.extend(b"sharp"),
            c if c.is_alphanumeric() => res.push(c.to_ascii_lowercase() as u8),
            // Other runes are mapped to `-`, but we avoid consecutive `-`.
            _ if res.last() != Some(&b'-') => {
                res.push(b'-');
            }
            _ => {}
        };
    }
    String::from_utf8(res).unwrap()
}

fn md_render_article_content(content: &mut Vec<u8>, node: &Node) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_render_article_content(content, child);
            }
        }
        Node::Blockquote(blockquote) => {
            write!(content, "<blockquote>").unwrap();

            for child in &blockquote.children {
                md_render_article_content(content, child);
            }
            write!(content, "</blockquote>").unwrap();
        }
        Node::FootnoteDefinition(footnote_definition) => todo!(),
        Node::MdxJsxFlowElement(_mdx_jsx_flow_element) => todo!(),
        Node::List(list) => todo!(),
        Node::MdxjsEsm(_mdxjs_esm) => todo!(),
        Node::Toml(_toml) => todo!(),
        Node::Yaml(_yaml) => todo!(),
        Node::Break(_) => todo!(),
        Node::InlineCode(inline_code) => {
            write!(content, "<code>{}</code>", inline_code.value).unwrap();
        }
        Node::InlineMath(_inline_math) => todo!(),
        Node::Delete(delete) => todo!(),
        Node::Emphasis(emphasis) => {
            write!(content, "<em>").unwrap();
            for child in &emphasis.children {
                md_render_article_content(content, child);
            }
            write!(content, "</em>").unwrap();
        }
        Node::MdxTextExpression(_mdx_text_expression) => todo!(),
        Node::FootnoteReference(footnote_reference) => todo!(),
        Node::Html(html) => {
            write!(content, "{}", html.value).unwrap();
        }
        Node::Image(image) => {
            write!(content, r#"<img src="{}" alt="{}"/>"#, image.url, image.alt).unwrap();
        }
        Node::ImageReference(_image_reference) => todo!(),
        Node::MdxJsxTextElement(_mdx_jsx_text_element) => todo!(),
        Node::Link(link) => {
            write!(content, r#"<a href="{}">"#, link.url).unwrap();
            for child in &link.children {
                md_render_article_content(content, child);
            }
            write!(content, r#"</a>"#).unwrap();
        }
        Node::LinkReference(_link_reference) => todo!(),
        Node::Strong(strong) => {
            write!(content, "<strong>").unwrap();
            for child in &strong.children {
                md_render_article_content(content, child);
            }
            write!(content, "</strong>").unwrap();
        }
        Node::Text(text) => {
            write!(content, "{}", text.value).unwrap();
        }
        Node::Code(code) => {
            write!(
                content,
                r#"<pre><code class="language-{}">{}</code></pre>"#,
                code.lang.as_ref().unwrap(),
                code.value
            )
            .unwrap();
        }
        Node::Math(_math) => todo!(),
        Node::MdxFlowExpression(_mdx_flow_expression) => todo!(),
        Node::Heading(heading) => {
            writeln!(content, "<h{}>", heading.depth).unwrap();
            for child in &heading.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</h{}>", heading.depth).unwrap();
        }
        Node::Table(table) => todo!(),
        Node::ThematicBreak(thematic_break) => todo!(),
        Node::TableRow(table_row) => todo!(),
        Node::TableCell(table_cell) => todo!(),
        Node::ListItem(list_item) => todo!(),
        Node::Definition(definition) => todo!(),
        Node::Paragraph(paragraph) => todo!(),
    }
}

fn md_render_article(html_header: &[u8], html_footer: &[u8], md_path: &Path) {
    assert!(!html_header.is_empty());
    assert!(!html_footer.is_empty());

    let md_content_bytes = fs::read(&md_path).unwrap();
    let md_content_bytes_len = md_content_bytes.len();
    let md_content = String::from_utf8(md_content_bytes).unwrap();
    let modified_at = std::fs::metadata(md_path).unwrap().modified().unwrap();
    // TODO: format modified_at.

    let (md_root_title, tags) = md_parse_metadata(&md_content);

    let metadata_delim = "---";
    let metadata_delim_pos = md_content.find(metadata_delim).unwrap();
    let (_, md_content) = md_content.split_at(metadata_delim_pos + metadata_delim.len());
    println!("md_content_start={}", &md_content[..20]);

    let md_ast = markdown::to_mdast(&md_content, &ParseOptions::default()).unwrap();

    let mut md_titles = Vec::with_capacity(12);
    md_collect_titles(&md_ast, &mut md_titles);
    println!("titles: {:#?}", md_titles);

    let mut html_content: Vec<u8> = Vec::with_capacity(md_content_bytes_len * 8);
    writeln!(
        html_content,
        "{}<!DOCTYPE html>\n<html>\n<head>\n<title>{}</title>",
        AUTOGENERATED_COMMENT, md_root_title
    )
    .unwrap();
    html_content.extend(html_header);
    writeln!(html_content, r#"<div class="article-prelude">"#).unwrap();
    writeln!(
        html_content,
        r#"{}<p class=\"publication-date\">Published on {:?}.</p>"#,
        BACK_LINK, modified_at
    )
    .unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(
        html_content,
        r#"<div class="article-title"><h1>{}</h1>"#,
        md_root_title
    )
    .unwrap();
    writeln!(html_content, r#"<div class="tags">"#).unwrap();
    for tag in tags {
        let id = html_slug(tag);
        writeln!(
            html_content,
            r#"<a href="/blog/articles-by-tag.html#{}" class="tag">{}</a>"#,
            id, tag
        )
        .unwrap();
    }
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();

    // TODO: TOC.

    md_render_article_content(&mut html_content, &md_ast);

    html_content.extend(BACK_LINK.as_bytes());
    html_content.extend(html_footer);

    let html_path = md_path.with_extension("html");
    fs::write(html_path, html_content).unwrap();
}

fn main() -> Result<()> {
    let md_path = PathBuf::from("x11_x64.md");
    let html_header = fs::read("header.html").unwrap();
    let html_footer = fs::read("footer.html").unwrap();
    md_render_article(&html_header, &html_footer, &md_path);

    //rouille::start_server("localhost:8001", move |request| {
    //    {
    //        // The `match_assets` function tries to find a file whose name corresponds to the URL
    //        // of the request. The second parameter (`"."`) tells where the files to look for are
    //        // located.
    //        // In order to avoid potential security threats, `match_assets` will never return any
    //        // file outside of this directory even if the URL is for example `/../../foo.txt`.
    //        let response = rouille::match_assets(request, "..");
    //
    //        // If a file is found, the `match_assets` function will return a response with a 200
    //        // status code and the content of the file. If no file is found, it will instead return
    //        // an empty 404 response.
    //        // Here we check whether if a file is found, and if so we return the response.
    //        if response.is_success() {
    //            return response;
    //        }
    //    }
    //
    //    router!(request,
    //
    //
    //
    //        (GET) (/ws) => {
    //            // This is the websockets route.
    //
    //            // In order to start using websockets we call `websocket::start`.
    //            // The function returns an error if the client didn't request websockets, in which
    //            // case we return an error 400 to the client thanks to the `try_or_400!` macro.
    //            //
    //            // The function returns a response to send back as part of the `start_server`
    //            // function, and a `websocket` variable of type `Receiver<Websocket>`.
    //            // Once the response has been sent back to the client, the `Receiver` will be
    //            // filled by rouille with a `Websocket` object representing the websocket.
    //
    //            let (response, websocket) = try_or_400!(websocket::start(request, Some("echo")));
    //
    //            let watching_path = request.url();
    //            thread::spawn(move || {
    //                // This line will block until the `response` above has been returned.
    //                let ws = websocket.recv().unwrap();
    //                websocket_handling_thread(ws, watching_path);
    //            });
    //            response
    //        },
    //        _ => rouille::Response::empty_404()
    //    )
    //});
    Ok(())
}

//fn websocket_handling_thread(mut websocket: websocket::Websocket, watching_path: String) {
//    println!("new websocket");
//    let (etx, erx) = std::sync::mpsc::channel();
//
//    let mut debouncer = new_debouncer(Duration::from_millis(200), etx).unwrap();
//
//    debouncer
//        .watcher()
//        .watch(Path::new("."), RecursiveMode::Recursive)
//        .unwrap();
//
//    let md_ext: OsString = "md".into();
//
//    // Block forever, printing out events as they come in
//    for res in erx {
//        match res {
//            Ok(events) => {
//                for event in events {
//                    let stem = event
//                        .path
//                        .file_stem()
//                        .unwrap()
//                        .to_string_lossy()
//                        .to_string();
//                    if event.path.extension().unwrap_or_default() == md_ext {
//                        println!("event: {:?}", event);
//
//                        let md_content_bytes = fs::read(&event.path).unwrap();
//                        let md_content_utf8 = String::from_utf8(md_content_bytes).unwrap();
//                        let md_ast = markdown::to_mdast(&md_content_utf8, &ParseOptions::default());
//                        println!("{:#?}", md_ast);
//                        let html_content = markdown::to_html(&md_content_utf8);
//
//                        let html_path = event.path.clone().with_extension("html");
//                        println!("write to: {:?}", &html_path);
//                        fs::write(html_path, html_content).unwrap();
//
//                        let file_path_str =
//                            event.path.file_stem().unwrap_or_default().to_string_lossy();
//                        websocket.send_text(&file_path_str).unwrap();
//                        return;
//                    }
//                }
//            }
//            Err(e) => eprintln!("watch error: {:?}", e),
//        }
//    }
//    println!("end of file watch & websocket handling");
//}
