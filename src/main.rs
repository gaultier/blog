use markdown::{
    ParseOptions,
    mdast::{Node, Text},
};
use notify::{RecursiveMode, Result};
use notify_debouncer_mini::new_debouncer;
use rouille::{router, try_or_400, websocket};
use std::{
    borrow::Cow,
    ffi::OsString,
    fs::{self},
    path::{Path, PathBuf},
    thread,
    time::Duration,
};
use time::OffsetDateTime;

use std::io::Write;

const AUTOGENERATED_COMMENT: &str = "<!--\nThis file has been auto-generated by main.c/main.bin from a markdown file of the same name.\nDo not edit it by hand.\n-->";
const BACK_LINK: &str = r#"<p><a href="/blog"> ‚è¥ Back to all articles</a></p>"#;

// TODO: Return Rc<String> or Cow<str>?
fn md_collect_titles(node: &Node, titles: &mut Vec<(String, u8)>) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_collect_titles(child, titles);
            }
        }
        Node::Heading(heading) => {
            let level = heading.depth;
            // TODO: Handle markdown title!
            assert_eq!(1, heading.children.len());
            let child = heading.children.first().unwrap();
            let content = match child {
                Node::Text(Text { value, .. }) => value.clone(),
                other => panic!("unexpected value: {:#?}", other),
            };
            titles.push((content, level));
        }
        Node::Paragraph(paragraph) => {
            for child in &paragraph.children {
                md_collect_titles(child, titles);
            }
        }
        _ => {}
    }
}

fn md_parse_metadata(md_content: &str) -> (&str, Vec<&str>) {
    let title_line = md_content.lines().next().unwrap();
    let title = title_line.strip_prefix("Title: ").unwrap().trim();

    let tags_line = md_content.lines().nth(1).unwrap();
    let tags_str = tags_line.strip_prefix("Tags: ").unwrap();
    let tags: Vec<&str> = tags_str.split(", ").map(|s| s.trim()).collect();

    (title, tags)
}

fn html_slug(s: &str) -> String {
    let mut res: Vec<u8> = Vec::with_capacity(s.len());

    for c in s.chars() {
        match c {
            '+' => res.extend(b"plus"),
            '#' => res.extend(b"sharp"),
            c if c.is_alphanumeric() => res.push(c.to_ascii_lowercase() as u8),
            // Other runes are mapped to `-`, but we avoid consecutive `-`.
            _ if res.last() != Some(&b'-') => {
                res.push(b'-');
            }
            _ => {}
        };
    }
    let s = String::from_utf8(res).unwrap();
    s.trim_matches(|c| c == '-').to_owned()
}

fn md_render_article_content(content: &mut Vec<u8>, node: &Node) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_render_article_content(content, child);
            }
        }
        Node::Blockquote(blockquote) => {
            writeln!(content, "<blockquote>").unwrap();

            for child in &blockquote.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</blockquote>").unwrap();
        }
        Node::FootnoteDefinition(footnote_definition) => todo!(),
        Node::MdxJsxFlowElement(_mdx_jsx_flow_element) => todo!(),
        Node::List(list) => {
            if list.ordered {
                writeln!(content, "<ol>").unwrap();
            } else {
                writeln!(content, "<ul>").unwrap();
            }
            for child in &list.children {
                md_render_article_content(content, child);
            }
            if list.ordered {
                writeln!(content, "</ol>").unwrap();
            } else {
                writeln!(content, "</ul>").unwrap();
            }
        }
        Node::MdxjsEsm(_mdxjs_esm) => todo!(),
        Node::Toml(_toml) => todo!(),
        Node::Yaml(_yaml) => todo!(),
        Node::Break(_) => todo!(),
        Node::InlineCode(inline_code) => {
            let sanitized = text_sanitize_for_html(&inline_code.value);
            write!(content, "<code>{}</code>", sanitized).unwrap();
        }
        Node::InlineMath(_inline_math) => todo!(),
        Node::Delete(delete) => todo!(),
        Node::Emphasis(emphasis) => {
            write!(content, "<em>").unwrap();
            for child in &emphasis.children {
                md_render_article_content(content, child);
            }
            write!(content, "</em>").unwrap();
        }
        Node::MdxTextExpression(_mdx_text_expression) => todo!(),
        Node::FootnoteReference(footnote_reference) => todo!(),
        Node::Html(html) => {
            write!(content, "{}", html.value).unwrap();
        }
        Node::Image(image) => {
            write!(
                content,
                r#"<img src="{}" alt="{}" />"#,
                image.url, image.alt
            )
            .unwrap();
        }
        Node::ImageReference(_image_reference) => todo!(),
        Node::MdxJsxTextElement(_mdx_jsx_text_element) => todo!(),
        Node::Link(link) => {
            write!(content, r#"<a href="{}">"#, link.url).unwrap();
            for child in &link.children {
                md_render_article_content(content, child);
            }
            write!(content, r#"</a>"#).unwrap();
        }
        Node::LinkReference(_link_reference) => todo!(),
        Node::Strong(strong) => {
            write!(content, "<strong>").unwrap();
            for child in &strong.children {
                md_render_article_content(content, child);
            }
            write!(content, "</strong>").unwrap();
        }
        Node::Text(text) => {
            let sanitized = text_sanitize_for_html(&text.value);
            write!(content, "{}", sanitized).unwrap();
        }
        Node::Code(code) => {
            let sanitized = text_sanitize_for_html(&code.value);
            writeln!(
                content,
                r#"<pre><code class="language-{}">{}
</code></pre>"#,
                code.lang.as_ref().unwrap(),
                sanitized
            )
            .unwrap();
        }
        Node::Math(_math) => todo!(),
        Node::MdxFlowExpression(_mdx_flow_expression) => todo!(),
        Node::Heading(heading) => {
            assert_eq!(heading.children.len(), 1);
            let value = md_ast_extract_children_text(&heading.children).unwrap();
            let sanitized = text_sanitize_for_html(&value);
            let slug = html_slug(&sanitized);

            writeln!(content, r#"<h{} id="{}">"#, heading.depth, slug).unwrap();
            write!(content, r#"  <a class="title" href="{}{}">"#, "#", slug).unwrap();
            for child in &heading.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</a>").unwrap();
            writeln!(content, r#"  <a class="hash-anchor" href="{}{}" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>"#,"#", slug).unwrap();
            writeln!(content, "</h{}>", heading.depth).unwrap();
        }
        Node::Table(table) => {
            writeln!(content, "<table>").unwrap();
            for child in &table.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</table>\n\n").unwrap();
        }
        Node::ThematicBreak(_) => {
            writeln!(content, "<hr />").unwrap();
        }
        Node::TableRow(table_row) => {
            writeln!(content, "<tr>").unwrap();
            for child in &table_row.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</tr>").unwrap();
        }
        Node::TableCell(table_cell) => {
            writeln!(content, "<td>").unwrap();
            for child in &table_cell.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</td>").unwrap();
        }
        Node::ListItem(list_item) => {
            write!(content, "<li>").unwrap();
            if let Some(text) = md_ast_extract_children_text(&list_item.children) {
                write!(content, "{}", text_sanitize_for_html(text)).unwrap();
            } else {
                for child in &list_item.children {
                    md_render_article_content(content, child);
                }
            }
            writeln!(content, "</li>").unwrap();
        }
        Node::Definition(_definition) => todo!(),
        Node::Paragraph(paragraph) => {
            write!(content, "<p>").unwrap();
            for child in &paragraph.children {
                md_render_article_content(content, child);
            }
            writeln!(content, "</p>").unwrap();
        }
    }
}

fn md_ast_extract_children_text(nodes: &[Node]) -> Option<&str> {
    if nodes.len() == 1
        && let Some(child) = nodes.first()
    {
        match child {
            Node::Text(t) => Some(&t.value),
            Node::Paragraph(p) if p.children.len() == 1 => match &p.children[0] {
                Node::Text(t) => Some(&t.value),
                _ => None,
            },
            _ => None,
        }
    } else {
        None
    }
}

fn text_sanitize_for_html(s: &str) -> Cow<'_, str> {
    if !s.contains(['&', '<', '>', '"', '\'']) {
        Cow::Borrowed(s)
    } else {
        let mut result = String::with_capacity(s.len());
        for c in s.chars() {
            match c {
                '&' => result.push_str("&amp;"),
                '<' => result.push_str("&lt;"),
                '>' => result.push_str("&gt;"),
                '"' => result.push_str("&quot;"),
                '\'' => result.push_str("&#39;"),
                other => result.push(other),
            }
        }
        Cow::Owned(result)
    }
}

fn md_render_toc(content: &mut Vec<u8>, titles: &[(String, u8)]) {
    if titles.is_empty() {
        return;
    }

    dbg!(titles);

    writeln!(
        content,
        r#"  <details class="toc"><summary>Table of contents</summary>
<ul>"#
    )
    .unwrap();

    let mut current_level = titles[0].1;

    for (i, (title, level)) in titles.iter().enumerate() {
        let level = *level;
        if level > current_level {
            for _ in 0..(level - current_level) {
                writeln!(content, "<ul>").unwrap();
            }
        } else if level < current_level {
            // Close the current <li>, then close the <ul> levels, then close the parent <li>.
            for _ in 0..(current_level - level) {
                writeln!(content, "</li></ul>").unwrap();
            }
            writeln!(content, "</li>").unwrap(); // Close the <li> of the previous same-level item.
        } else if i > 0 {
            // Same level: just close the previous item.
            writeln!(content, "</li>").unwrap();
        }
        current_level = level;

        writeln!(
            content,
            r#"{}  <li>
    <a href="{}{}">{}</a>
  </li>"#,
            "\n",
            "#",
            html_slug(&title),
            &title,
        )
        .unwrap();
    }

    // 3. Final Cleanup: Close all remaining open tags.
    let base_level = titles[0].1;
    for _ in 0..(current_level - base_level) {
        writeln!(content, "</li></ul>").unwrap();
    }
    writeln!(content, "</ul>\n</details>").unwrap();
}

fn md_render_article(html_header: &[u8], html_footer: &[u8], md_path: &Path) {
    assert!(!html_header.is_empty());
    assert!(!html_footer.is_empty());

    let md_content_bytes = fs::read(&md_path).unwrap();
    let md_content_bytes_len = md_content_bytes.len();
    let md_content = String::from_utf8(md_content_bytes).unwrap();
    let modified_at = std::fs::metadata(md_path).unwrap().modified().unwrap();
    let datetime: OffsetDateTime = modified_at.into();
    let format = time::format_description::parse("[year]-[month]-[day]").unwrap();
    let modified_at_formatted = datetime.format(&format).unwrap();
    // TODO: format modified_at.

    let (md_root_title, tags) = md_parse_metadata(&md_content);

    let metadata_delim = "---";
    let metadata_delim_pos = md_content.find(metadata_delim).unwrap();
    let (_, md_content) = md_content.split_at(metadata_delim_pos + metadata_delim.len());

    let md_ast = markdown::to_mdast(&md_content, &ParseOptions::default()).unwrap();

    let mut md_titles = Vec::with_capacity(12);
    md_collect_titles(&md_ast, &mut md_titles);

    let mut html_content: Vec<u8> = Vec::with_capacity(md_content_bytes_len * 8);
    writeln!(
        html_content,
        "{}
<!DOCTYPE html>\n<html>\n<head>\n<title>{}</title>",
        AUTOGENERATED_COMMENT, md_root_title
    )
    .unwrap();
    html_content.extend(html_header);
    writeln!(html_content, r#"<div class="article-prelude">"#).unwrap();
    writeln!(
        html_content,
        r#"{}
  <p class="publication-date">Published on {}.</p>"#,
        BACK_LINK, modified_at_formatted
    )
    .unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(
        html_content,
        r#"<div class="article-title">
  <h1>{}</h1>"#,
        md_root_title
    )
    .unwrap();
    write!(html_content, r#"<div class="tags"> "#).unwrap();
    for tag in tags {
        let id = html_slug(tag);
        write!(
            html_content,
            r#"<a href="/blog/articles-by-tag.html#{}" class="tag">{}</a> "#,
            id, tag
        )
        .unwrap();
    }
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();

    md_render_toc(&mut html_content, &md_titles);

    md_render_article_content(&mut html_content, &md_ast);

    write!(html_content, "\n{}", BACK_LINK).unwrap();
    html_content.extend(html_footer);

    let html_path = md_path.with_extension("html");
    fs::write(html_path, html_content).unwrap();
}

fn main() -> Result<()> {
    let md_path = PathBuf::from("x11_x64.md");
    let html_header = fs::read("header.html").unwrap();
    let html_footer = fs::read("footer.html").unwrap();
    md_render_article(&html_header, &html_footer, &md_path);

    rouille::start_server("localhost:8001", move |request| {
        {
            // The `match_assets` function tries to find a file whose name corresponds to the URL
            // of the request. The second parameter (`"."`) tells where the files to look for are
            // located.
            // In order to avoid potential security threats, `match_assets` will never return any
            // file outside of this directory even if the URL is for example `/../../foo.txt`.
            let response = rouille::match_assets(request, "..");

            // If a file is found, the `match_assets` function will return a response with a 200
            // status code and the content of the file. If no file is found, it will instead return
            // an empty 404 response.
            // Here we check whether if a file is found, and if so we return the response.
            if response.is_success() {
                return response;
            }
        }

        router!(request,



            (GET) (/ws) => {
                // This is the websockets route.

                // In order to start using websockets we call `websocket::start`.
                // The function returns an error if the client didn't request websockets, in which
                // case we return an error 400 to the client thanks to the `try_or_400!` macro.
                //
                // The function returns a response to send back as part of the `start_server`
                // function, and a `websocket` variable of type `Receiver<Websocket>`.
                // Once the response has been sent back to the client, the `Receiver` will be
                // filled by rouille with a `Websocket` object representing the websocket.

                let (response, websocket) = try_or_400!(websocket::start(request, Some("echo")));

                let watching_path = request.url();
                thread::spawn(move || {
                    // This line will block until the `response` above has been returned.
                    let ws = websocket.recv().unwrap();
                    websocket_handling_thread(ws, watching_path);
                });
                response
            },
            _ => rouille::Response::empty_404()
        )
    });
}

fn websocket_handling_thread(mut websocket: websocket::Websocket, watching_path: String) {
    println!("new websocket");
    let (etx, erx) = std::sync::mpsc::channel();

    let mut debouncer = new_debouncer(Duration::from_millis(200), etx).unwrap();

    debouncer
        .watcher()
        .watch(Path::new("."), RecursiveMode::Recursive)
        .unwrap();

    let md_ext: OsString = "md".into();

    // Block forever, printing out events as they come in
    for res in erx {
        match res {
            Ok(events) => {
                for event in events {
                    let stem = event
                        .path
                        .file_stem()
                        .unwrap()
                        .to_string_lossy()
                        .to_string();
                    if event.path.extension().unwrap_or_default() == md_ext {
                        println!("event: {:?}", event);

                        let md_path = PathBuf::from(&event.path);
                        let html_header = fs::read("header.html").unwrap();
                        let html_footer = fs::read("footer.html").unwrap();
                        md_render_article(&html_header, &html_footer, &md_path);

                        let file_path_str =
                            event.path.file_stem().unwrap_or_default().to_string_lossy();
                        websocket.send_text(&file_path_str).unwrap();
                        return;
                    }
                }
            }
            Err(e) => eprintln!("watch error: {:?}", e),
        }
    }
    println!("end of file watch & websocket handling");
}
