use markdown::{
    ParseOptions,
    mdast::{FootnoteDefinition, Node, Text},
};
use notify::{RecursiveMode, Result};
use notify_debouncer_mini::new_debouncer;
use rouille::{router, try_or_400, websocket};
use std::{
    borrow::Cow,
    collections::BTreeMap,
    ffi::OsString,
    fs::{self},
    path::{Path, PathBuf},
    time::Duration,
};
use time::OffsetDateTime;

use std::io::Write;

const AUTOGENERATED_COMMENT: &str = "<!--\nThis file has been auto-generated by main.c/main.bin from a markdown file of the same name.\nDo not edit it by hand.\n-->";
const BACK_LINK: &str = r#"<p><a href="/blog"> ⏴ Back to all articles</a></p>"#;

struct Title {
    text: String,
    depth: u8,
    start_md_offset: usize,
    slug: String,
}

// TODO: Return Rc<String> or Cow<str>?
fn md_collect_titles(
    node: &Node,
    title_to_counter: &mut BTreeMap<String, u8>,
    titles: &mut Vec<Title>,
) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_collect_titles(child, title_to_counter, titles);
            }
        }
        Node::Heading(heading) => {
            let depth = heading.depth;
            // TODO: Handle markdown title!
            assert_eq!(1, heading.children.len());
            let child = heading.children.first().unwrap();
            let content = match child {
                Node::Text(Text { value, .. }) => value.clone(),
                other => panic!("unexpected value: {:#?}", other),
            };

            let counter = title_to_counter
                .entry(content.clone())
                .and_modify(|c| *c += 1)
                .or_insert(0);
            let slug_target = if *counter > 0 {
                Cow::Owned(format!("{}-{}", &content, counter))
            } else {
                Cow::Borrowed(&content)
            };
            let slug = html_slug(&slug_target);
            titles.push(Title {
                text: content,
                depth,
                start_md_offset: heading.position.as_ref().unwrap().start.offset,
                slug,
            });
        }
        Node::Paragraph(paragraph) => {
            for child in &paragraph.children {
                md_collect_titles(child, title_to_counter, titles);
            }
        }
        _ => {}
    }
}

fn md_parse_metadata(md_content: &str) -> (&str, Vec<&str>) {
    let title_line = md_content.lines().next().unwrap();
    let title = title_line.strip_prefix("Title: ").unwrap().trim();

    let tags_line = md_content.lines().nth(1).unwrap();
    let tags_str = tags_line.strip_prefix("Tags: ").unwrap();
    let tags: Vec<&str> = tags_str.split(", ").map(|s| s.trim()).collect();

    (title, tags)
}

fn html_slug(s: &str) -> String {
    let mut res = String::with_capacity(s.len());

    for c in s.chars() {
        match c {
            '+' => res.push_str("plus"),
            '#' => res.push_str("sharp"),
            c if c.is_ascii_alphanumeric() => res.push(c.to_ascii_lowercase()),
            // Other runes are mapped to `-`, but we avoid consecutive `-`.
            _ if res.chars().last() != Some('-') => {
                res.push('-');
            }
            _ => {}
        };
    }
    res.trim_matches(|c| c == '-').to_owned()
}

fn md_render_article_content(
    content: &mut Vec<u8>,
    footnote_defs: &mut Vec<FootnoteDefinition>,
    node: &Node,
    titles: &[Title],
) {
    match node {
        Node::Root(root) => {
            for child in &root.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
        }
        Node::Blockquote(blockquote) => {
            writeln!(content, "<blockquote>").unwrap();

            for child in &blockquote.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</blockquote>").unwrap();
        }
        Node::FootnoteDefinition(footnote_definition) => {
            footnote_defs.push(footnote_definition.clone());
        }
        Node::MdxJsxFlowElement(_mdx_jsx_flow_element) => todo!(),
        Node::List(list) => {
            let tag = if list.ordered { "ol" } else { "ul" };
            if let Some(start) = list.start
                && start > 1
            {
                writeln!(content, r#"<{} start="{}">"#, tag, start).unwrap();
            } else {
                writeln!(content, r#"<{}>"#, tag).unwrap();
            }
            for child in &list.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</{}>", tag).unwrap();
        }
        Node::MdxjsEsm(_mdxjs_esm) => todo!(),
        Node::Toml(_toml) => todo!(),
        Node::Yaml(_yaml) => todo!(),
        Node::Break(_) => todo!(),
        Node::InlineCode(inline_code) => {
            let sanitized = text_sanitize_for_html(&inline_code.value);
            write!(content, "<code>{}</code>", sanitized).unwrap();
        }
        Node::InlineMath(_inline_math) => todo!(),
        Node::Delete(delete) => {
            write!(content, "<del>").unwrap();
            for child in &delete.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            write!(content, "</del>").unwrap();
        }
        Node::Emphasis(emphasis) => {
            write!(content, "<em>").unwrap();
            for child in &emphasis.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            write!(content, "</em>").unwrap();
        }
        Node::MdxTextExpression(_mdx_text_expression) => todo!(),
        Node::FootnoteReference(footnote_reference) => {
            writeln!(
                content,
                r#"<sup class="footnote-ref"><a href="{}fn-{}" id="fnref-{}" data-footnote-ref>{}</a></sup>"#,
                "#",
                &footnote_reference.identifier,
                footnote_reference.identifier,
                footnote_reference.label.as_ref().unwrap(),
            )
            .unwrap();
        }
        Node::Html(html) => {
            writeln!(content, "{}", html.value).unwrap();
        }
        Node::Image(image) => {
            write!(
                content,
                r#"<img src="{}" alt="{}" />"#,
                image.url, image.alt
            )
            .unwrap();
        }
        Node::ImageReference(_image_reference) => todo!(),
        Node::MdxJsxTextElement(_mdx_jsx_text_element) => todo!(),
        Node::Link(link) => {
            write!(
                content,
                r#"<a href="{}">"#,
                text_sanitize_for_html(&link.url)
            )
            .unwrap();
            for child in &link.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            write!(content, r#"</a>"#).unwrap();
        }
        Node::LinkReference(_link_reference) => todo!(),
        Node::Strong(strong) => {
            write!(content, "<strong>").unwrap();
            for child in &strong.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            write!(content, "</strong>").unwrap();
        }
        Node::Text(text) => {
            let sanitized = text_sanitize_for_html(&text.value);
            write!(content, "{}", sanitized).unwrap();
        }
        Node::Code(code) => {
            let sanitized = text_sanitize_for_html(&code.value);
            writeln!(
                content,
                r#"<pre><code class="language-{}">{}
</code></pre>"#,
                code.lang.as_ref().unwrap(),
                sanitized
            )
            .unwrap();
        }
        Node::Math(_math) => todo!(),
        Node::MdxFlowExpression(_mdx_flow_expression) => todo!(),
        Node::Heading(heading) => {
            assert_eq!(heading.children.len(), 1);
            let title = titles
                .iter()
                .find(|t| t.start_md_offset == heading.position.as_ref().unwrap().start.offset)
                .unwrap();

            writeln!(content, r#"<h{} id="{}">"#, heading.depth, title.slug).unwrap();
            write!(
                content,
                r#"  <a class="title" href="{}{}">"#,
                "#", title.slug
            )
            .unwrap();
            for child in &heading.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</a>").unwrap();
            writeln!(content, r#"  <a class="hash-anchor" href="{}{}" aria-hidden="true" onclick="navigator.clipboard.writeText(this.href);"></a>"#,"#", title.slug).unwrap();
            writeln!(content, "</h{}>", heading.depth).unwrap();
        }
        Node::Table(table) => {
            writeln!(content, "<table>").unwrap();
            for child in &table.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</table>\n\n").unwrap();
        }
        Node::ThematicBreak(_) => {
            writeln!(content, "<hr />").unwrap();
        }
        Node::TableRow(table_row) => {
            writeln!(content, "<tr>").unwrap();
            for child in &table_row.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</tr>").unwrap();
        }
        Node::TableCell(table_cell) => {
            writeln!(content, "<td>").unwrap();
            for child in &table_cell.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</td>").unwrap();
        }
        Node::ListItem(list_item) => {
            write!(content, "<li>").unwrap();
            let children = if list_item.children.len() == 1
                && let Node::Paragraph(p) = &list_item.children[0]
            {
                &p.children
            } else {
                &list_item.children
            };
            for child in children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</li>").unwrap();
        }
        Node::Definition(_definition) => todo!(),
        Node::Paragraph(paragraph) => {
            write!(content, "<p>").unwrap();
            for child in &paragraph.children {
                md_render_article_content(content, footnote_defs, child, titles);
            }
            writeln!(content, "</p>").unwrap();
        }
    }
}

fn text_sanitize_for_html(s: &str) -> Cow<'_, str> {
    if !s.contains(['&', '<', '>', '"', '\'']) {
        Cow::Borrowed(s)
    } else {
        let mut result = String::with_capacity(s.len());
        for c in s.chars() {
            match c {
                '&' => result.push_str("&amp;"),
                '<' => result.push_str("&lt;"),
                '>' => result.push_str("&gt;"),
                '"' => result.push_str("&quot;"),
                // '\'' => result.push_str("&#39;"),
                other => result.push(other),
            }
        }
        Cow::Owned(result)
    }
}

fn md_render_toc(content: &mut Vec<u8>, titles: &[Title]) {
    if titles.is_empty() {
        return;
    }

    writeln!(
        content,
        r#"  <details class="toc"><summary>Table of contents</summary>
<ul>"#
    )
    .unwrap();

    let mut current_depth = titles[0].depth;

    for (i, title) in titles.iter().enumerate() {
        if title.depth > current_depth {
            for _ in 0..(title.depth - current_depth) {
                writeln!(content, "<ul>").unwrap();
            }
        } else if title.depth < current_depth {
            // Close the current <li>, then close the <ul> levels, then close the parent <li>.
            for _ in 0..(current_depth - title.depth) {
                writeln!(content, "</li>\n</ul>").unwrap();
            }
            writeln!(content, "</li>").unwrap(); // Close the <li> of the previous same-level item.
        } else if i > 0 {
            // Same level: just close the previous item.
            writeln!(content, "</li>").unwrap();
        }
        current_depth = title.depth;

        writeln!(
            content,
            r#"{}  <li>
    <a href="{}{}">{}</a>"#,
            "\n", "#", title.slug, &title.text,
        )
        .unwrap();
    }

    // 3. Final Cleanup: Close all remaining open tags.
    let base_depth = titles[0].depth;
    for _ in 0..=(current_depth - base_depth) {
        writeln!(content, "</li>\n</ul>").unwrap();
    }
    writeln!(content, "</details>\n").unwrap();
}

fn md_render_article(html_header: &[u8], html_footer: &[u8], md_path: &Path) {
    assert!(!html_header.is_empty());
    assert!(!html_footer.is_empty());

    let md_content_bytes = fs::read(&md_path).unwrap();
    let md_content_bytes_len = md_content_bytes.len();
    let md_content = String::from_utf8(md_content_bytes).unwrap();
    let modified_at = std::fs::metadata(md_path).unwrap().modified().unwrap();
    let datetime: OffsetDateTime = modified_at.into();
    let format = time::format_description::parse("[year]-[month]-[day]").unwrap();
    let modified_at_formatted = datetime.format(&format).unwrap();
    // TODO: format modified_at.

    let (md_root_title, tags) = md_parse_metadata(&md_content);

    let metadata_delim = "---";
    let metadata_delim_pos = md_content.find(metadata_delim).unwrap();
    let (_, md_content) = md_content.split_at(metadata_delim_pos + metadata_delim.len());

    let md_ast = markdown::to_mdast(
        &md_content,
        &ParseOptions {
            constructs: markdown::Constructs::gfm(),
            gfm_strikethrough_single_tilde: true,
            ..Default::default()
        },
    )
    .unwrap();

    let mut md_titles = Vec::with_capacity(12);
    let mut title_to_counter: BTreeMap<String, u8> = BTreeMap::new();
    md_collect_titles(&md_ast, &mut title_to_counter, &mut md_titles);

    let mut html_content: Vec<u8> = Vec::with_capacity(md_content_bytes_len * 8);
    writeln!(
        html_content,
        "{}
<!DOCTYPE html>\n<html>\n<head>\n<title>{}</title>",
        AUTOGENERATED_COMMENT, md_root_title
    )
    .unwrap();
    html_content.extend(html_header);
    writeln!(html_content, r#"{}<div class="article-prelude">"#, "\n").unwrap();
    writeln!(
        html_content,
        r#"{}
  <p class="publication-date">Published on {}.</p>"#,
        BACK_LINK, modified_at_formatted
    )
    .unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(
        html_content,
        r#"<div class="article-title">
  <h1>{}</h1>"#,
        md_root_title
    )
    .unwrap();
    write!(html_content, r#"<div class="tags"> "#).unwrap();
    for tag in tags {
        let id = html_slug(tag);
        write!(
            html_content,
            r#"<a href="/blog/articles-by-tag.html#{}" class="tag">{}</a> "#,
            id, tag
        )
        .unwrap();
    }
    writeln!(html_content, r#"</div>"#).unwrap();
    writeln!(html_content, r#"</div>"#).unwrap();

    md_render_toc(&mut html_content, &md_titles);

    let mut footnote_defs = Vec::with_capacity(8);
    md_render_article_content(&mut html_content, &mut footnote_defs, &md_ast, &md_titles);
    md_render_footnote_definitions(&mut html_content, &footnote_defs);

    write!(html_content, "\n{}", BACK_LINK).unwrap();
    html_content.extend(html_footer);

    let html_path = md_path.with_extension("html");
    fs::write(html_path, html_content).unwrap();
}

fn md_render_footnote_definitions(content: &mut Vec<u8>, footnote_defs: &[FootnoteDefinition]) {
    if footnote_defs.is_empty() {
        return;
    }

    writeln!(
        content,
        r#"<section class="footnotes" data-footnotes>
<ol>"#
    )
    .unwrap();

    for def in footnote_defs {
        writeln!(content, r#"<li id="fn-{}">"#, def.identifier).unwrap();

        assert_eq!(1, def.children.len());
        let child = &def.children[0];
        let children = match child {
            Node::Paragraph(p) => &p.children,
            other => panic!("unexpected footnote definition: {:#?}", other),
        };
        writeln!(content, r#"<p>"#).unwrap();
        for child in children {
            md_render_article_content(content, &mut vec![], child, &[]);
        }

        writeln!(content, r#"<a href="{}fnref-{}" class="footnote-backref" data-footnote-backref data-footnote-backref-idx="{}" aria-label="Back to reference {}">↩</a>"#,"#", &def.identifier, &def.identifier, &def.identifier).unwrap();

        writeln!(
            content,
            r#"</p>
</li>"#
        )
        .unwrap();
    }
    writeln!(
        content,
        r#"</ol>
</section>"#
    )
    .unwrap();
}

fn main() -> Result<()> {
    let md_files = [
        "a_million_ways_to_data_race_in_go.md",
        "a_small_trick_to_improve_technical_discussions_by_sharing_code.md",
        "a_subtle_data_race_in_go.md",
        "addressing_cgo_pains_one_at_a_time.md",
        "advent_of_code_2018_5_revisited.md",
        "advent_of_code_2018_5.md",
        "an_amusing_go_static_analysis_blindspot.md",
        "an_optimization_and_debugging_story_go_dtrace.md",
        "are_my_sql_files_read_at_build_time_or_run_time.md",
        "body_of_work.md",
        "build-pie-executables-with-pie.md",
        "compile_ziglang_from_source_on_alpine_2020_9.md",
        "detecting_goroutine_leaks_with_dtrace.md",
        "feed.md",
        "gnuplot_lang.md",
        "go_dtrace_see_all_network_traffic.md",
        "go_dtrace_see_registered_routes.md",
        "how_to_reproduce_and_fix_an_io_data_race_with_dtrace.md",
        "how_to_rewrite_a_cpp_codebase_successfully.md",
        "image_size_reduction.md",
        //"index.md",
        "kahns_algorithm.md",
        "lessons_learned_from_a_successful_rust_rewrite.md",
        "making_my_debug_build_run_100_times_faster.md",
        "making_my_static_blog_generator_11_times_faster.md",
        "observe_sql_queries_in_go_with_dtrace.md",
        "odin_and_musl.md",
        "perhaps_rust_needs_defer.md",
        "roll_your_own_memory_profiling.md",
        "rust_c++_interop_trick.md",
        "speed_up_your_ci.md",
        "subtle_bug_with_go_errgroup.md",
        "the_missing_cross_platform_os_api_for_timers.md",
        "the_production_bug_that_made_me_care_about_undefined_behavior.md",
        "tip_of_day_1.md",
        "tip_of_day_3.md",
        "tip_of_the_day_2.md",
        "tip_of_the_day_4.md",
        "tip_of_the_day_5.md",
        "tip_of_the_day_6.md",
        "way_too_many_ways_to_wait_for_a_child_process_with_a_timeout.md",
        "wayland_from_scratch.md",
        "what_should_your_mutexes_be_named.md",
        "write_a_video_game_from_scratch_like_1987.md",
        "x11_x64.md",
        "you_inherited_a_legacy_cpp_codebase_now_what.md",
    ];
    let html_header = fs::read("header.html").unwrap();
    let html_footer = fs::read("footer.html").unwrap();
    for md_path in md_files {
        println!("generating {}", md_path);
        let path = PathBuf::from(md_path);
        md_render_article(&html_header, &html_footer, &path);
    }
    Ok(())

    //rouille::start_server("localhost:8001", move |request| {
    //    {
    //        // The `match_assets` function tries to find a file whose name corresponds to the URL
    //        // of the request. The second parameter (`"."`) tells where the files to look for are
    //        // located.
    //        // In order to avoid potential security threats, `match_assets` will never return any
    //        // file outside of this directory even if the URL is for example `/../../foo.txt`.
    //        let response = rouille::match_assets(request, "..");
    //
    //        // If a file is found, the `match_assets` function will return a response with a 200
    //        // status code and the content of the file. If no file is found, it will instead return
    //        // an empty 404 response.
    //        // Here we check whether if a file is found, and if so we return the response.
    //        if response.is_success() {
    //            return response;
    //        }
    //    }
    //
    //    router!(request,
    //
    //
    //
    //        (GET) (/ws) => {
    //            // This is the websockets route.
    //
    //            // In order to start using websockets we call `websocket::start`.
    //            // The function returns an error if the client didn't request websockets, in which
    //            // case we return an error 400 to the client thanks to the `try_or_400!` macro.
    //            //
    //            // The function returns a response to send back as part of the `start_server`
    //            // function, and a `websocket` variable of type `Receiver<Websocket>`.
    //            // Once the response has been sent back to the client, the `Receiver` will be
    //            // filled by rouille with a `Websocket` object representing the websocket.
    //
    //            let (response, websocket) = try_or_400!(websocket::start(request, Some("echo")));
    //
    //            let watching_path = request.url();
    //            thread::spawn(move || {
    //                // This line will block until the `response` above has been returned.
    //                let ws = websocket.recv().unwrap();
    //                websocket_handling_thread(ws, watching_path);
    //            });
    //            response
    //        },
    //        _ => rouille::Response::empty_404()
    //    )
    //});
}

fn websocket_handling_thread(mut websocket: websocket::Websocket, _watching_path: String) {
    println!("new websocket");
    let (etx, erx) = std::sync::mpsc::channel();

    let mut debouncer = new_debouncer(Duration::from_millis(200), etx).unwrap();

    debouncer
        .watcher()
        .watch(Path::new("."), RecursiveMode::Recursive)
        .unwrap();

    let md_ext: OsString = "md".into();

    // Block forever, printing out events as they come in
    for res in erx {
        match res {
            Ok(events) => {
                for event in events {
                    let _stem = event
                        .path
                        .file_stem()
                        .unwrap()
                        .to_string_lossy()
                        .to_string();
                    if event.path.extension().unwrap_or_default() == md_ext {
                        println!("event: {:?}", event);

                        let md_path = PathBuf::from(&event.path);
                        let html_header = fs::read("header.html").unwrap();
                        let html_footer = fs::read("footer.html").unwrap();
                        md_render_article(&html_header, &html_footer, &md_path);

                        let file_path_str =
                            event.path.file_stem().unwrap_or_default().to_string_lossy();
                        websocket.send_text(&file_path_str).unwrap();
                        return;
                    }
                }
            }
            Err(e) => eprintln!("watch error: {:?}", e),
        }
    }
    println!("end of file watch & websocket handling");
}
