<!DOCTYPE html>
<html>
<head>
<title>You&#x27ve just inherited a legacy C++ codebase, now what?</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js"></script>
<script>
  window.onload = function() {
      hljs.registerLanguage("odin", function(e) {
      return {
          aliases: ["odin", "odinlang", "odin-lang"],
          keywords: {
              keyword: "auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",
              literal: "true false nil",
              built_in: "abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"
          },
          illegal: "</",
          contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e.QUOTE_STRING_MODE, {
                  begin: "'",
                  end: "[^\\\\]'"
              }, {
                  begin: "`",
                  end: "`"
              }]
          }, {
              className: "number",
              variants: [{
                  begin: e.C_NUMBER_RE + "[ijk]",
                  relevance: 1
              }, e.C_NUMBER_MODE]
          }]
      }
    });

    hljs.highlightAll();

    document.querySelectorAll('code').forEach((el, _i) => {
        if (0 == el.classList.length || el.classList.contains('language-sh') || el.classList.contains('language-shell') || el.classList.contains('language-bash')){
          el.classList.add('code-no-line-numbers');
          return; 
        }

        var lines = el.innerHTML.trimEnd().split('\n');
        var out = [];
        lines.forEach(function(l, i){
          out.push('<span class="line-number">' + (i+1).toString() + '</span> ' + l);
        });
        el.innerHTML = out.join('\n');
    });
  }
</script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <ul>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="#000000"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" class="mercado-match" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"></path>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z" fill="url(#paint0_linear_549_34)"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="white"/>
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="none" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path fill="#0085ff" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"></path></svg>
        </a> </li>
    </ul>
</div>
<div class="body">

<div class="article-prelude">
  <p><a href="/blog"> ‚è¥ Back to all articles</a></p>

  <p class="publication-date">Published on 2024-02-29</p>
</div>
<div class="article-title">
<h1>You've just inherited a legacy C++ codebase, now what?</h1>

  <div class="tags"> <a href="/blog/articles-by-tag.html#Cplusplus" class="tag">C++</a> <a href="/blog/articles-by-tag.html#C" class="tag">C</a> <a href="/blog/articles-by-tag.html#Legacy" class="tag">Legacy</a> <a href="/blog/articles-by-tag.html#CI" class="tag">CI</a> <a href="/blog/articles-by-tag.html#Git" class="tag">Git</a></div>
  </div>

<p>--</p>
<p><em>Discussions: <a href="https://news.ycombinator.com/item?id=39549486">Hacker News</a>, <a href="https://lobste.rs/s/lf8b9r/you_ve_just_inherited_legacy_c_codebase">Lobster.rs</a>, <a href="https://old.reddit.com/r/programming/comments/1b3143w/youve_just_inherited_a_legacy_c_codebase_now_what/">/r/programming</a>. I've got great suggestions from the comments, see the addendum at the end!</em></p>
<p>You were minding your own business, and out of nowhere something fell on your lap. Maybe you started a new job, or perhaps changed teams, or someone experienced just left.</p>
<p>And now you are responsible for a C++ codebase. It's big, complex, idiosyncratic; you stare too long at it and it breaks in various interesting ways. In a word, legacy.</p>
<p>But somehow bugs still need to be fixed, the odd feature to be added. In short, you can't just ignore it or better yet nuke it out of existence. It matters. At least to someone who's paying your salary. So, it matters to you.</p>
<p>What do you do now?</p>
<p>Well, fear not, because I have experience this many times in numerous places (the snarky folks in the back will mutter: what C++ codebase isn't exactly like I described above), and there is a way out, that's not overly painful and will make you able to actually fix the bugs, add features, and, one can dream, even rewrite it some day.</p>
<p>So join me on a recollection of what worked for me and what one should absolutely avoid.</p>
<p>And to be fair to C++, I do not hate it (per se), it just happens to be one of these languages that people abuse and invariably leads to a horrifying mess and poor C++ is just the victim here and the C++ committee will fix it in C++45, worry not, by adding <code>std::cmake</code> to the standard library and you'll see how it's absolutely a game changer, and - Ahem, ok let's go back to the topic at hand.</p>
<p>So here's an overview of the steps to take:</p>
<ol>
<li>Get it to work locally, by only doing the minimal changes required in the code and build system, ideally none. No big refactorings yet, even if itches really bad!</li>
<li>Get out the chainsaw and rip out everything that's not absolutely required to provide the features your company/open source project is advertising and selling</li>
<li>Make the project enter the 21st century by adding CI, linters, fuzzing, auto-formatting, etc</li>
<li>Finally we get to make small, incremental changes to the code, Rinse and repeat until you're not awaken every night by nightmares of Russian hackers p@wning your application after a few seconds of poking at it</li>
<li>If you can, contemplate rewrite some parts in a memory safe language</li>
</ol>
<p>The overarching goal is exerting the least amount of effort to get the project in an acceptable state in terms of security, developer experience, correctness, and performance. It's crucial to always keep that in mind. It's not about 'clean code', using the new hotness language features, etc.</p>
<p>Ok, let's dive in!</p>
<p><em>By the way, everything here applies to a pure C codebase or a mixed C and C++ codebase, so if that's you, keep reading!</em></p>
<h2>Get buy-in</h2>
<p>You thought I was going to compare the different sanitizers, compile flags, or build systems? No sir, before we do any work, we talk to people. Crazy, right?</p>
<p>Software engineering needs to be a sustainable practice, not something you burn out of after a few months or years. We cannot do this after hours, on a death march, or even, alone! We need to convince people to support this effort, have them understand what we are doing, and why. And that encompasses everyone: your boss, your coworkers, even non-technical folks. And who knows, maybe you'll go on vacation and return to see that people are continuing this effort when you're out of office.</p>
<p>All of this only means: explain in layman terms the problem with a few simple facts, the proposed solution, and a timebox. Simple right? For example (to quote South Park: <em>All characters and events in this show‚Äîeven those based on real people‚Äîare entirely <p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
able to build our app on any cheap cloud instance?</li>
<li>Hey boss, we had a cryptic bug in production affecting users, it took weeks to figure out and fix, and it turns out if was due to undefined behavior ('a problem in the code that's very hard to notice') corrupting data, and when I run this industry standard linter ('a program that finds issues in the code') on our code, it detects the issue instantly. We should run that tool every time we make a change!</li>
<li>Hey boss, the yearly audit is coming up and the last one took 7 months to pass because the auditor was not happy with what they saw. I have ideas to make that smoother.</li>
<li>Hey boss, there is a security vulnerability in the news right now about being able to decrypt encrypted data and stealing secrets, I think we might be affected, but I don't know for sure because the cryptography library we use has been vendored ('copy-pasted') by hand with some changes on top that were never reviewed by anyone. We should clean that up and setup something so that we get alerted automatically if there is a vulnerability that affects us.</li>
</ul>
<p>And here's what to avoid, again totally, super duper fictional, never-really-happened-to-me examples:</p>
<ul>
<li>We are not using the latest C++ standard, we should halt all work for 2 weeks to upgrade, also I have no idea if something will break because we have no tests</li>
<li>I am going to change a lot of things in the project on a separate branch and work on it for months. It's definitely getting merged at some point! (<em>narrator's voice:</em> it wasn't)</li>
<li>We are going to rewrite the project from scratch, it should take a few weeks tops</li>
<li>We are going to improve the codebase, but no idea when it will be done or even what we are going to do exactly</li>
</ul>
<p>Ok, let's say that now you have buy-in from everyone that matters, let's go over the process:</p>
<ul>
<li>Every change is small and incremental. The app works before and works after. Tests pass, linters are happy, nothing was bypassed to apply the change (exceptions do happen but that's what they are, exceptional)</li>
<li>If an urgent bug fix has to be made, it can be done as usual, nothing is blocked</li>
<li>Every change is a measurable improvement and can be explained and demoed to non experts</li>
<li>If the whole effort has to be suspended or stopped altogether (because of priorities shifting, budget reasons, etc), it's still a net gain overall compared to before starting it (and that gain is in some form <em>measurable</em>)</li>
</ul>
<p>In my experience, with this approach, you keep everyone happy and can do the improvements that you really need to do.</p>
<p>Alright, let's get down to business now!</p>
<h2>Write down the platforms you support</h2>
<p>This is so important and not many projects do it. Write in the README (you do have a README, right?). It's just a list of <code>&lt;architecture&gt;-&lt;operating-system&gt;</code> pair, e.g. <code>x86_64-linux</code> or <code>aarch64-darwin</code>, that your codebase officially supports. This is crucial for getting the build working on every one of them but also and we'll see later, removing cruft for platforms you do <em>not</em> support.</p>
<p>If you want to get fancy, you can even write down which version of the architecture such as ARMV6 vs ARMv7, etc.</p>
<p>That helps answer important questions such as:</p>
<ul>
<li>Can we rely on having hardware support for floats, or SIMD, or SHA256?</li>
<li>Do we even care about supporting 32 bits?</li>
<li>Are we ever running on a big-endian platform? (The answer is very likely: no, never did, never will - if you do, please email me with the details because that sounds interesting).</li>
<li>Can a <code>char</code> be 7 bits?</li>
</ul>
<p>And an important point: This list should absolutely include the developers workstations. Which leads me to my next point:</p>
<h2>Get the build working on your machine</h2>
<p>You'd be amazed at how many C++ codebase in the wild that are a core part of a successful product earning millions and they basically do not compile. Well, if all the stars are aligned they do. But that's not what I'm talking about. I'm talking about reliably, consistently building on all platforms you support. No fuss, no 'I finally got it building after 3 weeks of hair-pulling' (this brings back some memories). It just works(tm).</p>
<p>A small aparte here. I used to be really into Karate. We are talking 3, 4 training sessions a week, etc. And I distinctly remember one of my teachers telling me (picture a wise Asian sifu - hmm actually my teacher was a bald white guy... picture Steve Ballmer then):</p>
<blockquote>
<p>You do not yet master this move. Sometimes you do and sometimes you don't, so you don't. When eating with a spoon, do you miss your mouth one out of five times?</p>
</blockquote>
<p>And I carried that with me as a Software Engineer. 'The new feature works' means it works every time. Not four out of five times. And so the build is the same.</p>
<p>Experience has shown me that the best way to produce software in a fast and efficient way is to be able to build on your machine, and ideally even run it on your machine.</p>
<p>Now if your project is humongous that may be a problem, your system might not even have enough RAM to complete the build. A fallback is to rent a big server somewhere and run your builds here. It's not ideal but better than nothing.</p>
<p>Another hurdle is the code requiring some platform specific API, for example <code>io_uring</code> on Linux. What can help here is to implement a shim, or build inside a virtual machine on your workstation. Again, not ideal but better than nothing.</p>
<p>I have done all of the above in the past and that works but building directly on your machine is still the best option.</p>
<h2>Get the tests passing on your machine</h2>
<p>First, if there are no tests, I am sorry. This is going to be really difficult to do any change at all. So go write some tests before doing any change to the code, make them pass, and come back. The easiest way is to capture inputs and outputs of the program running in the real world and write end-to-end tests based on that, the more varied the better. It will ensure there are no regressions when making changes, not that the behavior was correct in the first place, but again, better than nothing.</p>
<p>So, now you have a test suite. If some tests fail, disable them for now. Make them pass, even if the whole test suite takes hours to run. We'll worry about that later.</p>
<h2>Write down in the README how to build and test the application</h2>
<p>Ideally it's one command to build and one for testing. At first it's fine if it's more involved, in that case the respective commands can be put in a <code>build.sh</code> and <code>test.sh</code> that encapsulate the madness.</p>
<p>The goal is to have a non C++ expert be able to build the code and run the tests without having to ask you anything.</p>
<p>Here some folks would recommend documenting the project layout, the architecture, etc. Since the next step is going to rip out most of it, I'd say don't waste your time now, do that at the end.</p>
<h2>Find low hanging fruits to speed up the build and tests</h2>
<p>Emphasis on 'low hanging'. No change of the build system, no heroic efforts (I keep repeating that in this article but this is so important).</p>
<p>Again, in a typical C++ project, you'd be amazed at how much work the build system is doing without having to do it at all. Try these ideas below and measure if that helps or not:</p>
<ul>
<li>Building and running tests <em>of your dependencies</em>. In a project which was using <code>unittest++</code> as a test framework, built as a CMake subproject, I discovered that the default behavior was to build the tests of the test framework, and run them, every time! That's crazy. Usually there is a CMake variable or such to opt-out of this.</li>
<li>Building and running example programs <em>of your dependencies</em>. Same thing as above, the culprit that time was <code>mbedtls</code>. Again, setting a CMake variable to opt-out of that solved it.</li>
<li>Building and running the tests of your project by default when it's being included as a subproject of another parent project. Yeah the default behavior we just laughed at in our dependencies? It turns out we're doing the same to other projects! I am no CMake expert but it seems that there is no standard way to exclude tests in a build. So I recommend adding a build variable called <code>MYPROJECT_TEST</code> unset by default and only build and run tests when it is set. Typically only developers working on the project directly will set it. Same with examples, generating documentation, etc.</li>
<li>Building all of a third-party dependency when you only need a small part of it: <code>mbedtls</code> comes to mind as a good citizen here since it exposes many compile-time flags to toggle lots of parts you might not need. Beware of the defaults, and only build what you need!</li>
<li>Wrong dependencies listed for a target leading to rebuilding the world when it does not have to: most build systems have a way to output the dependency graph from their point of view and that can really help diagnose these issues. Nothing feels worse than waiting for minutes or hours for a rebuild, when deep inside, you know it should have only rebuilt a few files.</li>
<li>Experiment with a faster linker: <code>mold</code> is one that can be dropped in and really help at no cost. However that really depends on how many libraries are being linked, whether that's a bottleneck overall, etc.</li>
<li>Experiment with a different compiler, if you can: I have seen projects where clang is twice as fast as gcc, and others where there is no difference.</li>
</ul>
<p>Once that's done, here are a few things to additionally try, although the gains are typically much smaller or sometimes negative:</p>
<ul>
<li>LTO: off/on/thin</li>
<li>Split debug information</li>
<li>Make vs Ninja</li>
<li>The type of file system in use, and tweaking its settings</li>
</ul>
<p>Once the iteration cycle feels ok, the code gets to go under the microscope. If the build takes ages, it's not realistic to want to modify the code.</p>
<h2>Remove all unnecessary code</h2>
<p>Dad, I see dead lines of code.</p>
<p>(Get the reference? Well, ok then.)</p>
<p>I have seen 30%, sometimes more, of a codebase, being completely dead code. That's lines of code you pay for every time you compile, you want to make a refactoring, etc. So let's rip them out.</p>
<p>Here are some ways to go about it:</p>
<ul>
<li>The compiler has a bunch of <code>-Wunused-xxx</code> warnings, e.g. <code>-Wunused-function</code>. They catch some stuff, but not everything. Every single instance of these warnings should be addressed. Usually it's as easy as deleting the code, rebuilding and re-running the tests, done. In rare cases it's a symptom of a bug where the wrong function was called. So I'd be somewhat reluctant to fully automate this step. But if you're confident in your test suite, go for it.</li>
<li>Linters can find unused functions or class fields, e.g. <code>cppcheck</code>. In my experience there are quite a lot of false positives especially regarding virtual functions in the case of inheritance, but the upside is that these tools absolutely find unused things that the compilers did not notice. So, a good excuse for adding a linter to your arsenal, if not to the CI (more on that later).</li>
<li>I have seen more exotic techniques were the linker is instructed to put each function in its own section and print every time a section is removed because it's detected to be unused at link time, but that results in so much noise e.g. about standard library functions being unused, that I have not found that really practical. Others inspect the generated assembly and compare which functions are present there with the source code, but that does not work for virtual functions. So, maybe worth a shot, depending on your case?</li>
<li>Remember the list of supported platforms? Yeah, time to put it to use to kill all the code for unsupported platforms. Code trying to support ancient versions of Solaris on a project that exclusively ran on FreeBSD?  Out of the window it goes. Code trying to provide its own random number generator because maybe the platform we run on does not have one (of course it turned out that was never the case)? To the bin. Hundred of lines of code in case POSIX 2001 is not supported, when we only run on modern Linux and macOS? Nuke it. Checking if the host CPU is big-endian and swapping bytes if it is? Ciao (when was the last time you shipped code for a big-endian CPU? And if yes, how are you finding IBM?). That code introduced years ago for a hypothetical feature that never came? Hasta la vista.</li>
</ul>
<p>And the bonus for doing all of this, is not only that you sped up the build time by a factor of 5 with zero downside, is that, if your boss is a tiny bit technical, they'll love seeing PRs deleting thousands of lines of code. And your coworkers as well.</p>
<h2>Linters</h2>
<p>Don't go overboard with linter rules, add a few basic ones, incorporate them in the development life cycle, incrementally tweak the rules and fix the issues that pop up, and move on. Don't try to enable all the rules, it's just a rabbit hole of diminishing returns. I have used <code>clang-tidy</code> and <code>cppcheck</code> in the past, they can be helpful, but also incredibly slow and noisy, so be warned. Having no linter is not an option though. The first time you run the linter, it'll catch so many real issues that you'll wonder why the compiler is not detecting anything even with all the warnings on.</p>
<h2>Code formatting</h2>
<p>Wait for the appropriate moment where no branches are active (otherwise people will have horrendous merge conflicts), pick a code style at random, do a one time formatting of the entire codebase (no exceptions), typically with <code>clang-format</code>, commit the configuration, done. Don't waste any bit of saliva arguing about the actual code formatting. It only exists to make diffs smaller and avoid arguments, so do not argue about it!</p>
<h2>Sanitizers</h2>
<p>Same as linters, it can be a rabbit hole, unfortunately it's absolutely required to spot real, production affecting, hard to detect, bugs and to be able to fix them. <code>-fsanitize=address,undefined</code> is a good baseline. They usually do not have false positives so if something gets detected, go fix it. Run the tests with it so that issues get detected there as well. I even heard of people running the production code with some sanitizers enabled, so if your performance budget can allow it, it could be a good idea.</p>
<p>If the compiler you (have to) use to ship the production code does not support sanitizers, you can at least use clang or such when developing and running tests. That's when the work you did on the build system comes in handy, it should be relatively easy to use different compilers.</p>
<p>One thing is for sure: even in the best codebase in the world, with the best coding practices and developers, the second you enable the sanitizers, you absolutely will uncover horrifying bugs and memory leaks that went undetected for years. So do it. Be warned that fixing these can require a lot of work and refactorings.
Each sanitizer also has options so it could be useful to inspect them if your project is a special snowflake.</p>
<p>One last thing: ideally, all third-party dependencies should also be compiled with the sanitizers enabled when running tests, to spot <a href="https://github.com/rxi/microui/pull/67">issues</a> in them as well.</p>
<h2>Add a CI pipeline</h2>
<p>As Bryan Cantrill once said (quoting from memory), 'I am convinced most firmware just comes out of the home directory of a developer's laptop'. Setting up a CI is quick, free, and automates all the good things we have set up so far (linters, code formatting, tests, etc). And that way we can produce in a pristine environment the production binaries, on every change. If you're not doing this already as a developer, I don't think you really have entered the 21st century yet.</p>
<p>Cherry on the cake: most CI systems allow for running the steps on a matrix of different platforms! So you can demonstrably check that the list of supported platforms is not just theory, it is real.</p>
<p>Typically the pipeline just looks like <code>make all test lint fmt</code>  so it's not rocket science. Just make sure that issues that get reported by the tools (linters, sanitizers, etc) actually fail the pipeline, otherwise no one will notice and fix them.</p>
<h2>Incremental code improvements</h2>
<p>Well that's known territory so I won't say much here. Just that lots of code can often be dramatically simplified.</p>
<p>I remember iteratively simplifying a complicated class that manually allocated and (sometimes) deallocated memory, was meant to handle generic things, and so on. All the class did, as it turned out, was allocate a pointer, later check whether the pointer was null or not, and...that's it. Yeah that's a boolean in my book. True/false, nothing more to it.</p>
<p>I feel that's the step that's the hardest to timebox because each round of simplification opens new avenues to simplify further. Use your best judgment here and stay on the conservative side. Focus on tangible goals such as security, correctness and performance, and stray away from subjective criteria such as 'clean code'.</p>
<p>In my experience, upgrading the C++ standard in use in the project can at times help with code simplifications, for example to replace code that manually increments iterators by a <code>for (auto x : items)</code> loop, but remember it's just a means to an end, not an end in itself. If all you need is <code>std::clamp</code>, just write it yourself.</p>
<h2>Rewrite in a memory safe language?</h2>
<p>I am doing this right now at work, and that deserves an article of its own. Lots of gotchas there as well. Only do this with a compelling reason.</p>
<h2>Conclusion</h2>
<p>Well, there you have it. A tangible, step-by-step plan to get out of the finicky situation that's a complex legacy C++ codebase. I have just finished going through that at work on a project, and it's become much more bearable to work on it now. I have seen coworkers, who previously would not have come within a 10 mile radius of the codebase, now make meaningful contributions. So it feels great.</p>
<p>There are important topics that I wanted to mention but in the end did not, such as the absolute necessity of being able to run the code in a debugger locally, fuzzing, dependency scanning for vulnerabilities, etc. Maybe for the next article!</p>
<p>If you go through this on a project, and you found this article helpful, shoot me an email! It's nice to know that it helped someone.</p>
<h2>Addendum: Dependency management</h2>
<p><em>This section is very subjective, it's just my strong, biased opinion.</em></p>
<p>There's a hotly debated topic that I have so far carefully avoided and that's dependency management. So in short, in C++ there's none. Most people resort to using the system package manager, it's easy to notice because their README looks like this:</p>
<pre><code class="language-markdown">On Ubuntu 20.04: `sudo apt install [100 lines of packages]`

On macOS: `brew install [100 lines of packages named slightly differently]`

Any other: well you're out of luck buddy. I guess you'll have to pick a mainstream OS and reinstall ¬Ø\_(„ÉÑ)_/¬Ø
</code></pre>
<p>Etc. I have done it myself. And I think this is a terrible idea. Here's why:</p>
<ul>
<li>The installation instructions, as we've seen above, are OS and distribution dependent. Worse, they're dependent on the version of the distribution. I remember a project that took months to move from Ubuntu 20.04 to Ubuntu 22.04, because they ship different versions of the packages (if they ship the same packages at all), and so upgrading the distribution also means upgrading the 100 dependencies of your project at the same time. Obviously that's a very bad idea. You want to upgrade one dependency at a time, ideally.</li>
<li>There's always a third-party dependency that has no package and you have to build it from source anyway.</li>
<li>The packages are never built with the flags you want. Fedora and Ubuntu have debated for years whether to build packaged with the frame pointer enabled (they finally do since very recently). Remember the section about sanitizers? How are you going to get dependencies with sanitizer enabled? It's not going to happen. But there are way more examples: LTO, <code>-march</code>, debug information, etc. Or they were built with a different C++ compiler version from the one you are using and they broke the C++ ABI between the two.</li>
<li>You want to easily see the source of the dependency when auditing, developing, debugging, etc, <em>for the version you are currently using</em>.</li>
<li>You want to be able to patch a dependency easily if you encounter a bug, and rebuild easily without having to change the build system extensively</li>
<li>You never get the exact same version of a package across systems, e.g. when developer Alice is on macOS, Bob on Ubuntu and the production system on FreeBSD. So you have weird discrepancies you cannot reproduce and that's annoying.</li>
<li>Corollary of the point above: You don't know exactly which version(s) you are using across systems and it's hard to produce a Bill of Material (BOM) in an automated fashion, which is required (or going to be required very soon? Anyway it's a good idea to have it) in some fields.</li>
<li>The packages sometimes do not have the version of the library you need (static or dynamic)</li>
</ul>
<p>So you're thinking, I know, I will use those fancy new package managers for C++, Conan, vcpkg and the like! Well, not so fast:</p>
<ul>
<li>They require external dependencies so your CI becomes more complex and slower (e.g. figuring out which exact version of Python they require, which surely will be different from the version of Python your project requires)</li>
<li>They do not have all versions of a package. Example: <a href="https://conan.io/center/recipes/mbedtls">Conan and mbedtls</a>, it jumps from version <code>2.16.12</code> to <code>2.23.0</code>. What happened to the versions in between? Are they flawed and should not be used? Who knows! Security vulnerabilities are not listed anyways for the versions available! Of course I had a project in the past where I had to use version <code>2.17</code>...</li>
<li>They might not support some operating systems or architectures you care about (FreeBSD, ARM, etc)</li>
</ul>
<p>I mean, if you have a situation where they work for you, that's great, it's definitely an improvement over using system packages in my mind. It's just that I never encountered (so far) a project where I could make use of them - there was always some blocker.</p>
<p>So what do I recommend? Well, the good old git submodules and compiling from source approach. It's cumbersome, yes, but also:</p>
<ul>
<li>It's dead simple</li>
<li>It's better than manually vendoring because git has the history and the diff functionalities</li>
<li>You know exactly, down to the commit, which version of the dependency is in use</li>
<li>Upgrading the version of a single dependency is trivial, just run <code>git checkout</code></li>
<li>It works on every platform</li>
<li>You get to choose exactly the compilation flags, compiler, etc to build all the dependencies. And you can even tailor it per dependency!</li>
<li>Developers know it already even if they have no C++ experience</li>
<li>Fetching the dependencies is secure and the remote source is in git. No one is changing that sneakily.</li>
<li>It works recursively (i.e.: transitively, for the dependencies of your dependencies)</li>
</ul>
<p>Compiling each dependency in each submodule can be as simple as <code>add_subdirectory</code> with CMake, or <code>git submodule foreach make</code> by hand.</p>
<p>If submodules are really not an option, an alternative is to still compile from source but do it by hand, with one script, that fetches each dependency and builds it. Example in the wild: Neovim.</p>
<p>Of course, if your dependency graph visualized in Graphviz looks like a Rorschach test and has to build thousands of dependencies, it is not easily doable, but it might be still possible, using a build system like Buck2, which does hybrid local-remote builds, and reuses build artifacts between builds from different users.</p>
<p>If you look at the landscape of package managers for compiled languages (Go, Rust, etc), all of them that I know of compile from source. It's the same approach, minus git, plus the automation.</p>
<h2>Addendum: suggestions from readers</h2>
<p>I've gathered here some great ideas and feedback from readers (sometimes it's the almagamation of multiple comments from different people, and I am paraphrasing from memory so sorry if it's not completely accurate):</p>
<ul>
<li><em>You should put more emphasis on tests (expanding the test suite, the code coverage, etc) - but also: a test suite in C++ is only worth anything when running it under sanitizers, otherwise you get lured into a false sense of safety.</em> 100% agree. Modifying complex foreign code without tests is just not possible in my opinion. And yes, sanitizers will catch so many issues in the tests that you should even consider running your tests suite multiple time in CI with different sanitizers enabled.</li>
<li><em>vcpkg is a good dependency manager for C++ that solves all of your woes.</em> I've never got the chance to use it so I'll add it to my toolbox to experiment with. If it matches the requirements I listed, as well as enabling cross-compilation, then yes it's absolutely a win over git submodules.</li>
<li><em>Nix can serve as a good dependency manager for C++.</em> I must admit that I was beaten into submission by Nix's complexity and slowness. Maybe in a few years when it has matured?</li>
<li><em>You should not invest so much time in refactoring a legacy codebase if all you are going to do is one bug fix a year.</em> Somewhat agree, but it really is a judgement call. In my experience it's never one and only one bug fix, whatever management says. And all the good things such as removing dead code, sanitizers etc will be valuable even for the odd bug fix and also lead to noticing more bugs and fixing them. As one replier put it: <em>If you are going to own a codebase, then own it for real.</em></li>
<li><em>It's very risky to remove code, in general you never know for sure if it's being used or not, and if someone relies on this exact behavior in the wild.</em> That's true, that's why I advocate for removing code that is never called using static analysis tools, so that you know <em>for sure</em>. But yes, when in doubt, don't. My pet peeve here are virtual methods that are very resistant to static analysis (since the whole point is to pick which exact method to call at runtime), these usually cannot be as easily removed. Also, talk to your sales people, your product managers, heck even your users if you can. Most of the time, if you ask them whether a given feature or platform is in use or not, you'll get a swift yes or no reply, and you'll know how to proceed. We engineers sometimes forget that a 15 minute talk with people can simplify  so much technical work.</li>
<li><em>Stick all your code in a LLM and start asking it questions</em>: As a anti LLM person, I must admit that this idea never crossed my mind. However I think it might be worth a shot, if you can do that in a legally safe way, ideally fully locally, and take everything with a grain a salt. I'm genuinely curious to see what answers it comes up with!</li>
<li><em>There are tools that analyze the code and produce diagrams, class relationships etc to get an overview of the code</em>: I never used these tools but that's a good idea and I will definitely try one in the future</li>
<li><em>Step 0 should be to add the code in a source control system if that's not the case already</em>: For sure. I was lucky enough to never encounter that, but heck yeah, even the worst source control system is better than no source control system at all. And I say this after having had to use Visual Source Safe, the one where modifying a file means acquiring an exclusive lock on it, that you then have to release manually.</li>
<li><em>Setting up a CI should be step 1</em>: Fair point, I can totally see this perspective. I am quicker locally, but fair.</li>
<li><em>Don't be a code beauty queen, just do the fixes you need</em>: Amen.</li>
<li><em>If you can drop a platform that's barely used to reduce the combinatorial complexity, and that enables you to do major simplifications, go for it</em>: Absolutely. Talk to your sales people and stakeholders and try to convince them. In my case it was ancient FreeBSD versions long out of support, I think we used the security angle to convince everyone to drop them.</li>
<li><em>Reproducible builds</em>: This topic came up and was quite the debate. Honestly I don't think achieving a fully reproducible build in a typical C++ codebase is realistic. The compiler and standard library version alone are a problem since they usually are not considered in the build inputs. Achieving a reliable build though is definitely realistic. Docker came up on that topic. Now I have used Docker in anger since 2013 and I don't think it brings as much value as people generally think it does. But again - if all you can do is get the code building inside Docker, it's better than nothing at all.</li>
<li><em>Git can be instructed to ignore one commit e.g. the one formatting the whole codebase so that git blame still works and the history still makes sense</em>: Fantastic advice that I did not know before, so thanks! I'll definitely try that.</li>
<li><em>Use the VCS statistics from the history to identify which parts of the codebase have the most churn and which ones get usually changed together</em>: I never tried that, it's an interesting idea, but I also see lots of caveats. Probably worth a try?</li>
<li><em>This article applies not only to C++ but also to legacy codebases in other languages</em>: Thank you! I have the most experience in C++, so that was my point of view, but I'm glad to hear that. Just skip the C++-specific bits like sanitizers.</li>
<li><em>The book 'Working effectively with Legacy Code' has good advice</em>: I don't think I have ever read it from start to finish, so thanks for the recommendation. I seem to recall I skimmed it and found it very object-oriented specific with lots of OOP design patterns, and that was not helpful to me at the time, but my memory is fuzzy.</li>
<li><em>Generally, touch as little as possible, focus on what adds value (actual value, like, sales dollars).</em>: I agree generally (see the point: don't be beauty queen), however in a typical big C++ codebase, the moment you start to examine it under the lens of security, you will find lots and lots a security vulnerabilities that need fixing. And that does not translate in a financial gain - it's reducing risk. And I find that extremely valuable. Although, some fields are more sensitive than others.</li>
</ul>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
 In my experience it's never one and only one bug fix, whatever management says. And all the good things such as removing dead code, sanitizers etc will be valuable even for the odd bug fix and also lead to noticing more bugs and fixing them. As one replier put it: <em>If you are going to own a codebase, then own it for real.</em></li>
<li><em>It's very risky to remove code, in general you never know for sure if it's being used or not, and if someone relies on this exact behavior in the wild.</em> That's true, that's why I advocate for removing code that is never called using static analysis tools, so that you know <em>for sure</em>. But yes, when in doubt, don't. My pet peeve here are virtual methods that are very resistant to static analysis (since the whole point is to pick which exact method to call at runtime), these usually cannot be as easily removed. Also, talk to your sales people, your product managers, heck even your users if you can. Most of the time, if you ask them whether a given feature or platform is in use or not, you'll get a swift yes or no reply, and you'll know how to proceed. We engineers sometimes forget that a 15 minute talk with people can simplify  so much technical work.</li>
<li><em>Stick all your code in a LLM and start asking it questions</em>: As a anti LLM person, I must admit that this idea never crossed my mind. However I think it might be worth a shot, if you can do that in a legally safe way, ideally fully locally, and take everything with a grain a salt. I'm genuinely curious to see what answers it comes up with!</li>
<li><em>There are tools that analyze the code and produce diagrams, class relationships etc to get an overview of the code</em>: I never used these tools but that's a good idea and I will definitely try one in the future</li>
<li><em>Step 0 should be to add the code in a source control system if that's not the case already</em>: For sure. I was lucky enough to never encounter that, but heck yeah, even the worst source control system is better than no source control system at all. And I say this after having had to use Visual Source Safe, the one where modifying a file means acquiring an exclusive lock on it, that you then have to release manually.</li>
<li><em>Setting up a CI should be step 1</em>: Fair point, I can totally see this perspective. I am quicker locally, but fair.</li>
<li><em>Don't be a code beauty queen, just do the fixes you need</em>: Amen.</li>
<li><em>If you can drop a platform that's barely used to reduce the combinatorial complexity, and that enables you to do major simplifications, go for it</em>: Absolutely. Talk to your sales people and stakeholders and try to convince them. In my case it was ancient FreeBSD versions long out of support, I think we used the security angle to convince everyone to drop them.</li>
<li><em>Reproducible builds</em>: This topic came up and was quite the debate. Honestly I don't think achieving a fully reproducible build in a typical C++ codebase is realistic. The compiler and standard library version alone are a problem since they usually are not considered in the build inputs. Achieving a reliable build though is definitely realistic. Docker came up on that topic. Now I have used Docker in anger since 2013 and I don't think it brings as much value as people generally think it does. But again - if all you can do is get the code building inside Docker, it's better than nothing at all.</li>
<li><em>Git can be instructed to ignore one commit e.g. the one formatting the whole codebase so that git blame still works and the history still makes sense</em>: Fantastic advice that I did not know before, so thanks! I'll definitely try that.</li>
<li><em>Use the VCS statistics from the history to identify which parts of the codebase have the most churn and which ones get usually changed together</em>: I never tried that, it's an interesting idea, but I also see lots of caveats. Probably worth a try?</li>
<li><em>This article applies not only to C++ but also to legacy codebases in other languages</em>: Thank you! I have the most experience in C++, so that was my point of view, but I'm glad to hear that. Just skip the C++-specific bits like sanitizers.</li>
<li><em>The book 'Working effectively with Legacy Code' has good advice</em>: I don't think I have ever read it from start to finish, so thanks for the recommendation. I seem to recall I skimmed it and found it very object-oriented specific with lots of OOP design patterns, and that was not helpful to me at the time, but my memory is fuzzy.</li>
<li><em>Generally, touch as little as possible, focus on what adds value (actual value, like, sales dollars).</em>: I agree generally (see the point: don't be beauty queen), however in a typical big C++ codebase, the moment you start to examine it under the lens of security, you will find lots and lots a security vulnerabilities that need fixing. And that does not translate in a financial gain - it's reducing risk. And I find that extremely valuable. Although, some fields are more sensitive than others.</li>
</ul>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
