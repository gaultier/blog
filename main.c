#include "./submodules/cstd/lib.c"

// Plan:
// - Reader header & footer
// - Get all markdown files from git along with their creation/modification date
// - For each markdown file:
//   + Read metadata at the beginning of the file
//   + Parse metadata
//   + Convert markdown to HTML
//   + Parse titles from HTML
//   + Generate TOC
//   + Extract plain text from HTML
//   + Serialize articles including titles and plain text to client-side JS for
//   search
//   + Decorate titles with HTML id for links
//   + Generate final HTML with header, TOC, decorated content, and footer.
// - Generate tags page
// - Generate home page
// - Generate RSS feed

#define FEED_UUID                                                              \
  ((PgUuid){                                                                   \
      .value = {0x9c, 0x06, 0x5c, 0x53, 0x31, 0xbc, 0x40, 0x49, 0xa7, 0x95,    \
                0x93, 0x68, 0x02, 0xa6, 0xb1, 0xdf},                           \
      .version = 5,                                                            \
  })
#define BASE_URL "https://gaultier.github.io/blog"
#define METADATA_DELIMITER "---"
#define BACK_LINK "<p><a href=\"/blog\"> ‚è¥ Back to all articles</a></p>\n"
#define FNV_SEED ((u32)0x811c9dc5)
#define HTML_AUTOGENERATED_COMMENT                                             \
  "<!--\nThis file has been auto-generated by main.c/main.bin from a "         \
  "markdown "                                                                  \
  "file of the same name.\nDo not edit it by hand.\n-->\n"

typedef struct Title Title;
struct Title {
  PgString title;
  PgString slug;
  u8 level;
  Title *parent, *first_child, *next_sibling;
  u32 pos_start, pos_end;

  // If there are duplicate titles on the page (at different levels),
  // the counter distinguishes them.
  u32 counter;
};
PG_DYN_DECL(Title);
PG_SLICE_DECL(Title);

typedef struct {
  PgString html_file_name;
  PgString title;
  PG_SLICE(PgString) tags;
  PgString creation_date, modification_date;
} Article;
PG_DYN_DECL(Article);
PG_SLICE_DECL(Article);

typedef struct {
  PgString creation_date, modification_date, path_rel;
} GitStat;
PG_SLICE_DECL(GitStat);
PG_DYN_DECL(GitStat);

typedef struct {
  PgString html_file_name;
  PgString title;
  PG_SLICE(Title) titles;
  Pgu32Dyn title_text_offsets;
  PG_DYN(u8) text;
} SearchDocument;
PG_DYN_DECL(SearchDocument);

typedef struct {
  PG_DYN(SearchDocument) documents;
} SearchIndex;

static void search_index_serialize_to_file(SearchIndex search_index,
                                           PgString file_name,
                                           PgAllocator *allocator) {
  PG_ASSERT(!PG_SLICE_IS_EMPTY(search_index.documents));

  PG_RESULT(PgFileDescriptor, PgError)
  res_file =
      pg_file_open(file_name, PG_FILE_ACCESS_WRITE, 0600, true, allocator);
  PgFileDescriptor file = PG_UNWRAP(res_file);

  PG_DYN(u8) sb = pg_string_builder_make(50 * PG_MiB, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("const raw_index={documents:["), allocator);

  for (u64 i = 0; i < search_index.documents.len; i++) {
    SearchDocument doc = PG_SLICE_AT(search_index.documents, i);
    PG_DYN_APPEND_SLICE(&sb, PG_S("{\n"), allocator);

    // HTML file name.
    {
      PG_DYN_APPEND_SLICE(&sb, PG_S("html_file_name:\""), allocator);
      pg_string_builder_append_js_string_escaped(&sb, doc.html_file_name,
                                                 allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("\",\n"), allocator);
    }

    // Document title.
    {
      PG_DYN_APPEND_SLICE(&sb, PG_S("title:\""), allocator);
      pg_string_builder_append_js_string_escaped(&sb, doc.title, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("\",\n"), allocator);
    }

    // Text.
    {
      PG_DYN_APPEND_SLICE(&sb, PG_S("text:\""), allocator);
      pg_string_builder_append_js_string_escaped(
          &sb, PG_DYN_TO_SLICE(PgString, doc.text), allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("\",\n"), allocator);
    }

    // Titles.
    {
      PG_DYN_APPEND_SLICE(&sb, PG_S("titles:[\n"), allocator);

      for (u64 j = 1; j < doc.titles.len; j++) {
        Title title = PG_SLICE_AT(doc.titles, j);
        PG_DYN_APPEND_SLICE(&sb, PG_S("{\n"), allocator);

        PG_DYN_APPEND_SLICE(&sb, PG_S("title:\""), allocator);
        pg_string_builder_append_js_string_escaped(&sb, title.title, allocator);
        PG_DYN_APPEND_SLICE(&sb, PG_S("\",\n"), allocator);

        if (title.counter) {
          PG_DYN_APPEND_SLICE(&sb, PG_S("counter:"), allocator);
          pg_string_builder_append_u64(&sb, title.counter, allocator);
          PG_DYN_APPEND_SLICE(&sb, PG_S(",\n"), allocator);
        }

        PG_DYN_APPEND_SLICE(&sb, PG_S("slug:\""), allocator);
        pg_string_builder_append_js_string_escaped(&sb, title.slug, allocator);
        PG_DYN_APPEND_SLICE(&sb, PG_S("\",\n"), allocator);

        PG_DYN_APPEND_SLICE(&sb, PG_S("offset:"), allocator);
        pg_string_builder_append_u64(
            &sb, PG_SLICE_AT(doc.title_text_offsets, j - 1), allocator);
        PG_DYN_APPEND_SLICE(&sb, PG_S(",\n"), allocator);

        PG_DYN_APPEND_SLICE(&sb, PG_S("},\n"), allocator);
      }
      PG_DYN_APPEND_SLICE(&sb, PG_S("],\n"), allocator);
    }

    PG_DYN_APPEND_SLICE(&sb, PG_S("},\n"), allocator);
  }
  PG_DYN_APPEND_SLICE(&sb, PG_S("],\n"), allocator);

  PG_DYN_APPEND_SLICE(&sb, PG_S("};\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("export default { raw_index };"), allocator);

  PG_ASSERT(0 == pg_file_write_full_with_descriptor(
                     file, PG_DYN_TO_SLICE(PgString, sb)));

  PG_ASSERT(0 == pg_file_close(file));
}

[[nodiscard]]
static int article_cmp_by_creation_date_asc(const void *a, const void *b) {
  const Article *article_a = a;
  const Article *article_b = b;

  return pg_string_cmp(article_a->creation_date, article_b->creation_date);
}

[[nodiscard]]
static int article_cmp_by_creation_date_desc(const void *a, const void *b) {
  const Article *article_a = a;
  const Article *article_b = b;

  return pg_string_cmp(article_b->creation_date, article_a->creation_date);
}

[[nodiscard]] static i64 git_stats_find_by_path_rel(PG_SLICE(GitStat) git_stats,
                                                    PgString path_rel) {
  for (u64 i = 0; i < git_stats.len; i++) {
    GitStat elem = PG_SLICE_AT(git_stats, i);
    if (pg_string_eq(elem.path_rel, path_rel)) {
      return (i64)i;
    }
  }

  return -1;
}

[[nodiscard]]
static PG_SLICE(GitStat) git_get_articles_stats(PgAllocator *allocator) {
  PG_DYN(PgString) args = {0};
  PG_DYN_ENSURE_CAP(&args, 16, allocator);
  PG_DYN_PUSH(&args, PG_S("log"), allocator);
  // Print the date in ISO format.
  PG_DYN_PUSH(&args, PG_S("--format='%aI'"), allocator);
  // Ignore merge commits since they do not carry useful information.
  PG_DYN_PUSH(&args, PG_S("--no-merges"), allocator);
  // Only interested in creation, modification, renaming, deletion.
  PG_DYN_PUSH(&args, PG_S("--diff-filter=AMRD"), allocator);
  // Show which modification took place:
  // A: added, M: modified, RXXX: renamed (with percentage score), etc.
  PG_DYN_PUSH(&args, PG_S("--name-status"), allocator);
  PG_DYN_PUSH(&args, PG_S("--reverse"), allocator);
  PG_DYN_PUSH(&args, PG_S("*.md"), allocator);

  PgProcessSpawnOptions options = {
      .stdout_capture = PG_CHILD_PROCESS_STD_IO_PIPE,
      .stderr_capture = PG_CHILD_PROCESS_STD_IO_PIPE,
  };
  PG_RESULT(PgProcess, PgError)
  res_spawn =
      pg_process_spawn(PG_S("git"), PG_DYN_TO_SLICE(PG_SLICE(PgString), args),
                       options, allocator);
  PgProcess process = PG_UNWRAP(res_spawn);

  PG_RESULT(PgProcessStatus, PgError)
  res_wait = pg_process_wait(process, 256 * PG_KiB, 0, allocator);

  PgProcessStatus status = PG_UNWRAP(res_wait);
  PG_ASSERT(0 == status.exit_status);
  PG_ASSERT(0 == status.signal);
  PG_ASSERT(status.exited);
  PG_ASSERT(!status.signaled);
  PG_ASSERT(!status.core_dumped);
  PG_ASSERT(!status.stopped);

  PG_ASSERT(!pg_string_is_empty(status.stdout_captured));
  PG_ASSERT(pg_string_is_empty(status.stderr_captured));

  PG_DYN(GitStat) stats = {0};
  PG_DYN_ENSURE_CAP(&stats, 256, allocator);

  // Sample git output:
  // 2024-10-31T16:09:02+01:00
  //
  // M       lessons_learned_from_a_successful_rust_rewrite.md
  // A       tip_of_day_3.md
  // 2025-02-18T08:07:55+01:00
  //
  // R100    sha.md  making_my_debug_build_run_100_times_faster.md

  // For each commit.
  PgString remaining = status.stdout_captured;
  for (;;) {
    PgString date = {0};
    {
      PgStringCut cut = pg_string_cut_rune(remaining, '\n');
      if (!cut.has_value) { // End.
        break;
      }
      remaining = cut.right;

      PG_ASSERT(pg_string_starts_with(cut.left, PG_S("'20")));
      date = cut.left;
      date = pg_string_trim(date, '\'');
      date = pg_string_trim(date, '\n');
    }
    // Empty line.
    {
      PgStringCut cut = pg_string_cut_rune(remaining, '\n');
      PG_ASSERT(cut.has_value);
      remaining = cut.right;

      PG_ASSERT(pg_string_is_empty(cut.left));
    }

    // Files.
    for (;;) {
      // Start of a new commit?
      if (pg_string_starts_with(remaining, PG_S("'20"))) {
        break;
      }

      PgStringCut cut = pg_string_cut_rune(remaining, '\n');
      if (!cut.has_value) {
        break;
      }
      PgString line = cut.left;
      remaining = cut.right;

      PG_ASSERT(!pg_string_is_empty(line));
      u8 action = PG_SLICE_AT(line, 0);
      PG_ASSERT(action == 'A' || action == 'M' || action == 'R' ||
                action == 'D');

      PgString path_old = {0}, path_new = {0};
      {
        // Skip the 'action' part.
        cut = pg_string_cut_rune(line, '\t');
        PG_ASSERT(cut.has_value);
        line = cut.right;

        cut = pg_string_cut_rune(line, '\t');
        path_old = cut.has_value ? cut.left : line;
        path_new = cut.has_value ? cut.right : path_old;
        PG_ASSERT(!pg_string_is_empty(path_old));
        PG_ASSERT(!pg_string_is_empty(path_new));
      }

      if ('D' == action) {
        i64 idx = git_stats_find_by_path_rel(
            PG_DYN_TO_SLICE(PG_SLICE(GitStat), stats), path_old);
        PG_ASSERT(idx >= 0);
        PG_SLICE_SWAP_REMOVE(&stats, idx);
        continue;
      }

      if ('R' == action) {
        i64 idx = git_stats_find_by_path_rel(
            PG_DYN_TO_SLICE(PG_SLICE(GitStat), stats), path_old);
        PG_ASSERT(idx >= 0);
        PG_SLICE_SWAP_REMOVE(&stats, idx);

        // Still need to insert the new entry below.
      }

      // TODO: upsert entry.
      i64 idx = git_stats_find_by_path_rel(
          PG_DYN_TO_SLICE(PG_SLICE(GitStat), stats), path_new);
      if (-1 == idx) {
        GitStat new_entry = {
            .creation_date = date,
            .modification_date = date,
            .path_rel = path_new,
        };
        *PG_DYN_PUSH_WITHIN_CAPACITY(&stats) = new_entry;
      } else {
        GitStat *entry = PG_SLICE_AT_PTR(&stats, idx);
        PG_ASSERT(!pg_string_is_empty(entry->creation_date));
        PG_ASSERT(!pg_string_is_empty(entry->modification_date));
        PG_ASSERT(PG_CMP_GREATER != pg_string_cmp(entry->creation_date,
                                                  entry->modification_date));
        // Keep updating the modification date, when we reach the end of the
        // commit log, it has the right value.
        entry->modification_date = date;
        PG_ASSERT(PG_CMP_GREATER != pg_string_cmp(entry->creation_date,
                                                  entry->modification_date));
      }
    }
  }

  return PG_DYN_TO_SLICE(PG_SLICE(GitStat), stats);
}

[[nodiscard]]
static PgString datetime_to_date(PgString datetime) {
  PgStringCut cut = pg_string_cut_rune(datetime, 'T');
  return cut.has_value ? cut.left : datetime;
}

[[nodiscard]] static PgString markdown_to_html(PgFileDescriptor markdown_file,
                                               u64 metadata_offset,
                                               PgAllocator *allocator) {
  PG_DYN(PgString) args = {0};
  PG_DYN_ENSURE_CAP(&args, 16, allocator);
  PG_DYN_PUSH(&args, PG_S("--validate-utf8"), allocator);
  PG_DYN_PUSH(&args, PG_S("-e"), allocator);
  PG_DYN_PUSH(&args, PG_S("table"), allocator);
  PG_DYN_PUSH(&args, PG_S("-e"), allocator);
  PG_DYN_PUSH(&args, PG_S("strikethrough"), allocator);
  PG_DYN_PUSH(&args, PG_S("-e"), allocator);
  PG_DYN_PUSH(&args, PG_S("footnotes"), allocator);
  PG_DYN_PUSH(&args, PG_S("--unsafe"), allocator);
  PG_DYN_PUSH(&args, PG_S("-t"), allocator);
  PG_DYN_PUSH(&args, PG_S("html"), allocator);

  PgProcessSpawnOptions options = {
      .stdin_capture = PG_CHILD_PROCESS_STD_IO_PIPE,
      .stdout_capture = PG_CHILD_PROCESS_STD_IO_PIPE,
      .stderr_capture = PG_CHILD_PROCESS_STD_IO_PIPE,
  };
  PG_RESULT(PgProcess, PgError)
  res_spawn = pg_process_spawn(
      PG_S("./submodules/cmark-gfm/build/src/cmark-gfm"),
      PG_DYN_TO_SLICE(PG_SLICE(PgString), args), options, allocator);
  PgProcess process = PG_UNWRAP(res_spawn);

  PG_RESULT(u64, PgError) res_markdown_file_size = pg_file_size(markdown_file);
  PG_ASSERT(0 == pg_file_copy_with_descriptors_until_eof(
                     process.stdin_pipe, markdown_file, metadata_offset));
  PG_ASSERT(0 == pg_file_close(process.stdin_pipe));
  process.stdin_pipe.fd = 0;

  u64 markdown_file_size = PG_UNWRAP(res_markdown_file_size);
  u64 stdio_size_hint = markdown_file_size * 5;

  PG_RESULT(PgProcessStatus, PgError)
  res_wait = pg_process_wait(process, stdio_size_hint, 0, allocator);

  PgProcessStatus status = PG_UNWRAP(res_wait);
  PG_ASSERT(0 == status.exit_status);
  PG_ASSERT(0 == status.signal);
  PG_ASSERT(status.exited);
  PG_ASSERT(!status.signaled);
  PG_ASSERT(!status.core_dumped);
  PG_ASSERT(!status.stopped);

  PG_ASSERT(pg_string_is_empty(status.stderr_captured));
  return status.stdout_captured;
}

static void html_collect_titles_rec(PgHtmlNode *node, PG_DYN(Title) * titles,
                                    PgAllocator *allocator) {
  PG_ASSERT(node);

  u8 level = pg_html_node_get_title_level(node);
  if (level) {
    PG_ASSERT(2 <= level && level <= 6);

    Title new_title = {0};
    new_title.level = level;
    new_title.title = pg_html_node_get_simple_title_content(node);
    new_title.slug = pg_html_make_slug(new_title.title, allocator);
    new_title.pos_start = node->token_start.start;
    new_title.pos_end = 2 + node->token_end.end;
    // Other fields backpatched.

    *PG_DYN_PUSH_WITHIN_CAPACITY(titles) = new_title;
  }

  PgHtmlNode *first_child = pg_html_node_get_first_child(node);
  if (first_child != node) {
    html_collect_titles_rec(first_child, titles, allocator);
  }
  PgHtmlNode *next_sibling = pg_html_node_get_next_sibling(node);
  if (next_sibling != node) {
    html_collect_titles_rec(next_sibling, titles, allocator);
  }
}

[[nodiscard]]
static PG_SLICE(Title)
    html_collect_titles(PgHtmlNode *html_root, PgAllocator *allocator) {
  PG_DYN(Title) titles = {0};
  PG_DYN_ENSURE_CAP(&titles, 64, allocator);

  *PG_DYN_PUSH_WITHIN_CAPACITY(&titles) = (Title){.level = 1};
  Title *title_root = PG_SLICE_AT_PTR(&titles, 0);
  title_root->parent = title_root;

  html_collect_titles_rec(html_root, &titles, allocator);

  for (u64 i = 1; i < titles.len; i++) {
    Title *title = PG_SLICE_AT_PTR(&titles, i);
    title->parent = title_root;

    Title *previous = PG_SLICE_AT_PTR(&titles, i - 1);
    i8 level_diff = previous->level - title->level;

    if (level_diff > 0) {
      // The current title is a (great-)uncle of the current title.
      for (u64 _j = 0; _j < (u64)level_diff; _j++) {
        PG_ASSERT(title->parent);
        title->parent = title->parent->parent;
      }
    } else if (level_diff < 0) {
      // Check that we do not skip levels e.g. prevent `## Foo\n#### Bar\n`
      PG_ASSERT(level_diff == -1);
      title->parent = previous;
    } else if (0 == level_diff) { // Sibling.
      title->parent = previous->parent;
    }
    PG_ASSERT(title->parent->level + 1 == title->level);
    Title *child = title->parent->first_child;
    // Add the node as last child of the parent.
    while (child && child->next_sibling) {
      child = child->next_sibling;
    }
    // Already one child present.
    if (child) {
      child->next_sibling = title;
    } else { // First child.
      title->parent->first_child = title;
    }
  }

  for (u64 i = 0; i < titles.len; i++) {
    Title *title = PG_SLICE_AT_PTR(&titles, i);

    // Backpatch `counter` which is a monotonically incrementing number in case
    // of `slug` collisions.
    for (i64 j = (i64)i - 1; j >= 0; j--) {
      Title it = PG_SLICE_AT(titles, j);
      if (pg_string_eq(title->slug, it.slug)) {
        title->counter = it.counter + 1;
        break;
      }
    }
  }
  PG_ASSERT(nullptr == title_root->next_sibling);

  return PG_DYN_TO_SLICE(PG_SLICE(Title), titles);
}

static void html_write_title_link(PG_DYN(u8) * sb, Title title,
                                  PgAllocator *allocator) {
  PG_DYN_APPEND_SLICE(sb, title.slug, allocator);
  if (title.counter) {
    PG_DYN_APPEND_SLICE(sb, PG_S("-"), allocator);
    pg_string_builder_append_u64(sb, title.counter, allocator);
  }
}

static void html_write_decorated_titles(PgString html, PG_DYN(u8) * sb,
                                        PG_SLICE(Title) titles,
                                        PgAllocator *allocator) {
  PG_ASSERT(!PG_SLICE_IS_EMPTY(titles));

  u64 last_title_pos_end = 0;

  for (u64 i = 1; i < titles.len; i++) {
    Title title = PG_SLICE_AT(titles, i);
    PG_ASSERT(title.pos_end > title.pos_start);

    PG_DYN_APPEND_SLICE(
        sb, PG_SLICE_RANGE(html, last_title_pos_end, title.pos_start),
        allocator);
    if (last_title_pos_end != 0) {
      PG_ASSERT(last_title_pos_end < title.pos_end);
    }
    last_title_pos_end = title.pos_end;

    PG_DYN_APPEND_SLICE(sb, PG_S("h"), allocator);
    pg_string_builder_append_u64(sb, title.level, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S(" id=\""), allocator);
    html_write_title_link(sb, title, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("\">\n  <a class=\"title\" href=\"#"),
                        allocator);
    html_write_title_link(sb, title, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("\">"), allocator);
    PG_DYN_APPEND_SLICE(sb, title.title, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("</a>\n"), allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("  <a class=\"hash-anchor\" href=\"#"),
                        allocator);
    html_write_title_link(sb, title, allocator);
    PG_DYN_APPEND_SLICE(
        sb,
        PG_S("\" aria-hidden=\"true\" "
             "onclick=\"navigator.clipboard.writeText(this.href);\"></a>\n"),
        allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("</h"), allocator);
    pg_string_builder_append_u64(sb, title.level, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S(">\n"), allocator);
  }

  PG_DYN_APPEND_SLICE(sb, PG_SLICE_RANGE_START(html, last_title_pos_end),
                      allocator);
  PG_ASSERT(sb->len > html.len);
}

static void article_write_toc_rec(PG_DYN(u8) * sb, Title *title,
                                  PgAllocator *allocator) {
  if (!title) {
    return;
  }

  if (title->level > 1) {
    PG_DYN_APPEND_SLICE(sb, PG_S("\n  <li>\n    <a href=\"#"), allocator);
    html_write_title_link(sb, *title, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("\">"), allocator);
    PG_DYN_APPEND_SLICE(sb, title->title, allocator);
    PG_DYN_APPEND_SLICE(sb, PG_S("</a>\n"), allocator);
  }

  if (title->first_child) {
    PG_DYN_APPEND_SLICE(sb, PG_S("<ul>\n"), allocator);
  }
  article_write_toc_rec(sb, title->first_child, allocator);
  if (title->first_child) {
    PG_DYN_APPEND_SLICE(sb, PG_S("</ul>\n"), allocator);
  }

  if (title->level > 1) {
    PG_DYN_APPEND_SLICE(sb, PG_S("  </li>\n"), allocator);
  }

  article_write_toc_rec(sb, title->next_sibling, allocator);
}

static void article_write_toc(PG_DYN(u8) * sb, PG_SLICE(Title) titles,
                              PgAllocator *allocator) {
  PG_ASSERT(!PG_SLICE_IS_EMPTY(titles));
  Title *root = PG_SLICE_AT_PTR(&titles, 0);

  if (!root->first_child) {
    return;
  }

  PG_DYN_APPEND_SLICE(
      sb,
      PG_S(" <details class=\"toc\"><summary>Table of contents</summary>\n"),
      allocator);
  article_write_toc_rec(sb, root, allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</details>\n"), allocator);
}

static void search_index_feed_document(SearchIndex *search_index,
                                       PG_SLICE(PgHtmlToken) html_tokens,
                                       Article article, PG_SLICE(Title) titles,
                                       PgAllocator *allocator) {
  SearchDocument doc = {
      .html_file_name = article.html_file_name,
      .title = article.title,
      .titles = titles,
  };
  PG_DYN_ENSURE_CAP(&doc.text, 128 * PG_KiB, allocator);
  PG_DYN_ENSURE_CAP(&doc.title_text_offsets, titles.len, allocator);

  for (u64 i = 0; i < html_tokens.len; i++) {
    PgHtmlToken token = PG_SLICE_AT(html_tokens, i);

    if (PG_HTML_TOKEN_KIND_TAG_OPENING == token.kind &&
        (pg_string_eq(token.tag, PG_S("h2")) ||
         pg_string_eq(token.tag, PG_S("h3")) ||
         pg_string_eq(token.tag, PG_S("h4")) ||
         pg_string_eq(token.tag, PG_S("h5")) ||
         pg_string_eq(token.tag, PG_S("h6")))) {
      PG_ASSERT(i + 2 < html_tokens.len);

      *PG_DYN_PUSH_WITHIN_CAPACITY(&doc.title_text_offsets) = (u32)doc.text.len;
    } else if (PG_HTML_TOKEN_KIND_TEXT == token.kind) {
      PG_DYN_APPEND_SLICE(&doc.text, pg_string_trim_space(token.text),
                          allocator);
      PG_DYN_PUSH(&doc.text, ' ', allocator);
    }
  }
  PG_DYN_PUSH(&search_index->documents, doc, allocator);
}

static void article_generate_html_file(PgFileDescriptor markdown_file,
                                       u64 metadata_offset, Article *article,
                                       PgString header, PgString footer,
                                       SearchIndex *search_index,
                                       PgAllocator *allocator) {

  PgString article_html =
      markdown_to_html(markdown_file, metadata_offset, allocator);
  PG_RESULT(PgHtmlNodePtr, PgError)
  res_parse = pg_html_parse(article_html, allocator);

  PgHtmlNode *html_root = PG_UNWRAP(res_parse);

  PG_SLICE(Title) titles = html_collect_titles(html_root, allocator);

  PG_DYN(u8) sb = {0};
  PG_DYN_ENSURE_CAP(&sb, article_html.len * 8, allocator);
  PG_DYN_APPEND_SLICE(&sb,
                      PG_S(HTML_AUTOGENERATED_COMMENT
                           "<!DOCTYPE html>\n<html>\n<head>\n<title>"),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, pg_html_sanitize(article->title, allocator),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</title>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, header, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("\n<div class=\"article-prelude\">\n  "),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S(BACK_LINK), allocator);
  PG_DYN_APPEND_SLICE(
      &sb, PG_S("\n  <p class=\"publication-date\">Published on "), allocator);
  PG_DYN_APPEND_SLICE(&sb, datetime_to_date(article->creation_date), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S(".</p>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</div>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<div class=\"article-title\">\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<h1>"), allocator);
  PG_DYN_APPEND_SLICE(&sb, article->title, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</h1>\n"), allocator);

  PG_DYN_APPEND_SLICE(&sb, PG_S("  <div class=\"tags\">"), allocator);
  for (u64 i = 0; i < article->tags.len; i++) {
    PgString tag = PG_SLICE_AT(article->tags, i);
    PgString id = pg_html_make_slug(tag, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S(" <a href=\"/blog/articles-by-tag.html#"),
                        allocator);
    PG_DYN_APPEND_SLICE(&sb, id, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("\" class=\"tag\">"), allocator);
    PG_DYN_APPEND_SLICE(&sb, tag, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("</a>"), allocator);
  }
  PG_DYN_APPEND_SLICE(&sb, PG_S("</div>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("  </div>\n"), allocator);

  article_write_toc(&sb, titles, allocator);

  PG_DYN_APPEND_SLICE(&sb, PG_S("\n"), allocator);

  html_write_decorated_titles(article_html, &sb, titles, allocator);

  PG_DYN_APPEND_SLICE(&sb, PG_S(BACK_LINK), allocator);
  PG_DYN_APPEND_SLICE(&sb, footer, allocator);
  PgString html = PG_DYN_TO_SLICE(PgString, sb);
  {
    PG_RESULT(PG_DYN(PgHtmlToken), PgError)
    res_html_tokens = pg_html_tokenize(article_html, allocator);

    PG_SLICE(PgHtmlToken)
    html_tokens =
        PG_DYN_TO_SLICE(PG_SLICE(PgHtmlToken), PG_UNWRAP(res_html_tokens));
    search_index_feed_document(search_index, html_tokens, *article, titles,
                               allocator);
  }
  PG_ASSERT(0 ==
            pg_file_write_full(article->html_file_name, html, 0600, allocator));
}

[[nodiscard]]
static Article article_generate(PgString header, PgString footer,
                                GitStat git_stat, SearchIndex *search_index,
                                PgAllocator *allocator) {
  printf("generating article: %.*s\n", (int)git_stat.path_rel.len,
         git_stat.path_rel.data);
  Article article = {
      .creation_date = git_stat.creation_date,
      .modification_date = git_stat.modification_date,
  };

  PG_RESULT(PgFileDescriptor, PgError)
  res_markdown_file = pg_file_open(git_stat.path_rel, PG_FILE_ACCESS_READ, 0600,
                                   false, allocator);
  PgFileDescriptor markdown_file = PG_UNWRAP(res_markdown_file);

  u8 tmp[1024] = {0};
  PgString markdown_header = {
      .data = tmp,
      .len = PG_STATIC_ARRAY_LEN(tmp),
  };
  PG_RESULT(u64, PgError)
  res_markdown_header = pg_file_read(markdown_file, markdown_header);
  markdown_header.len = PG_UNWRAP(res_markdown_header);
  PG_ASSERT(markdown_header.len > 16);

  PG_ASSERT(0 == pg_file_rewind_start(markdown_file));

  PgStringCut cut =
      pg_string_cut_string(markdown_header, PG_S(METADATA_DELIMITER));
  PG_ASSERT(cut.has_value);
  PgString metadata_str = cut.left;
  PG_ASSERT(!pg_string_is_empty(metadata_str));
  u64 metadata_offset = cut.left.len + PG_STATIC_ARRAY_LEN(METADATA_DELIMITER);

  cut = pg_string_cut_rune(metadata_str, '\n');
  PG_ASSERT(cut.has_value);
  PgString metadata_title = cut.left;
  PG_ASSERT(!pg_string_is_empty(metadata_title));
  PgString metadata_tags = cut.right;
  PG_ASSERT(!pg_string_is_empty(metadata_tags));

  cut = pg_string_cut_rune(metadata_title, ':');
  PG_ASSERT(cut.has_value);
  article.title = pg_string_clone(pg_string_trim(cut.right, ' '), allocator);
  PG_ASSERT(!pg_string_is_empty(article.title));

  cut = pg_string_cut_rune(metadata_tags, ':');
  PG_ASSERT(cut.has_value);
  PgString tags_str = cut.right;
  PG_ASSERT(!pg_string_is_empty(tags_str));

  PgString remaining = tags_str;
  PG_DYN(PgString) tags = {0};
  PG_DYN_ENSURE_CAP(&tags, 32, allocator);
  for (;;) {
    cut = pg_string_cut_rune(remaining, ',');
    if (!cut.has_value) {
      PgString tag = pg_string_trim_space(remaining);
      *PG_DYN_PUSH_WITHIN_CAPACITY(&tags) = pg_string_clone(tag, allocator);
      break;
    }

    PgString tag = pg_string_trim(cut.left, ' ');
    remaining = cut.right;

    *PG_DYN_PUSH_WITHIN_CAPACITY(&tags) = pg_string_clone(tag, allocator);
  }
  PG_ASSERT(tags.len > 0);
  article.tags = PG_DYN_TO_SLICE(PG_SLICE(PgString), tags);

  PgString stem = pg_path_stem(git_stat.path_rel);
  article.html_file_name = pg_string_concat(stem, PG_S(".html"), allocator);

  article_generate_html_file(markdown_file, metadata_offset, &article, header,
                             footer, search_index, allocator);

  PG_ASSERT(0 == pg_file_close(markdown_file));
  return article;
}

[[nodiscard]]
static PG_SLICE(Article)
    articles_generate(PgString header, PgString footer,
                      SearchIndex *search_index, PgAllocator *allocator) {
  PG_ASSERT(!pg_string_is_empty(header));
  PG_ASSERT(!pg_string_is_empty(footer));

  PG_SLICE(GitStat) git_stats = git_get_articles_stats(allocator);

  PG_DYN(Article) articles = {0};
  PG_DYN_ENSURE_CAP(&articles, 100, allocator);

  for (u64 i = 0; i < git_stats.len; i++) {
    GitStat git_stat = PG_SLICE_AT(git_stats, i);

    // The home page is generated separately.
    // The logic is different from an article.
    if (pg_string_eq(git_stat.path_rel, PG_S("index.md"))) {
      continue;
    }

    // Skip the readme.
    if (pg_string_eq(git_stat.path_rel, PG_S("README.md"))) {
      continue;
    }

    // Skip the todo.
    if (pg_string_eq(git_stat.path_rel, PG_S("todo.md"))) {
      continue;
    }

    Article article =
        article_generate(header, footer, git_stat, search_index, allocator);
    *PG_DYN_PUSH_WITHIN_CAPACITY(&articles) = article;
  }

  return PG_DYN_TO_SLICE(PG_SLICE(Article), articles);
}

static void home_page_generate(PG_SLICE(Article) articles, PgString header,
                               PgString footer, PgAllocator *allocator) {

  qsort(articles.data, articles.len, sizeof(Article),
        article_cmp_by_creation_date_desc);

  PgString markdown_file_path = PG_S("index.md");
  PgString html_file_path = PG_S("index.html");

  PG_DYN(u8) sb = pg_string_builder_make(64 * PG_KiB, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<!DOCTYPE html>\n<html>\n<head>\n<title>"),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("Philippe Gaultier's blog"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</title>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, header, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("\n<div class=\"articles\">\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("  <h2 id=\"articles\">Articles</h2>\n"),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("  <ul>\n"), allocator);

  for (u64 i = 0; i < articles.len; i++) {
    Article a = PG_SLICE_AT(articles, i);

    if (pg_string_eq(a.html_file_name, PG_S("body_of_work.html"))) {
      continue;
    }
    PG_DYN_APPEND_SLICE(&sb, PG_S("\n  <li>\n"), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("    <div class=\"home-link\">\n"),
                        allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("      <span class=\"date\">"), allocator);
    PG_DYN_APPEND_SLICE(&sb, datetime_to_date(a.creation_date), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("</span>\n"), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("      <a href=\"/blog/"), allocator);
    PG_DYN_APPEND_SLICE(&sb, a.html_file_name, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("\">"), allocator);
    PG_DYN_APPEND_SLICE(&sb, a.title, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("</a>\n"), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("    </div>\n"), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("<div class=\"tags\">\n"), allocator);

    for (u64 j = 0; j < a.tags.len; j++) {
      PgString tag = PG_SLICE_AT(a.tags, j);
      PgString id = pg_html_make_slug(tag, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S(" <a href=\"/blog/articles-by-tag.html#"),
                          allocator);
      PG_DYN_APPEND_SLICE(&sb, id, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("\" class=\"tag\">"), allocator);
      PG_DYN_APPEND_SLICE(&sb, tag, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("</a>"), allocator);
    }
    PG_DYN_APPEND_SLICE(&sb, PG_S("</div></li>"), allocator);
  }
  PG_DYN_APPEND_SLICE(&sb, PG_S("  </ul>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</div>\n"), allocator);

  PG_RESULT(PgFileDescriptor, PgError)
  res_markdown_file = pg_file_open(markdown_file_path, PG_FILE_ACCESS_READ,
                                   0600, false, allocator);
  PgString html = markdown_to_html(PG_UNWRAP(res_markdown_file), 0, allocator);

  PG_RESULT(PgHtmlNodePtr, PgError) res_parse = pg_html_parse(html, allocator);

  PgHtmlNode *html_root = PG_UNWRAP(res_parse);

  PG_SLICE(Title) titles = html_collect_titles(html_root, allocator);
  html_write_decorated_titles(html, &sb, titles, allocator);

  PG_DYN_APPEND_SLICE(&sb, footer, allocator);

  PG_ASSERT(0 == pg_file_write_full(html_file_path,
                                    PG_DYN_TO_SLICE(PgString, sb), 0600,
                                    allocator));
  PG_ASSERT(0 == pg_file_close(PG_UNWRAP(res_markdown_file)));
}

#define HASH_TABLE_EXP 10

typedef struct {
  // Tag.
  PgString keys[1 << HASH_TABLE_EXP];
  // Articles.
  PG_DYN(Article) values[1 << HASH_TABLE_EXP];
} ArticlesByTag;

[[nodiscard]]
    static PG_DYN(Article) *
    articles_by_tag_lohas_valueup(ArticlesByTag *table, PgString key) {
  u64 hash = pg_hash_fnv(key);
  u32 mask = (1 << HASH_TABLE_EXP) - 1;
  u32 step = (hash >> (64 - HASH_TABLE_EXP)) | 1;
  for (u32 i = (u32)hash;;) {
    i = ((i + step) & mask);

    PgString *k =
        PG_C_ARRAY_AT_PTR(table->keys, PG_STATIC_ARRAY_LEN(table->keys), i);
    if (pg_string_is_empty(*k)) {
      *k = key;
      return table->values + i;
    } else if (pg_string_eq(*k, key)) {
      return table->values + i;
    }
  }
}

[[nodiscard]]
static PG_SLICE(PgString)
    articles_by_tag_get_keys(ArticlesByTag table, PgAllocator *allocator) {
  PG_DYN(PgString) res = {0};
  PG_DYN_ENSURE_CAP(&res, PG_STATIC_ARRAY_LEN(table.keys), allocator);

  for (u64 i = 0; i < PG_STATIC_ARRAY_LEN(table.keys); i++) {
    PgString key =
        PG_C_ARRAY_AT(table.keys, PG_STATIC_ARRAY_LEN(table.keys), i);
    if (pg_string_is_empty(key)) {
      continue;
    }

    PG_DYN_PUSH(&res, key, allocator);
  }

  qsort(res.data, res.len, sizeof(PgString), pg_string_cmp_qsort);

  return PG_DYN_TO_SLICE(PG_SLICE(PgString), res);
}

static void tags_page_generate(PG_SLICE(Article) articles, PgString header,
                               PgString footer, PgAllocator *allocator) {
  ArticlesByTag articles_by_tag = {0};

  PG_ASSERT(articles.len <= PG_STATIC_ARRAY_LEN(articles_by_tag.keys));
  static_assert(PG_STATIC_ARRAY_LEN(articles_by_tag.keys) ==
                PG_STATIC_ARRAY_LEN(articles_by_tag.values));

  for (u64 i = 0; i < articles.len; i++) {
    Article article = PG_SLICE_AT(articles, i);

    for (u64 j = 0; j < article.tags.len; j++) {
      PgString tag = PG_SLICE_AT(article.tags, j);
      PG_ASSERT(!pg_string_is_empty(tag));

      PG_DYN(Article) *articles_for_tag =
          articles_by_tag_lohas_valueup(&articles_by_tag, tag);
      PG_DYN_ENSURE_CAP(articles_for_tag, 128, allocator);
      PG_DYN_PUSH(articles_for_tag, article, allocator);
    }
  }
  PG_SLICE(PgString)
  tags_lexicographically_ordered =
      articles_by_tag_get_keys(articles_by_tag, allocator);

  PG_DYN(u8) sb = pg_string_builder_make(64 * PG_KiB, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<!DOCTYPE html>\n<html>\n<head>\n<title>"),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("Articles by tag"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</title>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, header, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S(BACK_LINK), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<h1>Articles by tag</h1>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<ul>\n"), allocator);

  for (u64 i = 0; i < tags_lexicographically_ordered.len; i++) {
    PgString tag = PG_SLICE_AT(tags_lexicographically_ordered, i);

    PG_DYN_APPEND_SLICE(&sb, PG_S("<li id=\""), allocator);
    PG_DYN_APPEND_SLICE(&sb, pg_html_make_slug(tag, allocator), allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("\"><span class=\"tag\">"), allocator);
    PG_DYN_APPEND_SLICE(&sb, tag, allocator);
    PG_DYN_APPEND_SLICE(&sb, PG_S("</span><ul>\n"), allocator);

    PG_DYN(Article) *articles_for_tag =
        articles_by_tag_lohas_valueup(&articles_by_tag, tag);
    PG_ASSERT(articles_for_tag->len > 0);

    qsort(articles_for_tag->data, articles_for_tag->len, sizeof(Article),
          article_cmp_by_creation_date_asc);

    for (u64 j = 0; j < articles_for_tag->len; j++) {
      Article article = PG_SLICE_AT(*articles_for_tag, j);

      bool tag_found = false;
      for (u64 k = 0; k < article.tags.len; k++) {
        if (pg_string_eq(PG_SLICE_AT(article.tags, k), tag)) {
          tag_found = true;
          break;
        }
      }
      PG_ASSERT(tag_found);

      PG_DYN_APPEND_SLICE(&sb, PG_S("<li>\n"), allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("  <span class=\"date\">"), allocator);
      PG_DYN_APPEND_SLICE(&sb, datetime_to_date(article.creation_date),
                          allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("</span>\n"), allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("  <a href=\""), allocator);
      PG_DYN_APPEND_SLICE(&sb, article.html_file_name, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("\">"), allocator);
      PG_DYN_APPEND_SLICE(&sb, article.title, allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("</a>\n"), allocator);
      PG_DYN_APPEND_SLICE(&sb, PG_S("</li>\n"), allocator);
    }

    PG_DYN_APPEND_SLICE(&sb, PG_S("</ul></li>\n"), allocator);
  }

  PG_DYN_APPEND_SLICE(&sb, PG_S("</ul>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, footer, allocator);

  PgString html_file_name = PG_S("articles-by-tag.html");
  PG_ASSERT(0 == pg_file_write_full(html_file_name,
                                    PG_DYN_TO_SLICE(PgString, sb), 0600,
                                    allocator));
}

static void article_rss_generate(PG_DYN(u8) * sb, Article a,
                                 PgAllocator *allocator) {
  PgUuid article_uuid = pg_uuid_v5(FEED_UUID, a.html_file_name);

  PG_DYN_APPEND_SLICE(sb, PG_S("\n<entry>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("<title>"), allocator);
  PG_DYN_APPEND_SLICE(sb, pg_html_sanitize(a.title, allocator), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</title>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("<link href=\""), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S(BASE_URL), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("/"), allocator);
  PG_DYN_APPEND_SLICE(sb, a.html_file_name, allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("\"/>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("<id>urn:uuid:"), allocator);
  PG_DYN_APPEND_SLICE(sb, pg_uuid_to_string(article_uuid, allocator),
                      allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</id>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("<updated>"), allocator);
  PG_DYN_APPEND_SLICE(sb, a.modification_date, allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</updated>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("<published>"), allocator);
  PG_DYN_APPEND_SLICE(sb, a.creation_date, allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</published>\n"), allocator);
  PG_DYN_APPEND_SLICE(sb, PG_S("</entry>\n"), allocator);
}

static void rss_generate(PG_SLICE(Article) articles, PgAllocator *allocator) {
  qsort(articles.data, articles.len, sizeof(Article),
        article_cmp_by_creation_date_asc);

  PG_DYN(u8) sb = pg_string_builder_make(16 * PG_KiB, allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"),
                      allocator);
  PG_DYN_APPEND_SLICE(
      &sb, PG_S("<feed xmlns=\"http://www.w3.org/2005/Atom\">\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<title>Philippe Gaultier's blog</title>\n"),
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<link href=\""), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S(BASE_URL), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("\"/>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<updated>"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_SLICE_LAST(articles).modification_date,
                      allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</updated>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<author>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<name>Philippe Gaultier</name>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</author>\n"), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("<id>urn:uuid:"), allocator);
  PG_DYN_APPEND_SLICE(&sb, pg_uuid_to_string(FEED_UUID, allocator), allocator);
  PG_DYN_APPEND_SLICE(&sb, PG_S("</id>\n"), allocator);

  for (u64 i = 0; i < articles.len; i++) {
    Article a = PG_SLICE_AT(articles, i);
    article_rss_generate(&sb, a, allocator);
  }

  PG_DYN_APPEND_SLICE(&sb, PG_S("</feed>"), allocator);

  PG_ASSERT(0 == pg_file_write_full(PG_S("feed.xml"),
                                    PG_DYN_TO_SLICE(PgString, sb), 0600,
                                    allocator));
}

[[maybe_unused]]
static void http_handler(PgHttpRequest req, PgReader *reader, PgWriter *writer,
                         PgLogger *logger, PgAllocator *allocator, void *ctx) {
  (void)ctx;
  (void)reader;

  pg_log(logger, PG_LOG_LEVEL_INFO, "http handler: handling request",
         pg_log_c_u64("headers_count", req.headers.len),
         pg_log_c_s("method", pg_http_method_to_string(req.method)),
         pg_log_c_s("url", pg_url_to_string(req.url, allocator)));

  PG_RESULT(u64, PgError)
  res_content_length = pg_http_content_length(
      PG_DYN_TO_SLICE(PG_SLICE(PgStringKeyValue), req.headers));
  if (PG_IS_ERR(res_content_length)) {
    pg_log(logger, PG_LOG_LEVEL_ERROR, "http handler: invalid content length",
           pg_log_c_u64("headers_count", req.headers.len),
           pg_log_c_s("method", pg_http_method_to_string(req.method)),
           pg_log_c_s("url", pg_url_to_string(req.url, allocator)));
    return;
  }
  u64 content_length = PG_UNWRAP(res_content_length);
  Pgu8Slice req_body = pg_bytes_make(content_length, allocator);
  PgError err = pg_reader_read_slice_full(reader, req_body);
  if (err) {
    pg_log(logger, PG_LOG_LEVEL_ERROR, "http handler: failed to read body",
           pg_log_c_u64("headers_count", req.headers.len),
           pg_log_c_s("method", pg_http_method_to_string(req.method)),
           pg_log_c_s("url", pg_url_to_string(req.url, allocator)));
    return;
  }

  pg_log(logger, PG_LOG_LEVEL_INFO, "http handler: body read",
         pg_log_c_u64("headers_count", req.headers.len),
         pg_log_c_s("method", pg_http_method_to_string(req.method)),
         pg_log_c_s("req_body", req_body),
         pg_log_c_s("url", pg_url_to_string(req.url, allocator)));

  PgHttpResponse resp = {0};
  resp.version_major = 1;
  resp.version_minor = 1;
  resp.status = 201;
  pg_http_push_header(&resp.headers, PG_S("Content-Type"),
                      PG_S("application/html"), allocator);

  err = pg_http_write_response(writer, resp, allocator);
  if (err) {
    pg_log(logger, PG_LOG_LEVEL_ERROR,
           "http handler: failed to write http response",
           pg_log_c_err("err", err));
    return;
  }

  (void)pg_writer_write_full(writer, PG_S("Hi there"), allocator);
  (void)pg_writer_flush(writer, allocator);

  // u8 tmp[4096] = {0};
  // Pgu8Slice tmp_slice = {
  //     .data = tmp,
  //     .len = PG_STATIC_ARRAY_LEN(tmp),
  // };
  // PG_RESULT(u64,PgError) res = pg_buf_reader_read(buf_reader, tmp_slice);
  // pg_log(logger, PG_LOG_LEVEL_DEBUG, "http handler: request body",
  //        pg_log_c_s("body", req_body));
}

[[maybe_unused]]
static void *run_http_server(void *) {
  PgArena arena = pg_arena_make_from_virtual_mem(40 * PG_KiB);
  PgArenaAllocator arena_allocator = pg_make_arena_allocator(&arena);
  PgAllocator *allocator = pg_arena_allocator_as_allocator(&arena_allocator);

  PgLogger logger = pg_log_make_logger_stdout(PG_LOG_LEVEL_INFO,
                                              PG_LOG_FORMAT_LOGFMT, allocator);
  PgHttpServerOptions options = {
      .port = 3001,
      .listen_backlog = 1024,
      .http_handler_arena_mem = 32 * PG_KiB,
      .handler = http_handler,
  };
  PgError err = pg_http_server_start(options, &logger);
  if (err) {
    return nullptr;
  }
  return nullptr;
}

#if 0
static void watch_dir() {
  PgArena arena = pg_arena_make_from_virtual_mem(4 * PG_KiB);
  PgArenaAllocator arena_allocator = pg_make_arena_allocator(&arena);
  PgAllocator *allocator = pg_arena_allocator_as_allocator(&arena_allocator);

  PG_RESULT(PgAio, PgError) res_aio = pg_aio_init();
  PgAio aio = PG_UNWRAP(res_aio);

  PgError err = pg_aio_register_watch_directory(
      &aio, PG_S("."),
      PG_WALK_DIRECTORY_KIND_FILE | PG_WALK_DIRECTORY_KIND_DIRECTORY,
      allocator);
  PG_ASSERT(0 == err);

  for (;;) {
    PG_RESULT(PgAioEvent, PgError)
    res_wait = pg_aio_fs_wait_one(aio, PG_NONE(u32), allocator);
    PgAioEvent event = PG_UNWRAP(res_wait);

    PgString ext = pg_file_extension(event.name);
    if (pg_string_eq(ext, PG_S("md"))) {
      fprintf(stderr, "file modified: %.*s %d\n", (i32)event.name.len,
              event.name.data, event.kind);
    }
  }
}
#endif

int main() {
  PgArena arena = pg_arena_make_from_virtual_mem(120 * PG_MiB);
  PgArenaAllocator arena_allocator = pg_make_arena_allocator(&arena);
  PgAllocator *allocator = pg_arena_allocator_as_allocator(&arena_allocator);

#if 0
  {
    PgThreadResult res_thread = pg_thread_create(run_http_server, nullptr);
    PG_ASSERT(!res_thread.err);
  }
#endif

#if 0
  {
    PG_RESULT(PgFileDescriptor) res_fs_init = pg_aio_fs_init();
    PG_ASSERT(0 == res_fs_init.err);
    PgFileDescriptor fs_manager = res_fs_init.res;

    PG_RESULT(PgFileDescriptor) res_fd = pg_aio_fs_register_interest(
        fs_manager, PG_S("."),
        PG_AIO_EVENT_KIND_FILE_MODIFIED | PG_AIO_EVENT_KIND_FILE_CREATED);
    PG_ASSERT(0 == res_fd.err);
    PgFileDescriptor fs_fd = res_fd.res;
    PG_ASSERT(0 != fs_fd.fd);

    PG_RESULT(PgFileDescriptor) res_init = pg_aio_init();
    PG_ASSERT(0 == res_init.err);
    PgFileDescriptor manager = res_init.res;

    PgError err = pg_aio_register_interest(manager, fs_manager,
                                           PG_AIO_EVENT_KIND_READABLE);
    PG_ASSERT(0 == err);

    for (u64 i = 0; i < 10; i++) {
      PgAioEventResult res_fs_wait =
          pg_aio_fs_wait_one(manager, (Pgu32Option){0}, allocator);
      PG_ASSERT(0 == res_fs_wait.err);
      PgAioEvent ev = res_fs_wait.res;
      printf("%u %.*s\n", ev.kind, (i32)ev.name.len, ev.name.data);
    }
  }
#endif

  PG_RESULT(PgString, PgError)
  res_header = pg_file_read_full_from_path(PG_S("header.html"), allocator);
  PgString header = PG_UNWRAP(res_header);

  PG_RESULT(PgString, PgError)
  res_footer = pg_file_read_full_from_path(PG_S("footer.html"), allocator);
  PgString footer = PG_UNWRAP(res_footer);

  SearchIndex search_index = {0};
  PG_SLICE(Article)
  articles = articles_generate(header, footer, &search_index, allocator);
  search_index_serialize_to_file(search_index, PG_S("search_index.js"),
                                 allocator);
  home_page_generate(articles, header, footer, allocator);
  tags_page_generate(articles, header, footer, allocator);
  rss_generate(articles, allocator);

  printf("generated %" PRIu64 " articles (arena use=%" PRIu64 ")\n",
         articles.len, pg_arena_mem_use(arena));

#if 0
  watch_dir();
#endif
}
