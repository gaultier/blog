## Ideas for articles

- [ ] HTTP server using arenas
- [ ] ~~Migration from mbedtls to aws-lc~~
- [ ] ~~ASM crypto~~
- [ ] How this blog is made. Line numbers in code snippets.
- [ ] Banjo chords
- [ ] Dtrace VM
- [ ] From BIOS to bootloader to kernel to userspace
- [ ] A faster HTTP parser than NodeJS's one
- [ ] SHA1 multi-block hash
- [ ] How CGO calls are implemented in assembly
- [ ] How I develop Windows applications from the comfort of Linux
- [ ] ~~Add a JS/Wasm live running version of the programs described in each article. As a fallback: Video/Gif.
    + [ ] Kahn's algorithm~~
- [ ] Blog search implementation
- [ ] C++ web server undefined behavior bug
- [ ] Weird and surprising things about x64 assembly
  + non symetric mnemonics (`cmp 1, rax` vs `cmp rax, 1`)
  + some different mnemonics encode to the same bytes (`jne`, `jz`)
  + diffent calling convention for functions & system calls in the SysV ABI (4th argument)
  + no (to my knowledge) mnemonic accepts 2 immediates or effective addresses as operands  e.g. `cmp 1, 0`
- [ ] Golang data race due to closure capture
    ```go
package main

import (
	"net/http"
	"strings"
)

func NewMiddleware(handler http.Handler, rateLimitEnabled bool) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.HasPrefix(r.URL.Path, "/admin") {
			rateLimitEnabled = false
		}

		if rateLimitEnabled {
			println("rate limiting...")
			// Rate limiting logic here ...
		} else {
			println("not rate limiting")
		}

		handler.ServeHTTP(w, r)
	})
}

func handle(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("hello!\n"))
}

func main() {
	handler := http.HandlerFunc(handle)
	middleware := NewMiddleware(handler, true)
	http.Handle("/", middleware)

	http.ListenAndServe(":3001", nil)
}
    ```

    ```sh
$ curl http://localhost:3001/
$ curl http://localhost:3001/admin
$ curl http://localhost:3001/

# Server output:
rate limiting...
not rate limiting
not rate limiting
    ```

    ```sh
$ go build -gcflags='-d closure=1' http-race.go
./http-race.go:9:26: heap closure, captured vars = [rateLimitEnabled handler]
    ```

    ```
diff --git a/http-race.go b/http-race.go
index 3d94a71..90b571e 100644
--- a/http-race.go
+++ b/http-race.go
@@ -5,8 +5,10 @@ import (
 	"strings"
 )
 
-func NewMiddleware(handler http.Handler, rateLimitEnabled bool) http.Handler {
+func NewMiddleware(handler http.Handler) http.Handler {
 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		rateLimitEnabled := true
+
 		if strings.HasPrefix(r.URL.Path, "/admin") {
 			rateLimitEnabled = false
 		}
@@ -28,7 +30,7 @@ func handle(w http.ResponseWriter, r *http.Request) {
 
 func main() {
 	handler := http.HandlerFunc(handle)
-	middleware := NewMiddleware(handler, true)
+	middleware := NewMiddleware(handler)
 	http.Handle("/", middleware)
 
 	http.ListenAndServe(":3001", nil)
    ```

    ```
$ go build -gcflags='-d closure=1' http-race.go
./http-race.go:9:26: heap closure, captured vars = [handler]
    ```


    ```sh
$ curl http://localhost:3001/
$ curl http://localhost:3001/admin
$ curl http://localhost:3001/

# Server output:
rate limiting...
not rate limiting
rate limiting...
    ```

    `parallel "curl -s http://localhost:3001/{2}"  ::: $(seq 100) ::: "admin" "hello"`

- [ ] How to get the current SQL schema when all you have is lots of migrations (deltas)
- [ ] 'About' page
- [ ] Search and replace fish function

## Blog implementation

- [x] Add autogenerated html comment in rendered html files
- [x] Consider post-processing HTML instead of markdown to simplify e.g. to add title ids
- [x] Support markdown syntax in article title in metadata
- [x] Use libcmark to simplify parsing
- [ ] Link to related articles at the end (requires post-processing after all articles have been generated)
- [x] Search
  + May require proper markdown parsing (e.g. with libcmark) to avoid having html/markdown elements in search results, to get the (approximate) location of each results (e.g. parent title), and show a rendered excerpt in search results. Perhaps simply post-process html?
  + Results are shown inline
  + Results show (some) surrounding text
  + Results have a link to the page and surrounding html section
  + Implementation: trigrams in js/wasm? Fuzzy search? See https://pkg.odin-lang.org/search.js
  + Search code/data are only fetched lazily
  + Cache invalidation of the search blob e.g. when an article is created/modified? => split search code (rarely changes) and data (changes a lot)
  + Code snippets included in search results?
- [ ] Articles excerpt on the home page?
- [ ] Dark mode
- [ ] Browser live reload
  + Send the F5 key to the browser window (does not work in Wayland)
  + Somehow send an IPC message to the right browser process to reload the page?
  + HTTP server & HTML page communicate via websocket to reload content (complex)
  + HTTP2 force push to force the browser to get the new page version?
  + Server sent event to reload the page
  + Websocket
- [ ] Built-in http server
- [ ] Built-in file watch
- [ ] Syntax highlighting done statically
- [ ] Highlight only the changed lines in a code snippet
- [ ] Copy-paste button for code snippets
