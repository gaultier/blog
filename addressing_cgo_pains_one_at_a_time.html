<!DOCTYPE html>
<html>
<head>
<title>Addressing CGO pains, one at a time</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link type="application/atom+xml" href="/blog/feed.xml" rel="self">
<link rel="shortcut icon" type="image/ico" href="/blog/favicon.ico">
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.8.0/styles/default.min.css">
<script src="highlight.min.js"></script>
<!-- From https://github.com/odin-lang/odin-lang.org/blob/6f48c2cfb094a42dffd34143884fa958bd9c0ba2/themes/odin/layouts/partials/head.html#L71 -->
<script src="x86asm.min.js"></script>
<script>
  window.onload = function() {
      hljs.registerLanguage("odin", function(e) {
      return {
          aliases: ["odin", "odinlang", "odin-lang"],
          keywords: {
              keyword: "auto_cast bit_field bit_set break case cast context continue defer distinct do dynamic else enum fallthrough for foreign if import in map matrix not_in or_else or_return package proc return struct switch transmute type_of typeid union using when where",
              literal: "true false nil",
              built_in: "abs align_of cap clamp complex conj expand_to_tuple imag jmag kmag len max min offset_of quaternion real size_of soa_unzip soa_zip swizzle type_info_of type_of typeid_of"
          },
          illegal: "</",
          contains: [e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, {
              className: "string",
              variants: [e.QUOTE_STRING_MODE, {
                  begin: "'",
                  end: "[^\\\\]'"
              }, {
                  begin: "`",
                  end: "`"
              }]
          }, {
              className: "number",
              variants: [{
                  begin: e.C_NUMBER_RE + "[ijk]",
                  relevance: 1
              }, e.C_NUMBER_MODE]
          }]
      }
    });

    hljs.highlightAll();

    document.querySelectorAll('code').forEach((el, _i) => {
        if (0 == el.classList.length || el.classList.contains('language-sh') || el.classList.contains('language-shell') || el.classList.contains('language-bash')){
          el.classList.add('code-no-line-numbers');
          return; 
        }

        var lines = el.innerHTML.trimEnd().split('\n');
        var out = [];
        lines.forEach(function(l, i){
          out.push('<span class="line-number">' + (i+1).toString() + '</span> ' + l);
        });
        el.innerHTML = out.join('\n');
    });
  }
</script>
</head>
<body>

<div id="banner">
    <div id="name">
        <img id="me" src="me.jpeg">
        <span>Philippe Gaultier</span>
    </div>
    <ul>
      <li> <a href="/blog/body_of_work.html">Body of work</a> </li>
      <li> <a href="/blog/articles-by-tag.html">Tags</a> </li>
      <li> <a href="https://github.com/gaultier/resume/raw/master/Philippe_Gaultier_resume_en.pdf">
          Resume
        </a> </li>

      <li> <a href="/blog/feed.xml">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 3.5C4.39543 3.5 3.5 4.39543 3.5 5.5V18.5C3.5 19.6046 4.39543 20.5 5.5 20.5H18.5C19.6046 20.5 20.5 19.6046 20.5 18.5V5.5C20.5 4.39543 19.6046 3.5 18.5 3.5H5.5ZM7 19C8.10457 19 9 18.1046 9 17C9 15.8954 8.10457 15 7 15C5.89543 15 5 15.8954 5 17C5 18.1046 5.89543 19 7 19ZM6.14863 10.5052C6.14863 10.0379 6.52746 9.65906 6.99478 9.65906C7.95949 9.65906 8.91476 9.84908 9.80603 10.2183C10.6973 10.5874 11.5071 11.1285 12.1893 11.8107C12.8715 12.4929 13.4126 13.3027 13.7817 14.194C14.1509 15.0852 14.3409 16.0405 14.3409 17.0052C14.3409 17.4725 13.9621 17.8514 13.4948 17.8514C13.0275 17.8514 12.6486 17.4725 12.6486 17.0052C12.6486 16.2627 12.5024 15.5275 12.2183 14.8416C11.9341 14.1556 11.5177 13.5324 10.9927 13.0073C10.4676 12.4823 9.84437 12.0659 9.15842 11.7817C8.47246 11.4976 7.73726 11.3514 6.99478 11.3514C6.52746 11.3514 6.14863 10.9725 6.14863 10.5052ZM7 5.15385C6.53268 5.15385 6.15385 5.53268 6.15385 6C6.15385 6.46732 6.53268 6.84615 7 6.84615C8.33342 6.84615 9.65379 7.10879 10.8857 7.61907C12.1176 8.12935 13.237 8.87728 14.1799 9.82015C15.1227 10.763 15.8707 11.8824 16.3809 13.1143C16.8912 14.3462 17.1538 15.6666 17.1538 17C17.1538 17.4673 17.5327 17.8462 18 17.8462C18.4673 17.8462 18.8462 17.4673 18.8462 17C18.8462 15.4443 18.5397 13.9039 17.9444 12.4667C17.3491 11.0294 16.4765 9.72352 15.3765 8.6235C14.2765 7.52349 12.9706 6.65091 11.5333 6.05558C10.0961 5.46026 8.55566 5.15385 7 5.15385Z" fill="#000000"/>
        </svg>
        </a> </li>

      <li> <a href="https://www.linkedin.com/in/philippegaultier/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-supported-dps="24x24" fill="currentColor" class="mercado-match" width="24" height="24" focusable="false">
              <path d="M20.5 2h-17A1.5 1.5 0 002 3.5v17A1.5 1.5 0 003.5 22h17a1.5 1.5 0 001.5-1.5v-17A1.5 1.5 0 0020.5 2zM8 19H5v-9h3zM6.5 8.25A1.75 1.75 0 118.3 6.5a1.78 1.78 0 01-1.8 1.75zM19 19h-3v-4.74c0-1.42-.6-1.93-1.38-1.93A1.74 1.74 0 0013 14.19a.66.66 0 000 .14V19h-3v-9h2.9v1.3a3.11 3.11 0 012.7-1.4c1.55 0 3.36.86 3.36 3.66z"></path>
            </svg>
        </a> </li>
      <li> <a href="https://github.com/gaultier">
        <svg height="32" aria-hidden="true" viewBox="0 0 24 24" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle">
            <path d="M12.5.75C6.146.75 1 5.896 1 12.25c0 5.089 3.292 9.387 7.863 10.91.575.101.79-.244.79-.546 0-.273-.014-1.178-.014-2.142-2.889.532-3.636-.704-3.866-1.35-.13-.331-.69-1.352-1.18-1.625-.402-.216-.977-.748-.014-.762.906-.014 1.553.834 1.769 1.179 1.035 1.74 2.688 1.25 3.349.948.1-.747.402-1.25.733-1.538-2.559-.287-5.232-1.279-5.232-5.678 0-1.25.445-2.285 1.178-3.09-.115-.288-.517-1.467.115-3.048 0 0 .963-.302 3.163 1.179.92-.259 1.897-.388 2.875-.388.977 0 1.955.13 2.875.388 2.2-1.495 3.162-1.179 3.162-1.179.633 1.581.23 2.76.115 3.048.733.805 1.179 1.825 1.179 3.09 0 4.413-2.688 5.39-5.247 5.678.417.36.776 1.05.776 2.128 0 1.538-.014 2.774-.014 3.162 0 .302.216.662.79.547C20.709 21.637 24 17.324 24 12.25 24 5.896 18.854.75 12.5.75Z"></path>
        </svg>
        </a> </li>
      <li> <a href="https://hachyderm.io/@pg">
        <svg width="75" height="79" viewBox="0 0 75 79" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M73.8393 17.4898C72.6973 9.00165 65.2994 2.31235 56.5296 1.01614C55.05 0.797115 49.4441 0 36.4582 0H36.3612C23.3717 0 20.585 0.797115 19.1054 1.01614C10.5798 2.27644 2.79399 8.28712 0.904997 16.8758C-0.00358524 21.1056 -0.100549 25.7949 0.0682394 30.0965C0.308852 36.2651 0.355538 42.423 0.91577 48.5665C1.30307 52.6474 1.97872 56.6957 2.93763 60.6812C4.73325 68.042 12.0019 74.1676 19.1233 76.6666C26.7478 79.2728 34.9474 79.7055 42.8039 77.9162C43.6682 77.7151 44.5217 77.4817 45.3645 77.216C47.275 76.6092 49.5123 75.9305 51.1571 74.7385C51.1797 74.7217 51.1982 74.7001 51.2112 74.6753C51.2243 74.6504 51.2316 74.6229 51.2325 74.5948V68.6416C51.2321 68.6154 51.2259 68.5896 51.2142 68.5661C51.2025 68.5426 51.1858 68.522 51.1651 68.5058C51.1444 68.4896 51.1204 68.4783 51.0948 68.4726C51.0692 68.4669 51.0426 68.467 51.0171 68.4729C45.9835 69.675 40.8254 70.2777 35.6502 70.2682C26.7439 70.2682 24.3486 66.042 23.6626 64.2826C23.1113 62.762 22.7612 61.1759 22.6212 59.5646C22.6197 59.5375 22.6247 59.5105 22.6357 59.4857C22.6466 59.4609 22.6633 59.4391 22.6843 59.422C22.7053 59.4048 22.73 59.3929 22.7565 59.3871C22.783 59.3813 22.8104 59.3818 22.8367 59.3886C27.7864 60.5826 32.8604 61.1853 37.9522 61.1839C39.1768 61.1839 40.3978 61.1839 41.6224 61.1516C46.7435 61.008 52.1411 60.7459 57.1796 59.7621C57.3053 59.7369 57.431 59.7154 57.5387 59.6831C65.4861 58.157 73.0493 53.3672 73.8178 41.2381C73.8465 40.7606 73.9184 36.2364 73.9184 35.7409C73.9219 34.0569 74.4606 23.7949 73.8393 17.4898Z" fill="url(#paint0_linear_549_34)"/>
        <path d="M61.2484 27.0263V48.114H52.8916V27.6475C52.8916 23.3388 51.096 21.1413 47.4437 21.1413C43.4287 21.1413 41.4177 23.7409 41.4177 28.8755V40.0782H33.1111V28.8755C33.1111 23.7409 31.0965 21.1413 27.0815 21.1413C23.4507 21.1413 21.6371 23.3388 21.6371 27.6475V48.114H13.2839V27.0263C13.2839 22.7176 14.384 19.2946 16.5843 16.7572C18.8539 14.2258 21.8311 12.926 25.5264 12.926C29.8036 12.926 33.0357 14.5705 35.1905 17.8559L37.2698 21.346L39.3527 17.8559C41.5074 14.5705 44.7395 12.926 49.0095 12.926C52.7013 12.926 55.6784 14.2258 57.9553 16.7572C60.1531 19.2922 61.2508 22.7152 61.2484 27.0263Z" fill="white"/>
        <defs>
        <linearGradient id="paint0_linear_549_34" x1="37.0692" y1="0" x2="37.0692" y2="79" gradientUnits="userSpaceOnUse">
        <stop stop-color="#6364FF"/>
        <stop offset="1" stop-color="#563ACC"/>
        </linearGradient>
        </defs>
        </svg>
        </a> </li>
      <li> <a href="https://bsky.app/profile/pgaultier.bsky.social">
        <svg fill="none" viewBox="0 0 64 57" width="32" style="width: 32px; height: 28.5px;"><path fill="#0085ff" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805ZM50.127 3.805C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745Z"></path></svg>
        </a> </li>
    </ul>
</div>
<div class="body">

<div class="article-prelude">
  <p><a href="/blog"> ‚è¥ Back to all articles</a></p>

  <p class="publication-date">Published on 2025-02-14</p>
</div>
<div class="article-title">
<h1>Addressing CGO pains, one at a time</h1>

  <div class="tags"> <a href="/blog/articles-by-tag.html#Go" class="tag">Go</a> <a href="/blog/articles-by-tag.html#C" class="tag">C</a> <a href="/blog/articles-by-tag.html#Rust" class="tag">Rust</a> <a href="/blog/articles-by-tag.html#Zig" class="tag">Zig</a> <a href="/blog/articles-by-tag.html#Docker" class="tag">Docker</a> <a href="/blog/articles-by-tag.html#Cross-compilation" class="tag">Cross-compilation</a></div>
  </div>

<p>Rust? Go? Cgo!</p>
<p>I maintain a Go codebase at work which does most of its work through a Rust library that exposes a C API. So they interact via Cgo, Go's FFI mechanism. And it works!</p>
<p>Also, Cgo has many weird limitations and surprises. Fortunately, over the two years or so I have been working in this project, I have (re-)discovered solutions for most of these issues. Let's go through them, and hopefully the next time you use Cgo, you'll have a smooth experience.</p>
<p><em>From Go's perspective, Rust is invisible, the C library looks like a pure C library (and indeed it used to be 100% C++ before it got incrementally rewritten to Rust). So I will use C snippets in this article, because that's what the public C header of the library looks like, and not everybody knows Rust, but most people know a C-like language. But worry not, I will still talk at lengths about Rust in the last section.</em></p>
<p>Let's create a sample app:</p>
<pre><code>.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ app.go
‚îú‚îÄ‚îÄ c
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api.c
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api.h
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api.o
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ libapi.a
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ go.mod
‚îî‚îÄ‚îÄ main.go
</code></pre>
<p>The C code is in the <code>c</code> directory, we build a static library <code>libapi.a</code> from it. The public header file is <code>api.h</code>.</p>
<p>The Go code then links this library.</p>
<p><em>The full code can be found at the end of this article.</em></p>
<h2>CGO does not have unions</h2>
<p>This is known to Go developers: Go does not have tagged unions, also called sum types, algebraic data types, etc. But C, and Rust, do have them, and Go needs to generate Go types for each C type, so that we can use them! So what does it do? Let's have a look.</p>
<p>So, here is a (very useful) C tagged union:</p>
<pre><code class="language-c">// c/api.h

#pragma once
#include &lt;stdint.h&gt;

typedef struct {
  char *data;
  uint64_t len;
} String;

typedef enum {
  ANIMAL_KIND_DOG,
  ANIMAL_KIND_CAT,
} AnimalKind;

typedef struct {
  AnimalKind kind;
  union {
    String cat_name;   // Only for `ANIMAL_KIND_CAT`.
    uint16_t dog_tail; // Only for `ANIMAL_KIND_DOG`.
  };
} Animal;

Animal animal_make_dog();

Animal animal_make_cat();

void animal_print(Animal *animal);
</code></pre>
<p>The C implementation is straightforward:</p>
<pre><code class="language-c">// c/api.c

#include &quot;api.h&quot;
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;

Animal animal_make_dog() {
  return (Animal){
      .kind = ANIMAL_KIND_DOG,
      .dog_tail = 42,
  };
}

Animal animal_make_cat() {
  return (Animal){
      .kind = ANIMAL_KIND_CAT,
      .cat_name =
          {
              .data = &quot;kitty&quot;,
              .len = 5,
          },
  };
}

void animal_print(Animal *animal) {
  switch (animal-&gt;kind) {
  case ANIMAL_KIND_DOG:
    printf(&quot;Dog: %&quot; PRIu16 &quot;\n&quot;, animal-&gt;dog_tail);
    break;
  case ANIMAL_KIND_CAT:
    printf(&quot;Cat: %.*s\n&quot;, (int)animal-&gt;cat_name.len, animal-&gt;cat_name.data);
    break;
  default:
    assert(0 &amp;&amp; &quot;unreachable&quot;);
  }
}
</code></pre>
<p>And here's how we use it in Go:</p>
<pre><code class="language-go">// app/app.go

package app

// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
import &quot;C&quot;
import &quot;fmt&quot;

func DoStuff() {
	dog := C.animal_make_dog()
	C.animal_print(&amp;dog)

	cat := C.animal_make_cat()
	C.animal_print(&amp;cat)
}
</code></pre>
<p>So far, so good. Let's run it (our <code>main.go</code> simply calls <code>app.DoStuff()</code>):</p>
<pre><code class="language-sh">$ go run .
Dog: 42
Cat: kitty
</code></pre>
<p>Great!</p>
<p>Now, let's say we want to access the fields of the C tagged union. We can to have some logic based on whether our cat's name is greater than a limit, say 255? What does the Go struct look like for <code>Animal</code>?</p>
<pre><code class="language-go">type _Ctype_struct___0 struct {
	kind	_Ctype_AnimalKind
	_	[4]byte
	anon0	[16]byte
}
</code></pre>
<p>So it's a struct with a <code>kind</code> field, so far so good. Then comes 4 bytes of padding, as expected (the C struct also has them). But then, we only see 16 opaque bytes. The size is correct: the C union is the size of its largest member which is 16 bytes long (<code>String</code>). But then, how do we access <code>String.len</code>?</p>
<p>Here's the very tedious way, by hand:</p>
<pre><code class="language-go">// app/app.go
func DoStuff() {
    // [...]

	cat_ptr := unsafe.Pointer(&amp;cat)
	cat_name_ptr := unsafe.Add(cat_ptr, 8)
	cat_name_len_ptr := unsafe.Add(cat_name_ptr, 8)
	fmt.Println(*(*C.uint64_t)(cat_name_len_ptr))
}
</code></pre>
<p>And we get:</p>
<pre><code>$ go run .
Dog: 42
Cat: kitty
5
</code></pre>
<p>Ok, we are a C compiler now. Back to computing fields offsets by hand! I sure hope you do not forget about alignment! And keep the offsets in sync with the C struct when its layout changes!</p>
<p>Well we all agree this sucks, but that's all what the <code>unsafe</code> package offers. Cherry on the cake, every pointer in this code has the same type: <code>unsafe.Pointer</code>, even though the first one really is a <code>Animal*</code>, the second one is a <code>String*</code>, and the third one is a <code>uint64_t*</code>. Not great.</p>
<p>So the solution is: treat C unions as opaque values in Go, and only access them with C functions (essentially, getters and setters):</p>
<pre><code class="language-c">// c/api.h

uint16_t animal_dog_get_tail(Animal *animal);

String animal_cat_get_name(Animal *animal);
</code></pre>
<pre><code class="language-c">// c/api.c

uint16_t animal_dog_get_tail(Animal *animal) {
  assert(ANIMAL_KIND_DOG == animal-&gt;kind);
  return animal-&gt;dog_tail;
}

String animal_cat_get_name(Animal *animal) {
  assert(ANIMAL_KIND_CAT == animal-&gt;kind);
  return animal-&gt;cat_name;
}
</code></pre>
<p>And now we have a sane Go code:</p>
<pre><code class="language-go">// app/app.go
func DoStuff() {
    // [...]

	cat_name := C.animal_cat_get_name(&amp;cat)
	fmt.Println(cat_name.len)
}
</code></pre>
<p>And as a bonus, whenever the layout of <code>Animal</code> changes, for example the order of fields gets changed, or a new field gets added which changes the alignment and thus the padding (here it's not the case because the alignment is already 8 which is the maximum, but in other cases it could happen), the C code gets recompiled, it does the right thing automatically, and everything works as expected.</p>
<p><strong>My recommendation:</strong> never role-play as a compiler, just use getters and setters for unions and let the C compiler do the dirty work.</p>
<p><strong>My ask to the Go team:</strong> mention the approach with getters and setters in the docs. The only thing the <a href="https://pkg.go.dev/cmd/cgo">docs</a> have to say about unions right now is: <code>As Go doesn't have support for C's union type in the general case, C's union types are represented as a Go byte array with the same length</code>. And I don't expect Go to have (tagged) unions anytime soon, so that's the best we can do.</p>
<h2>Slices vs Strings</h2>
<p>Quick Go trivia question: what's the difference between <code>[]byte</code> (a slice of bytes) and <code>string</code> (which is a slice of bytes underneath)?</p>
<p>...</p>
<p>The former is mutable while the latter is immutable.
Yes, I might have learned that while writing this article.</p>
<p>Anyways, converting C slices (pointer + length) to Go is straightforward using the <code>unsafe</code> package in modern Go (it used to be much hairier in older Go versions):</p>
<pre><code class="language-go">// app/app.go
func DoStuff() {
    // [...]

	cat_name := C.animal_cat_get_name(&amp;cat)
	slice := unsafe.Slice(cat_name.data, cat_name.len)
	str := unsafe.String((*byte)(unsafe.Pointer(cat_name.data)), cat_name.len)

	fmt.Println(slice)
	fmt.Println(str)
}
</code></pre>
<p>And it does what we expect:</p>
<pre><code class="language-sh">$ go run .
Dog: 42
Cat: kitty
[107 105 116 116 121]
kitty
</code></pre>
<p>Ok, but just reading them is boring, let's try to mutate them. First, we need to allocate a fresh string in C, otherwise the string constant will be located in the read-only part of the executable, mapped to read-only page, and we will segfault when trying to mutate it. So we modify <code>animal_make_cat</code>:</p>
<pre><code class="language-c">// c/api.c

Animal animal_make_cat() {
  return (Animal){
      .kind = ANIMAL_KIND_CAT,
      .cat_name =
          {
              .data = strdup(&quot;kitty&quot;), // &lt;= Heap allocation here.
              .len = 5,
          },
  };
}
</code></pre>
<p>Let's mutate all the things!</p>
<pre><code class="language-go">// app/app.go
func DoStuff() {
    // [...]

	slice[0] -= 32 // Poor man's uppercase.
	fmt.Println(slice)
	fmt.Println(str)
}
</code></pre>
<p>And we get the additional output:</p>
<pre><code>[75 105 116 116 121]
Kitty
</code></pre>
<p>But wait, this is undefined behavior! The string <em>did</em> get mutated! The Go compiler generates code based on the assumption that strings are immutable, so our program <em>may</em> break in very unexpected ways.</p>
<p>The docs for <code>unsafe.String</code> state:</p>
<blockquote>
<p>Since Go strings are immutable, the bytes passed to String
must not be modified as long as the returned string value exists.</p>
</blockquote>
<p>Maybe the runtime Cgo checks will detect it?</p>
<pre><code>$ GODEBUG=cgocheck=1 go run .
[...]
[75 105 116 116 121]
Kitty
# Works fine!

$ GOEXPERIMENT=cgocheck2 go run . 
[...]
[75 105 116 116 121]
Kitty
# Works fine!
</code></pre>
<p>Nope... so what can we do about it? In my real-life program I have almost no strings to deal with, but some programs will.</p>
<p><strong>My recommendation:</strong></p>
<ul>
<li>In Go, do not use <code>unsafe.String</code>, just use <code>unsafe.Slice</code> and accept that it's mutable everywhere in the program</li>
<li>If you really want to use <code>unsafe.String</code>, make sure that the string data returned by the C code is immutable, <strong>enforced by the OS</strong>, so either:
<ul>
<li>It's a constant string placed in the read-only segment</li>
<li>The string data is allocated in its own virtual memory page and the page permissions are changed to read-only before returning the pointer to Go</li>
</ul>
</li>
<li>In C, do not expose string data directly to Go, only expose opaque values (<code>void*</code>), and mutations are only done by calling a C function. That way, the Go caller simply cannot use <code>unsafe.String</code> (I guess they could with lots of casts, but that's not in the realm of a <em>honest mistake</em> anymore).</li>
</ul>
<p><strong>My ask to the Go team:</strong> attempt to develop more advanced checks to detect this issue at runtime.</p>
<h2>Test a C function in Go tests</h2>
<p>We are principled programmers who write tests. Let's write a test to ensure that <code>animal_make_dog()</code> does indeed create a dog, i.e. the kind is <code>ANIMAL_KIND_DOG</code>:</p>
<pre><code class="language-go">// app/app_test.go

package app

import &quot;testing&quot;
import &quot;C&quot;

func TestAnimalMakeDog(t *testing.T) {
	dog := C.animal_make_dog()
	_ = dog
}
</code></pre>
<p>Let's run it:</p>
<pre><code class="language-sh">$ go test ./app/
use of cgo in test app_test.go not supported
</code></pre>
<p>Ah... yeah this is a <a href="https://go.dev/wiki/cgo">known limitation</a>: <code>_test.go files can‚Äôt use cgo.</code>.</p>
<p>Solution: wrap the C function in a Go one.</p>
<pre><code>// app/app.go

func AnimalDogKind() int {
	return C.ANIMAL_KIND_DOG
}

func AnimalMakeDog() C.Animal {
	return C.animal_make_dog()
}
</code></pre>
<p>And we now have a passing Go test:</p>
<pre><code class="language-go">// app/app_test.go

package app

import &quot;testing&quot;

func TestAnimalMakeDog(t *testing.T) {
	dog := AnimalMakeDog()
	if int(dog.kind) != AnimalDogKind() {
		panic(&quot;wrong kind&quot;)
	}
}
</code></pre>
<pre><code class="language-sh">$ go test ./app/ -count=1 -v
=== RUN   TestAnimalMakeDog
--- PASS: TestAnimalMakeDog (0.00s)
PASS
ok  	cgo/app	0.003s
</<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
ratch, you will have noticed it takes a significant amount of time still. What Go is really good at, is caching: it's really smart at detecting what changed, and only rebuilding that. And that's great! Until it isn't.</p>
<p>Sometimes, changes to the Cgo build flags, or to the <code>.a</code> library, were not detected by Go. I could not really reproduce these issues reliably, but they do happen.</p>
<p>Solution: force a clean build with <code>go build -a</code>.</p>
<h2>False positive warnings</h2>
<p>Sometimes we need to run some C code once at startup, when the package gets initialized:</p>
<pre><code class="language-Go">// app/app.go

package app

// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
// void initial_setup();
import &quot;C&quot;

func init() {
	C.initial_setup()
}


[...]
</code></pre>
<p>And the C function <code>initial_setup</code> is defined in a second file in the same Go package (this is not strictly necessary but it will turn out to be useful to showcase something later):</p>
<pre><code class="language-go">// app/cfuncs.go

package app

/*
void initial_setup(){
    // Do some useful stuff.
}
*/
import &quot;C&quot;
</code></pre>
<p>Yes, we can write C code directly in Go files. Inside comments. Not, it's not weird at all.</p>
<p>We build, everything is fine:</p>
<pre><code class="language-sh">$ go build .
</code></pre>
<p>Since we are serious programmers, we want to enable C warnings, right? Let's add <code>-Wall</code> to the <code>CFLAGS</code>:</p>
<pre><code class="language-go">// app/app.go

[...]
// #cgo CFLAGS: -Wall -g -O2 -I${SRCDIR}/../c/    &lt;= We add -Wall
[...]
</code></pre>
<p>We re-build, and get this nice error:</p>
<pre><code class="language-go">$ go build .
# cgo/app
cgo-gcc-prolog: In function ‚Äò_cgo_13d20cc583d0_Cfunc_initial_setup‚Äô:
cgo-gcc-prolog:78:49: warning: unused variable ‚Äò_cgo_a‚Äô [-Wunused-variable]
</code></pre>
<p>Wait, we do not have <em>any</em> variable in <code>initial_setup</code>, how come a variable is unused?</p>
<p>Some searching around turns up this <a href="https://github.com/golang/go/issues/6883#issuecomment-383800123,">Github issue</a> where the official recommendation is: do not use <code>-Wall</code>, it creates false positives. Ok.</p>
<p><strong>My recommendation:</strong> Write C code in C files and enable all the warnings you want.</p>
<p><strong>My ask to the Go team:</strong> Let's please fix the false positives and allow people to enable some basic warnings. <code>-Wall</code> is the bare minimum!</p>
<h2>White space is significant</h2>
<p>Let's go back to the <code>app/cfuncs.go</code> we just created that builds fine:</p>
<pre><code class="language-go">package app

/*
void initial_setup(){}
*/
import &quot;C&quot;
</code></pre>
<p>Let's add one empty line near the end:</p>
<pre><code class="language-go">
package app

/*
void initial_setup(){}
*/

import &quot;C&quot;
</code></pre>
<p>Let's build:</p>
<pre><code class="language-sh">$ go build .
# cgo
/home/pg/Downloads/go/pkg/tool/linux_amd64/link: running gcc failed: exit status 1
/usr/bin/gcc -m64 -o $WORK/b001/exe/a.out -Wl,--export-dynamic-symbol=_cgo_panic -Wl,--export-dynamic-symbol=_cgo_topofstack -Wl,--export-dynamic-symbol=crosscall2 -Wl,--compress-debug-sections=zlib /tmp/go-link-2748897775/go.o /tmp/go-link-2748897775/000000.o /tmp/go-link-2748897775/000001.o /tmp/go-link-2748897775/000002.o /tmp/go-link-2748897775/000003.o /tmp/go-link-2748897775/000004.o /tmp/go-link-2748897775/000005.o /tmp/go-link-2748897775/000006.o /tmp/go-link-2748897775/000007.o /tmp/go-link-2748897775/000008.o /tmp/go-link-2748897775/000009.o /tmp/go-link-2748897775/000010.o /tmp/go-link-2748897775/000011.o /tmp/go-link-2748897775/000012.o /tmp/go-link-2748897775/000013.o /tmp/go-link-2748897775/000014.o /tmp/go-link-2748897775/000015.o /tmp/go-link-2748897775/000016.o -O2 -g /home/pg/scratch/cgo/app/../c/libapi.a -O2 -g -lpthread -no-pie
/usr/bin/ld: /tmp/go-link-2748897775/000001.o: in function `_cgo_f1a74d84225f_Cfunc_initial_setup':
/tmp/go-build/cgo-gcc-prolog:80:(.text+0x53): undefined reference to `initial_setup'
collect2: error: ld returned 1 exit status
</code></pre>
<p>Ok... not much to say here.</p>
<p>Here's another example. We add a comment about not using <code>-Wall</code>:</p>
<pre><code class="language-go">// app/app.go

package app

// NOTE: Do not use -Wall.
// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
// void initial_setup();
import &quot;C&quot;

[...]
</code></pre>
<p>We rebuild, and boom:</p>
<pre><code class="language-sh">$ go build .
# cgo/app
app/app.go:3:6: error: expected '=', ',', ';', 'asm' or '__attribute__' before ':' token
    3 | // NOTE: Do not use -Wall.
      |      ^
</code></pre>
<p>That's because when seeing a <code>#cgo</code> directive in the comments, the Go compiler parses what it recognizes, passes the rest to the C compiler, which chokes on it.</p>
<p>Solution: insert a blank line between the comment and the <code>#cgo</code> directive to avoid that:</p>
<pre><code class="language-go">// app/app.go

package app

// NOTE: Do not use -Wall.

// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
// void initial_setup();
import &quot;C&quot;

[...]
</code></pre>
<p><strong>My recommendation:</strong> If you get a hairy and weird error, compare the white space with official code examples.</p>
<p><strong>My ask to the Go team:</strong> Can we please fix this? Or at least document it? There is zero mention of this pitfall anywhere, as far as I can see.</p>
<h2>Debug Go and C/Rust</h2>
<p>It's very simple, you have two exclusive choices:</p>
<ul>
<li>Use a C/Rust debugger (e.g gdb, lldb, etc), which does not understand the Go calling convention so you can see the C/Rust call stack, but it ends at the Cgo FFI boundary, or</li>
<li>Use a Go debugger (e.g. delve) which does not (really) understand the C/Rust calling convention so you can see the Go stack, but it ends at the Cgo FFI boundary</li>
</ul>
<p>Let's see it for ourselves:</p>
<pre><code class="language-sh">$ gdb ./cgo
(gdb) break animal_print
Breakpoint 1 at 0x469b6c
(gdb) run
[...]
Thread 1 &quot;cgo&quot; hit Breakpoint 1, 0x0000000000469b6c in animal_print ()
(gdb) backtrace
#0  0x0000000000469b6c in animal_print ()
#1  0x0000000000464644 in runtime.asmcgocall () at /home/pg/Downloads/go/src/runtime/asm_amd64.s:923
#2  0x000000c0000061c0 in ?? ()
#3  0x0000000000462a0a in runtime.systemstack () at /home/pg/Downloads/go/src/runtime/asm_amd64.s:514
#4  0x00007fffffffe228 in ?? ()
#5  0x0000000000466f3f in runtime.newproc (fn=0x46288f &lt;runtime.rt0_go+303&gt;) at &lt;autogenerated&gt;:1
#6  0x0000000000462905 in runtime.mstart () at /home/pg/Downloads/go/src/runtime/asm_amd64.s:395
#7  0x000000000046288f in runtime.rt0_go () at /home/pg/Downloads/go/src/runtime/asm_amd64.s:358
#8  0x0000000000000001 in ?? ()
#9  0x00007fffffffe388 in ?? ()
#10 0x00007fffffffe340 in ?? ()
#11 0x0000000000000001 in ?? ()
#12 0x00007fffffffe388 in ?? ()
#13 0x00007ffff7db1248 in __libc_start_call_main (main=0x300000002, argc=192, argv=0x43a3c5 &lt;runtime.reentersyscall+165&gt;) at ../sysdeps/nptl/libc_start_call_main.h:58
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
</code></pre>
<p>Where is <code>app.DoStuff</code>? Where is <code>main</code>? Probably around frames 8-13 in the <code>corrupt stack</code>...</p>
<p>Now with <code>delve</code>:</p>
<pre><code class="language-sh">$ go build   -gcflags=all=&quot;-N -l&quot;
$ dlv exec ./cgo
(dlv) b animal_print
Command failed: could not find function C.animal_print

(dlv) b app.DoStuff
Breakpoint 1 set at 0x471f2a for cgo/app.DoStuff() ./app/app.go:23
(dlv) c
&gt; [Breakpoint 1] cgo/app.DoStuff() ./app/app.go:23 (hits goroutine(1):1 total:1) (PC: 0x471f2a)
    18:	
    19:	func AnimalMakeDog() C.Animal {
    20:		return C.animal_make_dog()
    21:	}
    22:	
=&gt;  23:	func DoStuff() {
    24:		dog := C.animal_make_dog()
    25:		C.animal_print(&amp;dog)
    26:	
    27:	}
(dlv) s
&gt; cgo/app.DoStuff() ./app/app.go:24 (PC: 0x471f2e)
    19:	func AnimalMakeDog() C.Animal {
    20:		return C.animal_make_dog()
    21:	}
    22:	
    23:	func DoStuff() {
=&gt;  24:		dog := C.animal_make_dog()
    25:		C.animal_print(&amp;dog)
    26:	
    27:	}
(dlv) 
&gt; cgo/app._Cfunc_animal_make_dog() _cgo_gotypes.go:79 (PC: 0x471d93)
(dlv) 
&gt; cgo/app._Cfunc_animal_make_dog() _cgo_gotypes.go:80 (PC: 0x471dab)
(dlv) 
&gt; cgo/app._Cfunc_animal_make_dog() _cgo_gotypes.go:81 (PC: 0x471dd3)
(dlv) 
&gt; cgo/app._Cfunc_animal_make_dog() _cgo_gotypes.go:83 (PC: 0x471de4)
(dlv) 
&gt; cgo/app.DoStuff() ./app/app.go:24 (PC: 0x471f45)
Values returned:
	r1: cgo/app._Ctype_struct___0 {
		kind: 0,
		_: [4]uint8 [0,0,0,0],
		anon0: [16]uint8 [42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],}

    19:	func AnimalMakeDog() C.Animal {
    20:		return C.animal_make_dog()
    21:	}
    22:	
    23:	func DoStuff() {
=&gt;  24:		dog := C.animal_make_dog()
    25:		C.animal_print(&amp;dog)
    26:	
    27:	}
(dlv) 
&gt; cgo/app.DoStuff() ./app/app.go:25 (PC: 0x471f67)
    20:		return C.animal_make_dog()
    21:	}
    22:	
    23:	func DoStuff() {
    24:		dog := C.animal_make_dog()
=&gt;  25:		C.animal_print(&amp;dog)
    26:	
    27:	}
(dlv) 
&gt; cgo/app.DoStuff() ./app/app.go:25 (PC: 0x471f67)
    20:		return C.animal_make_dog()
    21:	}
    22:	
    23:	func DoStuff() {
    24:		dog := C.animal_make_dog()
=&gt;  25:		C.animal_print(&amp;dog)
    26:	
    27:	}
(dlv) s
&gt; cgo/app._Cfunc_animal_print() _cgo_gotypes.go:91 (PC: 0x471e13)
(dlv) s
&gt; cgo/app._Cfunc_animal_print() _cgo_gotypes.go:92 (PC: 0x471e17)
(dlv) stack
0  0x0000000000471e17 in cgo/app._Cfunc_animal_print
   at _cgo_gotypes.go:92
1  0x0000000000471f75 in cgo/app.DoStuff
   at ./app/app.go:25
2  0x000000000047228f in main.main
   at ./main.go:6
3  0x0000000000437a07 in runtime.main
   at /home/pg/Downloads/go/src/runtime/proc.go:272
4  0x000000000046c301 in runtime.goexit
   at /home/pg/Downloads/go/src/runtime/asm_amd64.s:1700
</code></pre>
<p>So the Go debugger does not understand C/Rust debugging information, so as soon as we are inside a C/Rust function, it cannot show anything useful, but it can still kind of understand the call stack...Urgh.</p>
<p>And the <a href="https://go.dev/doc/gdb">docs</a> acknowledge that:</p>
<blockquote>
<p>GDB does not understand Go programs well. The stack management, threading, and runtime contain aspects that differ enough from the execution model GDB expects that they can confuse the debugger and cause incorrect results even when the program is compiled with gccgo. As a consequence, although GDB can be useful in some situations (e.g., debugging Cgo code, or debugging the runtime itself), it is not a reliable debugger for Go programs, particularly heavily concurrent ones. Moreover, it is not a priority for the Go project to address these issues, which are difficult.</p>
</blockquote>
<p>And it's not an issue of missing debugging information, I compiled the C code with <code>-g</code>, or <code>-g3</code>.</p>
<p>This point is close to being a deal-breaker for me. Debugging is really important! A language/tech stack is IMHO only as good as we developers can understand and troubleshoot production applications. Can't debug, can't pinpoint where the bug is? Not sure if that program is worth much.</p>
<p><strong>My recommendation:</strong>: Have both debuggers at hand and locate where the problem is: is it on the Go side or on the C/Rust side? Then use the right debugger to inspect local variables and such. Yes, it's a pity. I guess you can try to build Go code with Gccgo, perhaps gdb understands the full call stack then? My approach was to insert logs everywhere in the code, both Go and Rust, with logs. Not ideal. It's a bit too close to 'printf debugging' to my taste.</p>
<p><strong>My ask for the Go team:</strong>: Well, ideally both debuggers would work fully with CGO. But since this issue is known for years...I don't have much hope.</p>
<h3>Strace, bpftrace</h3>
<p>It's the same issue manifesting in a different way: it's not just debuggers than do not understand the call stack, it's also <code>strace</code>:</p>
<pre><code class="language-sh">$ strace -k -e write ./cgo
--- SIGURG {si_signo=SIGURG, si_code=SI_TKILL, si_pid=438876, si_uid=1000} ---
 &gt; /usr/lib64/libc.so.6(pthread_sigmask@GLIBC_2.2.5+0x48) [0x783b8]
 &gt; /home/pg/scratch/cgo/cgo(_cgo_sys_thread_start+0x7e) [0x4727ee]
 &gt; /home/pg/scratch/cgo/cgo(runtime.asmcgocall.abi0+0x9c) [0x46c01c]
write(1, &quot;Dog: 42\n&quot;, 8Dog: 42
)                = 8
 &gt; /usr/lib64/libc.so.6(__write+0x4d) [0xe853d]
 &gt; /usr/lib64/libc.so.6(_IO_file_write@@GLIBC_2.2.5+0x34) [0x68fa4]
 &gt; /usr/lib64/libc.so.6(new_do_write+0x5c) [0x6711c]
 &gt; /usr/lib64/libc.so.6(_IO_do_write@@GLIBC_2.2.5+0x20) [0x67fb0]
 &gt; /usr/lib64/libc.so.6(_IO_file_overflow@@GLIBC_2.2.5+0x11a) [0x6852a]
 &gt; /usr/lib64/libc.so.6(_IO_default_xsputn+0x74) [0x6a624]
 &gt; /usr/lib64/libc.so.6(_IO_file_xsputn@@GLIBC_2.2.5+0x117) [0x69127]
 &gt; /usr/lib64/libc.so.6(__printf_buffer_flush_to_file+0xc8) [0x36448]
 &gt; /usr/lib64/libc.so.6(__printf_buffer_to_file_done+0x1b) [0x3650b]
 &gt; /usr/lib64/libc.so.6(__vfprintf_internal+0xaa) [0x41bea]
 &gt; /usr/lib64/libc.so.6(printf+0xb2) [0x35bf2]
 &gt; /home/pg/scratch/cgo/cgo(animal_print+0x38) [0x472da0]
 &gt; /home/pg/scratch/cgo/cgo(runtime.asmcgocall.abi0+0x63) [0x46bfe3]
 &gt; No DWARF information found
+++ exited with 0 +++
</code></pre>
<p>Same as gdb, the call stack stops at the Cgo FFI boundary.</p>
<p>But surprisingly, <code>bpftrace</code> seems to work:</p>
<pre><code class="language-sh">$ sudo bpftrace -e 'uprobe:./cgo:animal_print {print(ustack(perf, 64))}' -c ./cgo
Attaching 1 probe...
Dog: 42

	472d68 animal_print+0 (./cgo)
	46bfe4 runtime.asmcgocall.abi0+100 (./cgo)
	46361f runtime.cgocall+127 (./cgo)
	471e3f cgo/app._Cfunc_animal_print.abi0+63 (./cgo)
	471f75 cgo/app.DoStuff+85 (./cgo)
	47228f main.main+15 (./cgo)
	437a07 runtime.main+583 (./cgo)
	46c301 runtime.goexit.abi0+1 (./cgo)
</code></pre>
<p>So, let's use <code>bpftrace</code>, I guess.</p>
<h2>Cross-compile</h2>
<p>So picture me, building my Go program (a web service) using Cgo. Locally, it builds very quickly, due to Rust and Go caching.</p>
<p>Now, time to build in Docker to be able to test my changes:</p>
<pre><code class="language-sh">$ time docker build [...]
[...]
Total execution time 101.664413146
</code></pre>
<p>That's in seconds. Every. Single. Time. Urgh.</p>
<p>The issue is that little to no caching is being leveraged by either compiler. Dependencies are fetched from the internet, and essentially, a clean release build is performed. That takes a looong time. Past developers tried to fix this by volume mounting host directories inside Docker but apparently, they missed a few.</p>
<p>That's why I am convinced that Docker is not meant to build stuff. Only to run stuff. I have seen the same problem with C++ codebases being built in Docker, with Rust codebases being built in Docker, etc. Even with JavaScript/Typescript codebases built in docker (these were for some reason often the slowest to build). In the worst cases it would take over an hour to build, and developers resorted to duplicate the deployment setup to be able to run (and thus test) the app locally, completely bypassing Docker.</p>
<p>I think the original intent to do a clean build inside Docker was because developers feared that the local environment was somehow tainted and/or that the compiler would mess up with the caching and result in a borked build. And that was the case I believe, with most C/C++ codebase relying on globally installed libraries built how-knows-how. But modern compilers are, from my perspective, really good at identifying changes, correctly caching what did not change, and rebuilding with the correct build flags, what does need to be rebuilt. And developers have improved on the Bill Of Material side. Much work has been done on existing tools to get reproducible builds. New tools have emerged, like Nix, that focus on controlled reproducible builds.</p>
<p>So in my opinion, the ideal Docker build process is: a single static executable is built locally, relying on caching of previous builds (or possibly in CI, remote intermediate artifacts). Then, it is copied inside the image which, again ideally, for security purposes, is very bare bone. The dockerfile can look like this:</p>
<pre><code class="language-dockerfile">FROM gcr.io/distroless/static:nonroot
USER nonroot
WORKDIR /home/nonroot

COPY --chown=nonroot:nonroot app.exe .

CMD [&quot;/home/nonroot/app.exe&quot;]
</code></pre>
<p>It's fast, simple, secure. But, to make it work, regardless of the host, we need to cross-compile.</p>
<p>Go is praised for its uncomplicated cross-compiling support. But this goes out of the window when Cgo is enabled. Let's try:</p>
<pre><code class="language-sh">$ GOOS=linux GOARCH=arm go build  .
cgo/app: build constraints exclude all Go files in /home/pg/scratch/cgo/app
</code></pre>
<p>It fails. But fortunately, Go still supports cross-compiling with Cgo as long as we provide it with a cross-compiler.</p>
<p>After some experimentation, my favorite way is to use <a href="https://dev.to/kristoff/zig-makes-go-cross-compilation-just-work-29ho">Zig</a> for that. That way it works the same way for people using macOS, Linux, be it on ARM, on x86_64, etc. And it makes it trivial to build native Docker images for ARM without changing the whole build system or installing additional tools.</p>
<p>The work on Zig is fantastic, please consider supporting them!</p>
<p>So, how does it look like? Let's assume we want to target <code>x86_64-linux-musl</code>, built statically, since we use a distroless image that does not come with a libc. The benefit is that our service looks like any other Go service without Cgo.</p>
<p>We could also target a specific glibc version and deploy on a LTS version of Ubuntu, Debian, etc. Zig supports that.</p>
<p>First, we cross-compile our C code:</p>
<pre><code class="language-sh">$ CC=&quot;zig cc --target=x86_64-linux-musl&quot; make -C ./c
</code></pre>
<p>Or, bring your own cross-compiler, you don't have to use Zig:</p>
<pre><code>$ CC=musl-gcc make -C ./c
</code></pre>
<p>If we have Rust code, we do instead:</p>
<pre><code class="language-sh">$ rustup target add x86_64-unknown-linux-musl
$ cargo build --release --all-features --target=x86_64-unknown-linux-musl
</code></pre>
<p>Then we build our Go code using the Zig C compiler. I put the non cross-compiling build commands just before for comparison:</p>
<pre><code class="language-sh">$ go build .
$ file cgo
cgo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9d5da9b6a211c5635a83e4a8a346ff605f7b6e3b, for GNU/Linux 3.2.0, with debug_info, not stripped

$ CGO_ENABLED=1 CC='zig cc --target=x86_64-linux-musl -static' GOOS=linux GOARCH=amd64 go build .
$ file cgo
cgo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=gTeiH1YL9FSvJJ2euuGd/P0s07MkwoQlcaBA6EXDD/NOYPaeKuxUZ0cnLxfpC9/YeAu_C7s53nGjPEKZDYI, with debug_info, not stripped
</code></pre>
<p>Ta dam!</p>
<p>Time to build a native ARM image? No problem:</p>
<pre><code class="language-sh">$ CC=&quot;zig cc --target=aarch64-linux-musl&quot; make -C ./c
$ CGO_ENABLED=1 CC='zig cc --target=aarch64-linux-musl -static' GOOS=linux GOARCH=arm64 go build .
$ file ./cgo
./cgo: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, Go BuildID=QRDa72MrAj44K3mt54PK/_aJwgCwTO37mKpnfElWN/0TEmGFNLMEZCx3Zv_PKs/lgDlIHFQ6-LxhCOsdhQI, with debug_info, not stripped
</code></pre>
<p>If you've done <em>any</em> work with cross-compilation, you know that this is magic. It's supposed to take weeks to make it work, dammit!</p>
<blockquote>
<p>Note: Rust code typically needs libunwind for printing a backtrace, so it needs to be cross-compiled and linked as well. But no worries, Zig has you covered, it ships with libunwind sources and will, just like with musl, build it for your target, and cache the results! Just add <code>-lunwind</code> to the <code>zig cc</code> invocation, and voila.</p>
</blockquote>
<p>Oh, and what about the speed now? Here is a full Docker build with my real-life program (Rust + Go):</p>
<pre><code class="language-sh">$ make docker-build
Executed in    1.47 secs
</code></pre>
<p>That time includes <code>cargo build --release</code>, <code>go build</code>, and <code>docker build</code>. Most of the time is spent copying the giant executable (around 72 MiB!) into the Docker image since neither Rust nor Go are particularly good at producing small executables.</p>
<p>So, we went from ~100s to ~1s, roughly a 100x improvement. Pretty pretty good if you ask me.</p>
<p><strong>My recommendation:</strong>: Never build in Docker if you can avoid it. Build locally and copy the one static executable into the Docker image.</p>
<p><strong>My ask for the Go team</strong>: None actually, they have done an amazing job on the build system to support this use-case, and on the documentation.</p>
<h2>Conclusion</h2>
<p>Cgo is rocky, but there are no real blocking issues, apart from the debugging pain point, mostly lots of small pains. Half the cure is being aware of the ailment, as the saying goes. So armed with this knowledge, I wish you god speed with your Cgo projects!</p>
<h2>Addendum: the full code</h2>
<details>
  <summary>The full code</summary>
<p><code>c/Makefile:</code></p>
<pre><code class="language-make">libapi.a: api.o
	$(AR) -rcs libapi.a api.o

api.o: api.c
	$(CC) $(CFLAGS) api.c -c
</code></pre>
<p><code>c/api.c:</code></p>
<pre><code class="language-c">#include &quot;api.h&quot;
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

Animal animal_make_dog() {
  return (Animal){
      .kind = ANIMAL_KIND_DOG,
      .dog_tail = 42,
  };
}

Animal animal_make_cat() {
  return (Animal){
      .kind = ANIMAL_KIND_CAT,
      .cat_name =
          {
              .data = strdup(&quot;kitty&quot;),
              .len = 5,
          },
  };
}

void animal_print(Animal *animal) {
  switch (animal-&gt;kind) {
  case ANIMAL_KIND_DOG:
    printf(&quot;Dog: %&quot; PRIu16 &quot;\n&quot;, animal-&gt;dog_tail);
    break;
  case ANIMAL_KIND_CAT:
    printf(&quot;Cat: %.*s\n&quot;, (int)animal-&gt;cat_name.len, animal-&gt;cat_name.data);
    break;
  default:
    assert(0 &amp;&amp; &quot;unreachable&quot;);
  }
}

uint16_t animal_dog_get_tail(Animal *animal) {
  assert(ANIMAL_KIND_DOG == animal-&gt;kind);
  return animal-&gt;dog_tail;
}

String animal_cat_get_name(Animal *animal) {
  assert(ANIMAL_KIND_CAT == animal-&gt;kind);
  return animal-&gt;cat_name;
}
</code></pre>
<p><code>c/api.h:</code></p>
<pre><code class="language-c">#pragma once
#include &lt;stdint.h&gt;

typedef struct {
  char *data;
  uint64_t len;
} String;

typedef enum {
  ANIMAL_KIND_DOG,
  ANIMAL_KIND_CAT,
} AnimalKind;

typedef struct {
  AnimalKind kind;
  union {
    String cat_name;   // Only for `ANIMAL_KIND_CAT`.
    uint16_t dog_tail; // Only for `ANIMAL_KIND_DOG`.
  };
} Animal;

Animal animal_make_dog();

Animal animal_make_cat();

void animal_print(Animal *animal);

uint16_t animal_dog_get_tail(Animal *animal);

String animal_cat_get_name(Animal *animal);
</code></pre>
<p><code>app/app.go:</code></p>
<pre><code class="language-go">package app

// NOTE: Do not use -Wall.

// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
// void initial_setup();
import &quot;C&quot;

func init() {
	C.initial_setup()
}

func AnimalDogKind() int {
	return C.ANIMAL_KIND_DOG
}

func AnimalMakeDog() C.Animal {
	return C.animal_make_dog()
}

func DoStuff() {
	dog := C.animal_make_dog()
	C.animal_print(&amp;dog)

}
</code></pre>
<p><code>app/app_test.go:</code></p>
<pre><code class="language-go">package app

import &quot;testing&quot;

func TestAnimalMakeDog(t *testing.T) {
	dog := AnimalMakeDog()
	if int(dog.kind) != AnimalDogKind() {
		panic(&quot;wrong kind&quot;)
	}
}
</code></pre>
<p><code>app/cfuncs.go:</code></p>
<pre><code class="language-go">package app

/*
void initial_setup(){}
*/
import &quot;C&quot;
</code></pre>
<p><code>main.go:</code></p>
<pre><code class="language-go">package main

import &quot;cgo/app&quot;

func main() {
	app.DoStuff()
}
</code></pre>
<p><code>go.mod:</code></p>
<pre><code>module cgo

go 1.23.1
</code></pre>
</details>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
>
</html>
CC) $(CFLAGS) api.c -c
</code></pre>
<p><code>c/api.c:</code></p>
<pre><code class="language-c">#include &quot;api.h&quot;
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

Animal animal_make_dog() {
  return (Animal){
      .kind = ANIMAL_KIND_DOG,
      .dog_tail = 42,
  };
}

Animal animal_make_cat() {
  return (Animal){
      .kind = ANIMAL_KIND_CAT,
      .cat_name =
          {
              .data = strdup(&quot;kitty&quot;),
              .len = 5,
          },
  };
}

void animal_print(Animal *animal) {
  switch (animal-&gt;kind) {
  case ANIMAL_KIND_DOG:
    printf(&quot;Dog: %&quot; PRIu16 &quot;\n&quot;, animal-&gt;dog_tail);
    break;
  case ANIMAL_KIND_CAT:
    printf(&quot;Cat: %.*s\n&quot;, (int)animal-&gt;cat_name.len, animal-&gt;cat_name.data);
    break;
  default:
    assert(0 &amp;&amp; &quot;unreachable&quot;);
  }
}

uint16_t animal_dog_get_tail(Animal *animal) {
  assert(ANIMAL_KIND_DOG == animal-&gt;kind);
  return animal-&gt;dog_tail;
}

String animal_cat_get_name(Animal *animal) {
  assert(ANIMAL_KIND_CAT == animal-&gt;kind);
  return animal-&gt;cat_name;
}
</code></pre>
<p><code>c/api.h:</code></p>
<pre><code class="language-c">#pragma once
#include &lt;stdint.h&gt;

typedef struct {
  char *data;
  uint64_t len;
} String;

typedef enum {
  ANIMAL_KIND_DOG,
  ANIMAL_KIND_CAT,
} AnimalKind;

typedef struct {
  AnimalKind kind;
  union {
    String cat_name;   // Only for `ANIMAL_KIND_CAT`.
    uint16_t dog_tail; // Only for `ANIMAL_KIND_DOG`.
  };
} Animal;

Animal animal_make_dog();

Animal animal_make_cat();

void animal_print(Animal *animal);

uint16_t animal_dog_get_tail(Animal *animal);

String animal_cat_get_name(Animal *animal);
</code></pre>
<p><code>app/app.go:</code></p>
<pre><code class="language-go">package app

// NOTE: Do not use -Wall.

// #cgo CFLAGS: -g -O2 -I${SRCDIR}/../c/
// #cgo LDFLAGS: ${SRCDIR}/../c/libapi.a
// #include &lt;api.h&gt;
// void initial_setup();
import &quot;C&quot;

func init() {
	C.initial_setup()
}

func AnimalDogKind() int {
	return C.ANIMAL_KIND_DOG
}

func AnimalMakeDog() C.Animal {
	return C.animal_make_dog()
}

func DoStuff() {
	dog := C.animal_make_dog()
	C.animal_print(&amp;dog)

}
</code></pre>
<p><code>app/app_test.go:</code></p>
<pre><code class="language-go">package app

import &quot;testing&quot;

func TestAnimalMakeDog(t *testing.T) {
	dog := AnimalMakeDog()
	if int(dog.kind) != AnimalDogKind() {
		panic(&quot;wrong kind&quot;)
	}
}
</code></pre>
<p><code>app/cfuncs.go:</code></p>
<pre><code class="language-go">package app

/*
void initial_setup(){}
*/
import &quot;C&quot;
</code></pre>
<p><code>main.go:</code></p>
<pre><code class="language-go">package main

import &quot;cgo/app&quot;

func main() {
	app.DoStuff()
}
</code></pre>
<p><code>go.mod:</code></p>
<pre><code>module cgo

go 1.23.1
</code></pre>
</details>
<p><a href="/blog"> ‚è¥ Back to all articles</a></p>

<blockquote id="donate">
  <p>If you enjoy what you're reading, you want to support me, and can afford it: <a href="https://paypal.me/philigaultier?country.x=DE&locale.x=en_US">Support me</a>. That allows me to write more cool articles!</p>
</blockquote>

<blockquote>
  <p>
    This blog is <a href="https://github.com/gaultier/blog">open-source</a>!
    If you find a problem, please open a Github issue.
    The content of this blog as well as the code snippets are under the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_(%22BSD_License_2.0%22,_%22Revised_BSD_License%22,_%22New_BSD_License%22,_or_%22Modified_BSD_License%22)">BSD-3 License</a> which I also usually use for all my personal projects. It's basically free for every use but you have to mention me as the original author.
  </p>
</blockquote>

</div>
</body>
</html>
